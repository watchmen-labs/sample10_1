diff --git b/tests/config/test_config.py a/tests/config/test_config.py
new file mode 100644
index 0000000..c8c3225
--- /dev/null
+++ a/tests/config/test_config.py
@@ -0,0 +1,165 @@
+from __future__ import annotations
+
+import json
+import os
+import re
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+
+from deepdiff.diff import DeepDiff
+
+from poetry.config.config import Config
+from poetry.config.config import boolean_normalizer
+from poetry.config.config import int_normalizer
+from poetry.utils.password_manager import PasswordManager
+from tests.helpers import flatten_dict
+from tests.helpers import isolated_environment
+
+
+if TYPE_CHECKING:
+    from collections.abc import Callable
+    from collections.abc import Iterator
+
+    from tests.conftest import DummyBackend
+
+    Normalizer = Callable[[str], Any]
+
+
+def get_options_based_on_normalizer(normalizer: Normalizer) -> Iterator[str]:
+    flattened_config = flatten_dict(obj=Config.default_config, delimiter=".")
+
+    for k in flattened_config:
+        if Config._get_normalizer(k) == normalizer:
+            yield k
+
+
+@pytest.mark.parametrize(
+    ("name", "value"),
+    [
+        ("installer.parallel", True),
+        ("virtualenvs.create", True),
+        ("requests.max-retries", 0),
+    ],
+)
+def test_config_get_default_value(config: Config, name: str, value: bool) -> None:
+    assert config.get(name) is value
+
+
+def test_config_get_processes_depended_on_values(
+    config: Config, config_cache_dir: Path
+) -> None:
+    assert str(config_cache_dir / "virtualenvs") == config.get("virtualenvs.path")
+
+
+def generate_environment_variable_tests() -> Iterator[tuple[str, str, str, bool]]:
+    data: list[tuple[Normalizer, list[tuple[str, Any]]]] = [
+        (
+            boolean_normalizer,
+            [
+                ("true", True),
+                ("false", False),
+                ("True", True),
+                ("False", False),
+                ("1", True),
+                ("0", False),
+            ],
+        ),
+        (int_normalizer, [("4", 4), ("2", 2)]),
+    ]
+
+    for normalizer, values in data:
+        for env_value, value in values:
+            for name in get_options_based_on_normalizer(normalizer=normalizer):
+                env_var = "POETRY_" + re.sub("[.-]+", "_", name).upper()
+                yield name, env_var, env_value, value
+
+
+@pytest.mark.parametrize(
+    ("name", "env_var", "env_value", "value"),
+    list(generate_environment_variable_tests()),
+)
+def test_config_get_from_environment_variable(
+    config: Config,
+    environ: Iterator[None],
+    name: str,
+    env_var: str,
+    env_value: str,
+    value: bool,
+) -> None:
+    os.environ[env_var] = env_value
+    assert config.get(name) is value
+
+
+def test_config_get_from_environment_variable_nested(
+    config: Config,
+    environ: Iterator[None],
+) -> None:
+    options = config.default_config["virtualenvs"]["options"]
+    expected = {}
+
+    for k, v in options.items():
+        if isinstance(v, bool):
+            expected[k] = not v
+            os.environ[f"POETRY_VIRTUALENVS_OPTIONS_{k.upper().replace('-', '_')}"] = (
+                "true" if expected[k] else "false"
+            )
+
+    assert config.get("virtualenvs.options") == expected
+
+
+@pytest.mark.parametrize(
+    ("path_config", "expected"),
+    [("~/.venvs", Path.home() / ".venvs"), ("venv", Path("venv"))],
+)
+def test_config_expands_tilde_for_virtualenvs_path(
+    config: Config, path_config: str, expected: Path
+) -> None:
+    config.merge({"virtualenvs": {"path": path_config}})
+    assert config.virtualenvs_path == expected
+
+
+def test_disabled_keyring_is_unavailable(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    manager = PasswordManager(config)
+    assert manager.use_keyring
+
+    config.config["keyring"]["enabled"] = False
+    manager = PasswordManager(config)
+    assert not manager.use_keyring
+
+
+@pytest.mark.parametrize(
+    ("value", "invalid"),
+    [
+        # non-serialised json
+        ("BAD=VALUE", True),
+        # good value
+        (json.dumps({"CC": "gcc", "--build-option": ["--one", "--two"]}), False),
+        # non-string key
+        ('{0: "hello"}', True),
+        # non-string value in list
+        ('{"world": ["hello", 0]}', True),
+    ],
+)
+def test_config_get_from_environment_variable_build_config_settings(
+    value: str,
+    invalid: bool,
+    config: Config,
+) -> None:
+    with isolated_environment(
+        {
+            "POETRY_INSTALLER_BUILD_CONFIG_SETTINGS_DEMO": value,
+        },
+        clear=True,
+    ):
+        configured_value = config.get("installer.build-config-settings.demo")
+
+        if invalid:
+            assert configured_value is None
+        else:
+            assert not DeepDiff(configured_value, json.loads(value))
diff --git b/tests/config/test_config_source.py a/tests/config/test_config_source.py
new file mode 100644
index 0000000..abd8139
--- /dev/null
+++ a/tests/config/test_config_source.py
@@ -0,0 +1,158 @@
+from __future__ import annotations
+
+from typing import Any
+
+import pytest
+
+from poetry.config.config_source import UNSET
+from poetry.config.config_source import ConfigSourceMigration
+from poetry.config.config_source import drop_empty_config_category
+from poetry.config.dict_config_source import DictConfigSource
+
+
+@pytest.mark.parametrize(
+    ["config_data", "expected"],
+    [
+        (
+            {
+                "category_a": {
+                    "category_b": {
+                        "category_c": {},
+                    },
+                },
+                "system-git-client": True,
+            },
+            {"system-git-client": True},
+        ),
+        (
+            {
+                "category_a": {
+                    "category_b": {
+                        "category_c": {},
+                        "category_d": {"some_config": True},
+                    },
+                },
+                "system-git-client": True,
+            },
+            {
+                "category_a": {
+                    "category_b": {
+                        "category_d": {"some_config": True},
+                    }
+                },
+                "system-git-client": True,
+            },
+        ),
+    ],
+)
+def test_drop_empty_config_category(
+    config_data: dict[Any, Any], expected: dict[Any, Any]
+) -> None:
+    assert (
+        drop_empty_config_category(
+            keys=["category_a", "category_b", "category_c"], config=config_data
+        )
+        == expected
+    )
+
+
+def test_config_source_migration_rename_key() -> None:
+    config_data = {
+        "virtualenvs": {
+            "prefer-active-python": True,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    migration = ConfigSourceMigration(
+        old_key="virtualenvs.prefer-active-python",
+        new_key="virtualenvs.use-poetry-python",
+    )
+
+    migration.apply(config_source)
+
+    config_source._config = {
+        "virtualenvs": {
+            "use-poetry-python": True,
+        },
+        "system-git-client": True,
+    }
+
+
+def test_config_source_migration_remove_key() -> None:
+    config_data = {
+        "virtualenvs": {
+            "prefer-active-python": True,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    migration = ConfigSourceMigration(
+        old_key="virtualenvs.prefer-active-python",
+        new_key=None,
+    )
+
+    migration.apply(config_source)
+
+    config_source._config = {
+        "virtualenvs": {},
+        "system-git-client": True,
+    }
+
+
+def test_config_source_migration_unset_value() -> None:
+    config_data = {
+        "virtualenvs": {
+            "prefer-active-python": True,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    migration = ConfigSourceMigration(
+        old_key="virtualenvs.prefer-active-python",
+        new_key="virtualenvs.use-poetry-python",
+        value_migration={True: UNSET, False: True},
+    )
+
+    migration.apply(config_source)
+
+    config_source._config = {
+        "virtualenvs": {},
+        "system-git-client": True,
+    }
+
+
+def test_config_source_migration_complex_migration() -> None:
+    config_data = {
+        "virtualenvs": {
+            "prefer-active-python": True,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    migration = ConfigSourceMigration(
+        old_key="virtualenvs.prefer-active-python",
+        new_key="virtualenvs.use-poetry-python",
+        value_migration={True: None, False: True},
+    )
+
+    migration.apply(config_source)
+
+    config_source._config = {
+        "virtualenvs": {
+            "use-poetry-python": None,
+        },
+        "system-git-client": True,
+    }
diff --git b/tests/config/test_dict_config_source.py a/tests/config/test_dict_config_source.py
new file mode 100644
index 0000000..925833d
--- /dev/null
+++ a/tests/config/test_dict_config_source.py
@@ -0,0 +1,68 @@
+from __future__ import annotations
+
+import pytest
+
+from poetry.config.config_source import PropertyNotFoundError
+from poetry.config.dict_config_source import DictConfigSource
+
+
+def test_dict_config_source_add_property() -> None:
+    config_source = DictConfigSource()
+    assert config_source._config == {}
+
+    config_source.add_property("system-git-client", True)
+    assert config_source._config == {"system-git-client": True}
+
+    config_source.add_property("virtualenvs.use-poetry-python", False)
+    assert config_source._config == {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+
+def test_dict_config_source_remove_property() -> None:
+    config_data = {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    config_source.remove_property("system-git-client")
+    assert config_source._config == {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        }
+    }
+
+    config_source.remove_property("virtualenvs.use-poetry-python")
+    assert config_source._config == {"virtualenvs": {}}
+
+
+def test_dict_config_source_get_property() -> None:
+    config_data = {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+    config_source = DictConfigSource()
+    config_source._config = config_data
+
+    assert config_source.get_property("virtualenvs.use-poetry-python") is False
+    assert config_source.get_property("system-git-client") is True
+
+
+def test_dict_config_source_get_property_should_raise_if_not_found() -> None:
+    config_source = DictConfigSource()
+
+    with pytest.raises(
+        PropertyNotFoundError, match="Key virtualenvs.use-poetry-python not in config"
+    ):
+        _ = config_source.get_property("virtualenvs.use-poetry-python")
diff --git b/tests/config/test_file_config_source.py a/tests/config/test_file_config_source.py
new file mode 100644
index 0000000..7567ab2
--- /dev/null
+++ a/tests/config/test_file_config_source.py
@@ -0,0 +1,91 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+import tomlkit
+
+from poetry.config.config_source import PropertyNotFoundError
+from poetry.config.file_config_source import FileConfigSource
+from poetry.toml import TOMLFile
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+
+def test_file_config_source_add_property(tmp_path: Path) -> None:
+    config = tmp_path.joinpath("config.toml")
+    config.touch()
+
+    config_source = FileConfigSource(TOMLFile(config))
+
+    assert config_source._file.read() == {}
+
+    config_source.add_property("system-git-client", True)
+    assert config_source._file.read() == {"system-git-client": True}
+
+    config_source.add_property("virtualenvs.use-poetry-python", False)
+    assert config_source._file.read() == {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+
+def test_file_config_source_remove_property(tmp_path: Path) -> None:
+    config_data = {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+    config = tmp_path.joinpath("config.toml")
+    with config.open(mode="w", encoding="utf-8") as f:
+        f.write(tomlkit.dumps(config_data))
+
+    config_source = FileConfigSource(TOMLFile(config))
+
+    config_source.remove_property("system-git-client")
+    assert config_source._file.read() == {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        }
+    }
+
+    config_source.remove_property("virtualenvs.use-poetry-python")
+    assert config_source._file.read() == {}
+
+
+def test_file_config_source_get_property(tmp_path: Path) -> None:
+    config_data = {
+        "virtualenvs": {
+            "use-poetry-python": False,
+        },
+        "system-git-client": True,
+    }
+
+    config = tmp_path.joinpath("config.toml")
+    with config.open(mode="w", encoding="utf-8") as f:
+        f.write(tomlkit.dumps(config_data))
+
+    config_source = FileConfigSource(TOMLFile(config))
+
+    assert config_source.get_property("virtualenvs.use-poetry-python") is False
+    assert config_source.get_property("system-git-client") is True
+
+
+def test_file_config_source_get_property_should_raise_if_not_found(
+    tmp_path: Path,
+) -> None:
+    config = tmp_path.joinpath("config.toml")
+    config.touch()
+
+    config_source = FileConfigSource(TOMLFile(config))
+
+    with pytest.raises(
+        PropertyNotFoundError, match="Key virtualenvs.use-poetry-python not in config"
+    ):
+        _ = config_source.get_property("virtualenvs.use-poetry-python")
diff --git b/tests/config/test_source.py a/tests/config/test_source.py
new file mode 100644
index 0000000..e639b81
--- /dev/null
+++ a/tests/config/test_source.py
@@ -0,0 +1,59 @@
+from __future__ import annotations
+
+import pytest
+
+from tomlkit.container import Container
+from tomlkit.items import Table
+from tomlkit.items import Trivia
+
+from poetry.config.source import Source
+from poetry.repositories.repository_pool import Priority
+
+
+@pytest.mark.parametrize(
+    "source,table_body",
+    [
+        (
+            Source("foo", "https://example.com"),
+            {
+                "name": "foo",
+                "priority": "primary",
+                "url": "https://example.com",
+            },
+        ),
+        (
+            Source("bar", "https://example.com/bar", priority=Priority.EXPLICIT),
+            {
+                "name": "bar",
+                "priority": "explicit",
+                "url": "https://example.com/bar",
+            },
+        ),
+    ],
+)
+def test_source_to_table(source: Source, table_body: dict[str, str | bool]) -> None:
+    table = Table(Container(), Trivia(), False)
+    table._value = table_body  # type: ignore[assignment]
+
+    assert source.to_toml_table() == table
+
+
+def test_source_default_is_primary() -> None:
+    source = Source("foo", "https://example.com")
+    assert source.priority == Priority.PRIMARY
+
+
+@pytest.mark.parametrize(
+    ("priority", "expected_priority"),
+    [
+        ("supplemental", Priority.SUPPLEMENTAL),
+        ("SUPPLEMENTAL", Priority.SUPPLEMENTAL),
+    ],
+)
+def test_source_priority_as_string(priority: str, expected_priority: Priority) -> None:
+    source = Source(
+        "foo",
+        "https://example.com",
+        priority=priority,  # type: ignore[arg-type]
+    )
+    assert source.priority == Priority.SUPPLEMENTAL
diff --git b/tests/console/commands/cache/conftest.py a/tests/console/commands/cache/conftest.py
new file mode 100644
index 0000000..a5e0fe7
--- /dev/null
+++ a/tests/console/commands/cache/conftest.py
@@ -0,0 +1,62 @@
+from __future__ import annotations
+
+import uuid
+
+from typing import TYPE_CHECKING
+from typing import TypeVar
+
+import pytest
+
+from poetry.utils.cache import FileCache
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from pytest import MonkeyPatch
+
+    from tests.conftest import Config
+
+T = TypeVar("T")
+
+
+@pytest.fixture
+def repository_cache_dir(monkeypatch: MonkeyPatch, config: Config) -> Path:
+    return config.repository_cache_directory
+
+
+@pytest.fixture
+def repository_one() -> str:
+    return f"01_{uuid.uuid4()}"
+
+
+@pytest.fixture
+def repository_two() -> str:
+    return f"02_{uuid.uuid4()}"
+
+
+@pytest.fixture
+def mock_caches(
+    repository_cache_dir: Path,
+    repository_one: str,
+    repository_two: str,
+) -> None:
+    (repository_cache_dir / repository_one).mkdir(parents=True)
+    (repository_cache_dir / repository_two).mkdir(parents=True)
+
+
+@pytest.fixture
+def cache(
+    repository_cache_dir: Path,
+    repository_one: str,
+    mock_caches: None,
+) -> FileCache[dict[str, str]]:
+    cache: FileCache[dict[str, str]] = FileCache(
+        path=repository_cache_dir / repository_one
+    )
+
+    cache.remember(
+        "cachy:0.1", lambda: {"name": "cachy", "version": "0.1"}, minutes=None
+    )
+    cache.remember("cleo:0.2", lambda: {"name": "cleo", "version": "0.2"}, minutes=None)
+    return cache
diff --git b/tests/console/commands/cache/test_clear.py a/tests/console/commands/cache/test_clear.py
new file mode 100644
index 0000000..8628ef4
--- /dev/null
+++ a/tests/console/commands/cache/test_clear.py
@@ -0,0 +1,89 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+from typing import TypeVar
+
+import pytest
+
+from cleo.testers.application_tester import ApplicationTester
+
+from poetry.console.application import Application
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from poetry.utils.cache import FileCache
+
+T = TypeVar("T")
+
+
+@pytest.fixture
+def tester() -> ApplicationTester:
+    app = Application()
+
+    tester = ApplicationTester(app)
+    return tester
+
+
+def test_cache_clear_all(
+    tester: ApplicationTester,
+    repository_one: str,
+    repository_cache_dir: Path,
+    cache: FileCache[T],
+) -> None:
+    exit_code = tester.execute(f"cache clear {repository_one} --all", inputs="yes")
+    repository_one_dir = repository_cache_dir / repository_one
+
+    assert exit_code == 0
+    assert tester.io.fetch_output() == ""
+    # ensure directory is empty or doesn't exist
+    assert not repository_one_dir.exists() or not any(repository_one_dir.iterdir())
+    assert not cache.has("cachy:0.1")
+    assert not cache.has("cleo:0.2")
+
+
+def test_cache_clear_all_no(
+    tester: ApplicationTester,
+    repository_one: str,
+    repository_cache_dir: Path,
+    cache: FileCache[T],
+) -> None:
+    exit_code = tester.execute(f"cache clear {repository_one} --all", inputs="no")
+
+    assert exit_code == 0
+    assert tester.io.fetch_output() == ""
+    # ensure directory is not empty
+    assert any((repository_cache_dir / repository_one).iterdir())
+    assert cache.has("cachy:0.1")
+    assert cache.has("cleo:0.2")
+
+
+@pytest.mark.parametrize("package_name", ["cachy", "Cachy"])
+def test_cache_clear_pkg(
+    tester: ApplicationTester,
+    repository_one: str,
+    cache: FileCache[T],
+    package_name: str,
+) -> None:
+    exit_code = tester.execute(
+        f"cache clear {repository_one}:{package_name}:0.1", inputs="yes"
+    )
+
+    assert exit_code == 0
+    assert tester.io.fetch_output() == ""
+    assert not cache.has("cachy:0.1")
+    assert cache.has("cleo:0.2")
+
+
+def test_cache_clear_pkg_no(
+    tester: ApplicationTester,
+    repository_one: str,
+    cache: FileCache[T],
+) -> None:
+    exit_code = tester.execute(f"cache clear {repository_one}:cachy:0.1", inputs="no")
+
+    assert exit_code == 0
+    assert tester.io.fetch_output() == ""
+    assert cache.has("cachy:0.1")
+    assert cache.has("cleo:0.2")
diff --git b/tests/console/commands/cache/test_list.py a/tests/console/commands/cache/test_list.py
new file mode 100644
index 0000000..2def856
--- /dev/null
+++ a/tests/console/commands/cache/test_list.py
@@ -0,0 +1,41 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("cache list")
+
+
+def test_cache_list(
+    tester: CommandTester, mock_caches: None, repository_one: str, repository_two: str
+) -> None:
+    tester.execute()
+
+    expected = f"""\
+{repository_one}
+{repository_two}
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_cache_list_empty(tester: CommandTester, repository_cache_dir: Path) -> None:
+    tester.execute()
+
+    expected = """\
+No caches found
+"""
+
+    assert tester.io.fetch_error() == expected
diff --git b/tests/console/commands/conftest.py a/tests/console/commands/conftest.py
new file mode 100644
index 0000000..cce363a
--- /dev/null
+++ a/tests/console/commands/conftest.py
@@ -0,0 +1,57 @@
+from __future__ import annotations
+
+import pytest
+
+
+@pytest.fixture
+def init_basic_inputs() -> str:
+    return "\n".join(
+        [
+            "my-package",  # Package name
+            "1.2.3",  # Version
+            "This is a description",  # Description
+            "n",  # Author
+            "MIT",  # License
+            ">=3.6",  # Python
+            "n",  # Interactive packages
+            "n",  # Interactive dev packages
+            "\n",  # Generate
+        ]
+    )
+
+
+@pytest.fixture()
+def init_basic_toml() -> str:
+    return """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+"""
+
+
+@pytest.fixture()
+def new_basic_toml() -> str:
+    return """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+]
+
+[tool.poetry]
+packages = [{include = "my_package", from = "src"}]
+"""
diff --git b/tests/console/commands/debug/test_resolve.py a/tests/console/commands/debug/test_resolve.py
new file mode 100644
index 0000000..1d733e3
--- /dev/null
+++ a/tests/console/commands/debug/test_resolve.py
@@ -0,0 +1,80 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.factory import Factory
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("debug resolve")
+
+
+@pytest.fixture(autouse=True)
+def __add_packages(repo: TestRepository) -> None:
+    cachy020 = get_package("cachy", "0.2.0")
+    cachy020.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+
+    repo.add_package(get_package("cachy", "0.1.0"))
+    repo.add_package(cachy020)
+    repo.add_package(get_package("msgpack-python", "0.5.3"))
+
+    repo.add_package(get_package("pendulum", "2.0.3"))
+    repo.add_package(get_package("cleo", "0.6.5"))
+
+
+def test_debug_resolve_gives_resolution_results(tester: CommandTester) -> None:
+    tester.execute("cachy")
+
+    expected = """\
+Resolving dependencies...
+
+Resolution results:
+
+msgpack-python 0.5.3
+cachy          0.2.0
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_debug_resolve_tree_option_gives_the_dependency_tree(
+    tester: CommandTester,
+) -> None:
+    tester.execute("cachy --tree")
+
+    expected = """\
+Resolving dependencies...
+
+Resolution results:
+
+cachy 0.2.0
+└── msgpack-python >=0.5 <0.6
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_debug_resolve_git_dependency(tester: CommandTester) -> None:
+    tester.execute("git+https://github.com/demo/demo.git")
+
+    expected = """\
+Resolving dependencies...
+
+Resolution results:
+
+pendulum 2.0.3
+demo     0.1.2
+"""
+
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/env/conftest.py a/tests/console/commands/env/conftest.py
new file mode 100644
index 0000000..7fb3b15
--- /dev/null
+++ a/tests/console/commands/env/conftest.py
@@ -0,0 +1,95 @@
+from __future__ import annotations
+
+import os
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils.env import EnvManager
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+    from pathlib import Path
+
+    from tests.helpers import PoetryTestApplication
+
+
+@pytest.fixture
+def venv_name(app: PoetryTestApplication) -> str:
+    return EnvManager.generate_env_name(
+        app.poetry.package.name,
+        str(app.poetry.file.path.parent),
+    )
+
+
+@pytest.fixture
+def venv_cache(tmp_path: Path) -> Path:
+    return tmp_path
+
+
+@pytest.fixture(scope="module")
+def python_versions() -> list[str]:
+    return ["3.6", "3.7"]
+
+
+@pytest.fixture
+def venvs_in_cache_config(app: PoetryTestApplication, venv_cache: Path) -> None:
+    app.poetry.config.merge({"virtualenvs": {"path": str(venv_cache)}})
+
+
+@pytest.fixture
+def venvs_in_cache_dirs(
+    app: PoetryTestApplication,
+    venvs_in_cache_config: None,
+    venv_name: str,
+    venv_cache: Path,
+    python_versions: list[str],
+) -> list[str]:
+    directories = []
+    for version in python_versions:
+        directory = venv_cache / f"{venv_name}-py{version}"
+        directory.mkdir(parents=True, exist_ok=True)
+        directories.append(directory.name)
+    return directories
+
+
+@pytest.fixture
+def venvs_in_project_dir(app: PoetryTestApplication) -> Iterator[Path]:
+    os.environ.pop("VIRTUAL_ENV", None)
+    venv_dir = app.poetry.file.path.parent.joinpath(".venv")
+    venv_dir.mkdir(exist_ok=True)
+    app.poetry.config.merge({"virtualenvs": {"in-project": True}})
+
+    try:
+        yield venv_dir
+    finally:
+        if venv_dir.exists():
+            venv_dir.rmdir()
+
+
+@pytest.fixture
+def venvs_in_project_dir_none(app: PoetryTestApplication) -> Iterator[Path]:
+    os.environ.pop("VIRTUAL_ENV", None)
+    venv_dir = app.poetry.file.path.parent.joinpath(".venv")
+    venv_dir.mkdir(exist_ok=True)
+    app.poetry.config.merge({"virtualenvs": {"in-project": None}})
+
+    try:
+        yield venv_dir
+    finally:
+        venv_dir.rmdir()
+
+
+@pytest.fixture
+def venvs_in_project_dir_false(app: PoetryTestApplication) -> Iterator[Path]:
+    os.environ.pop("VIRTUAL_ENV", None)
+    venv_dir = app.poetry.file.path.parent.joinpath(".venv")
+    venv_dir.mkdir(exist_ok=True)
+    app.poetry.config.merge({"virtualenvs": {"in-project": False}})
+
+    try:
+        yield venv_dir
+    finally:
+        venv_dir.rmdir()
diff --git b/tests/console/commands/env/helpers.py a/tests/console/commands/env/helpers.py
new file mode 100644
index 0000000..4337281
--- /dev/null
+++ a/tests/console/commands/env/helpers.py
@@ -0,0 +1,51 @@
+from __future__ import annotations
+
+import os
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+from poetry.core.constraints.version import Version
+
+
+if TYPE_CHECKING:
+    from collections.abc import Callable
+
+VERSION_3_7_1 = Version.parse("3.7.1")
+
+
+def build_venv(path: Path | str, **_: Any) -> None:
+    Path(path).mkdir(parents=True, exist_ok=True)
+
+
+def check_output_wrapper(
+    version: Version = VERSION_3_7_1,
+) -> Callable[[list[str], Any, Any], str]:
+    def check_output(cmd: list[str], *args: Any, **kwargs: Any) -> str:
+        # cmd is a list, like ["python", "-c", "do stuff"]
+        python_cmd = cmd[-1]
+        if "print(json.dumps(env))" in python_cmd:
+            return (
+                f'{{"version_info": [{version.major}, {version.minor},'
+                f" {version.patch}]}}"
+            )
+
+        if "sys.version_info[:3]" in python_cmd:
+            return version.text
+
+        if "sys.version_info[:2]" in python_cmd:
+            return f"{version.major}.{version.minor}"
+
+        if "import sys; print(sys.executable)" in python_cmd:
+            executable = cmd[0]
+            basename = os.path.basename(executable)
+            return f"/usr/bin/{basename}"
+
+        if "print(sys.base_prefix)" in python_cmd:
+            return "/usr"
+
+        assert "import sys; print(sys.prefix)" in python_cmd
+        return "/prefix"
+
+    return check_output
diff --git b/tests/console/commands/env/test_activate.py a/tests/console/commands/env/test_activate.py
new file mode 100644
index 0000000..b466134
--- /dev/null
+++ a/tests/console/commands/env/test_activate.py
@@ -0,0 +1,94 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils._compat import WINDOWS
+
+
+if TYPE_CHECKING:
+    from cleo.testers.application_tester import ApplicationTester
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.env import VirtualEnv
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("env activate")
+
+
+@pytest.mark.parametrize(
+    "shell, command, ext",
+    (
+        ("bash", "source", ""),
+        ("zsh", "source", ""),
+        ("fish", "source", ".fish"),
+        ("nu", "overlay use", ".nu"),
+        ("csh", "source", ".csh"),
+        ("tcsh", "source", ".csh"),
+    ),
+)
+@pytest.mark.skipif(WINDOWS, reason="Only Unix shells")
+def test_env_activate_prints_correct_script(
+    tmp_venv: VirtualEnv,
+    mocker: MockerFixture,
+    tester: CommandTester,
+    shell: str,
+    command: str,
+    ext: str,
+) -> None:
+    mocker.patch("shellingham.detect_shell", return_value=(shell, None))
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=tmp_venv)
+
+    tester.execute()
+
+    line = tester.io.fetch_output().rstrip("\n")
+    assert line == f"{command} {tmp_venv.bin_dir}/activate{ext}"
+
+
+@pytest.mark.parametrize(
+    "shell, command, ext, prefix",
+    (
+        ("cmd", ".", "activate.bat", ""),
+        ("pwsh", ".", "activate.ps1", "& "),
+        ("powershell", ".", "activate.ps1", "& "),
+    ),
+)
+@pytest.mark.skipif(not WINDOWS, reason="Only Windows shells")
+def test_env_activate_prints_correct_script_on_windows(
+    tmp_venv: VirtualEnv,
+    mocker: MockerFixture,
+    tester: CommandTester,
+    shell: str,
+    command: str,
+    ext: str,
+    prefix: str,
+) -> None:
+    mocker.patch("shellingham.detect_shell", return_value=(shell, None))
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=tmp_venv)
+
+    tester.execute()
+
+    line = tester.io.fetch_output().rstrip("\n")
+    assert line == f'{prefix}"{tmp_venv.bin_dir / ext!s}"'
+
+
+@pytest.mark.parametrize("verbosity", ["", "-v", "-vv", "-vvv"])
+def test_no_additional_output_in_verbose_mode(
+    tmp_venv: VirtualEnv,
+    mocker: MockerFixture,
+    app_tester: ApplicationTester,
+    verbosity: str,
+) -> None:
+    mocker.patch("shellingham.detect_shell", return_value=("pwsh", None))
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=tmp_venv)
+
+    # use an AppTester instead of a CommandTester to catch additional output
+    app_tester.execute(f"env activate {verbosity}")
+
+    lines = app_tester.io.fetch_output().splitlines()
+    assert len(lines) == 1
diff --git b/tests/console/commands/env/test_info.py a/tests/console/commands/env/test_info.py
new file mode 100644
index 0000000..140c461
--- /dev/null
+++ a/tests/console/commands/env/test_info.py
@@ -0,0 +1,66 @@
+from __future__ import annotations
+
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils.env import MockEnv
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture(autouse=True)
+def setup(mocker: MockerFixture) -> None:
+    mocker.patch(
+        "poetry.utils.env.EnvManager.get",
+        return_value=MockEnv(
+            path=Path("/prefix"), base=Path("/base/prefix"), is_venv=True
+        ),
+    )
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("env info")
+
+
+def test_env_info_displays_complete_info(tester: CommandTester) -> None:
+    tester.execute()
+
+    expected = f"""
+Virtualenv
+Python:         3.7.0
+Implementation: CPython
+Path:           {Path("/prefix")}
+Executable:     {sys.executable}
+Valid:          True
+
+Base
+Platform:   darwin
+OS:         posix
+Python:     {".".join(str(v) for v in sys.version_info[:3])}
+Path:       {Path("/base/prefix")}
+Executable: python
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_env_info_displays_path_only(tester: CommandTester) -> None:
+    tester.execute("--path")
+    expected = str(Path("/prefix")) + "\n"
+    assert tester.io.fetch_output() == expected
+
+
+def test_env_info_displays_executable_only(tester: CommandTester) -> None:
+    tester.execute("--executable")
+    expected = str(sys.executable) + "\n"
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/env/test_list.py a/tests/console/commands/env/test_list.py
new file mode 100644
index 0000000..b617d3e
--- /dev/null
+++ a/tests/console/commands/env/test_list.py
@@ -0,0 +1,78 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+import tomlkit
+
+from poetry.toml.file import TOMLFile
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.env import MockEnv
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def venv_activate_37(venv_cache: Path, venv_name: str) -> None:
+    envs_file = TOMLFile(venv_cache / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.0"}
+    envs_file.write(doc)
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("env list")
+
+
+def test_none_activated(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    mocker: MockerFixture,
+    env: MockEnv,
+) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=env)
+    tester.execute()
+    expected = "\n".join(venvs_in_cache_dirs)
+    assert tester.io.fetch_output().strip() == expected
+
+
+def test_activated(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_cache: Path,
+    venv_activate_37: None,
+) -> None:
+    tester.execute()
+    expected = "\n".join(venvs_in_cache_dirs).replace("py3.7", "py3.7 (Activated)")
+    assert tester.io.fetch_output().strip() == expected
+
+
+def test_in_project_venv(
+    tester: CommandTester, venvs_in_project_dir: list[str]
+) -> None:
+    tester.execute()
+    expected = ".venv (Activated)\n"
+    assert tester.io.fetch_output() == expected
+
+
+def test_in_project_venv_no_explicit_config(
+    tester: CommandTester, venvs_in_project_dir_none: list[str]
+) -> None:
+    tester.execute()
+    expected = ".venv (Activated)\n"
+    assert tester.io.fetch_output() == expected
+
+
+def test_in_project_venv_is_false(
+    tester: CommandTester, venvs_in_project_dir_false: list[str]
+) -> None:
+    tester.execute()
+    expected = ""
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/env/test_remove.py a/tests/console/commands/env/test_remove.py
new file mode 100644
index 0000000..04d839f
--- /dev/null
+++ a/tests/console/commands/env/test_remove.py
@@ -0,0 +1,168 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.constraints.version import Version
+
+from tests.console.commands.env.helpers import check_output_wrapper
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("env remove")
+
+
+def test_remove_by_python_version(
+    mocker: MockerFixture,
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_name: str,
+    venv_cache: Path,
+) -> None:
+    check_output = mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    tester.execute("3.6")
+
+    assert check_output.called
+    assert not (venv_cache / f"{venv_name}-py3.6").exists()
+
+    expected = f"Deleted virtualenv: {venv_cache / venv_name}-py3.6\n"
+    assert tester.io.fetch_output() == expected
+
+
+def test_remove_by_name(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_name: str,
+    venv_cache: Path,
+) -> None:
+    expected = ""
+
+    for name in venvs_in_cache_dirs:
+        tester.execute(name)
+
+        assert not (venv_cache / name).exists()
+
+        expected += f"Deleted virtualenv: {venv_cache / name}\n"
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    "envs_file", [None, "empty", "self", "other", "self_and_other"]
+)
+def test_remove_all(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_name: str,
+    venv_cache: Path,
+    envs_file: str | None,
+) -> None:
+    envs_file_path = venv_cache / "envs.toml"
+    if envs_file == "empty":
+        envs_file_path.touch()
+    elif envs_file == "self":
+        envs_file_path.write_text(
+            f'[{venv_name}]\nminor = "3.9"\npatch = "3.9.1"\n', encoding="utf-8"
+        )
+    elif envs_file == "other":
+        envs_file_path.write_text(
+            '[other-abcdefgh]\nminor = "3.9"\npatch = "3.9.1"\n', encoding="utf-8"
+        )
+    elif envs_file == "self_and_other":
+        envs_file_path.write_text(
+            f'[{venv_name}]\nminor = "3.9"\npatch = "3.9.1"\n'
+            '[other-abcdefgh]\nminor = "3.9"\npatch = "3.9.1"\n',
+            encoding="utf-8",
+        )
+    else:
+        # no envs file -> nothing to prepare
+        assert envs_file is None
+
+    expected = {""}
+    tester.execute("--all")
+    for name in venvs_in_cache_dirs:
+        assert not (venv_cache / name).exists()
+        expected.add(f"Deleted virtualenv: {venv_cache / name}")
+    assert set(tester.io.fetch_output().split("\n")) == expected
+
+    if envs_file is not None:
+        assert envs_file_path.exists()
+        envs_file_content = envs_file_path.read_text(encoding="utf-8")
+        assert venv_name not in envs_file_content
+        if "other" in envs_file:
+            assert "other-abcdefgh" in envs_file_content
+        else:
+            assert envs_file_content == ""
+    else:
+        assert not envs_file_path.exists()
+
+
+def test_remove_all_and_version(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_name: str,
+    venv_cache: Path,
+) -> None:
+    expected = {""}
+    tester.execute(f"--all {venvs_in_cache_dirs[0]}")
+    for name in venvs_in_cache_dirs:
+        assert not (venv_cache / name).exists()
+        expected.add(f"Deleted virtualenv: {venv_cache / name}")
+    assert set(tester.io.fetch_output().split("\n")) == expected
+
+
+def test_remove_multiple(
+    tester: CommandTester,
+    venvs_in_cache_dirs: list[str],
+    venv_name: str,
+    venv_cache: Path,
+) -> None:
+    expected = {""}
+    removed_envs = venvs_in_cache_dirs[0:2]
+    remaining_envs = venvs_in_cache_dirs[2:]
+    tester.execute(" ".join(removed_envs))
+    for name in removed_envs:
+        assert not (venv_cache / name).exists()
+        expected.add(f"Deleted virtualenv: {venv_cache / name}")
+    for name in remaining_envs:
+        assert (venv_cache / name).exists()
+    assert set(tester.io.fetch_output().split("\n")) == expected
+
+
+def test_remove_in_project(tester: CommandTester, venvs_in_project_dir: Path) -> None:
+    assert venvs_in_project_dir.exists()
+
+    tester.execute()
+
+    assert not venvs_in_project_dir.exists()
+
+    expected = f"Deleted virtualenv: {venvs_in_project_dir}\n"
+    assert tester.io.fetch_output() == expected
+
+
+def test_remove_in_project_all(
+    tester: CommandTester, venvs_in_project_dir: Path
+) -> None:
+    assert venvs_in_project_dir.exists()
+
+    tester.execute("--all")
+
+    assert not venvs_in_project_dir.exists()
+
+    expected = f"Deleted virtualenv: {venvs_in_project_dir}\n"
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/env/test_use.py a/tests/console/commands/env/test_use.py
new file mode 100644
index 0000000..f27b1ac
--- /dev/null
+++ a/tests/console/commands/env/test_use.py
@@ -0,0 +1,162 @@
+from __future__ import annotations
+
+import os
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+import tomlkit
+
+from poetry.core.constraints.version import Version
+
+from poetry.toml.file import TOMLFile
+from poetry.utils.env import MockEnv
+from tests.console.commands.env.helpers import build_venv
+from tests.console.commands.env.helpers import check_output_wrapper
+
+
+if TYPE_CHECKING:
+    from unittest.mock import MagicMock
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.env.base_env import PythonVersion
+    from tests.types import CommandTesterFactory
+    from tests.types import MockedPythonRegister
+
+
+@pytest.fixture(autouse=True)
+def setup(mocker: MockerFixture) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+
+@pytest.fixture(autouse=True)
+def mock_subprocess_calls(
+    setup: None, current_python: PythonVersion, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.from_parts(*current_python[:3])),
+    )
+    mocker.patch(
+        "subprocess.Popen.communicate",
+        side_effect=[("/prefix", None), ("/prefix", None), ("/prefix", None)],
+    )
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("env use")
+
+
+def test_activate_activates_non_existing_virtualenv_no_envs_file(
+    mocker: MockerFixture,
+    tester: CommandTester,
+    venv_cache: Path,
+    venv_name: str,
+    venvs_in_cache_config: None,
+    mocked_python_register: MockedPythonRegister,
+    with_no_active_python: MagicMock,
+) -> None:
+    mocked_python_register("3.7.1")
+    mock_build_env = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=build_venv
+    )
+
+    tester.execute("3.7")
+
+    venv_py37 = venv_cache / f"{venv_name}-py3.7"
+    mock_build_env.assert_called_with(
+        venv_py37,
+        executable=Path("/usr/bin/python3.7"),
+        flags={
+            "always-copy": False,
+            "system-site-packages": False,
+            "no-pip": False,
+        },
+        prompt="simple-project-py3.7",
+    )
+
+    envs_file = TOMLFile(venv_cache / "envs.toml")
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.7"
+    assert envs[venv_name]["patch"] == "3.7.1"
+
+    assert (
+        tester.io.fetch_error()
+        == f"Creating virtualenv {venv_py37.name} in {venv_py37.parent}\n"
+    )
+    assert tester.io.fetch_output() == f"Using virtualenv: {venv_py37}\n"
+
+
+def test_get_prefers_explicitly_activated_virtualenvs_over_env_var(
+    tester: CommandTester,
+    current_python: PythonVersion,
+    venv_cache: Path,
+    venv_name: str,
+    venvs_in_cache_config: None,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    os.environ["VIRTUAL_ENV"] = "/environment/prefix"
+
+    python_minor = ".".join(str(v) for v in current_python[:2])
+    python_patch = ".".join(str(v) for v in current_python[:3])
+    venv_dir = venv_cache / f"{venv_name}-py{python_minor}"
+    venv_dir.mkdir(parents=True, exist_ok=True)
+
+    envs_file = TOMLFile(venv_cache / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": python_minor, "patch": python_patch}
+    envs_file.write(doc)
+
+    mocked_python_register(python_patch)
+
+    tester.execute(python_minor)
+
+    expected = f"""\
+Using virtualenv: {venv_dir}
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_get_prefers_explicitly_activated_non_existing_virtualenvs_over_env_var(
+    mocker: MockerFixture,
+    tester: CommandTester,
+    current_python: PythonVersion,
+    venv_cache: Path,
+    venv_name: str,
+    venvs_in_cache_config: None,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    os.environ["VIRTUAL_ENV"] = "/environment/prefix"
+
+    python_minor = ".".join(str(v) for v in current_python[:2])
+    venv_dir = venv_cache / f"{venv_name}-py{python_minor}"
+
+    mocked_python_register(python_minor)
+
+    mocker.patch(
+        "poetry.utils.env.EnvManager._env",
+        new_callable=mocker.PropertyMock,
+        return_value=MockEnv(
+            path=Path("/environment/prefix"),
+            base=Path("/base/prefix"),
+            version_info=current_python,
+            is_venv=True,
+        ),
+    )
+    mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
+
+    tester.execute(python_minor)
+
+    assert (
+        tester.io.fetch_error()
+        == f"Creating virtualenv {venv_dir.name} in {venv_dir.parent}\n"
+    )
+    assert tester.io.fetch_output() == f"Using virtualenv: {venv_dir}\n"
diff --git b/tests/console/commands/python/test_python_install.py a/tests/console/commands/python/test_python_install.py
new file mode 100644
index 0000000..84420f3
--- /dev/null
+++ a/tests/console/commands/python/test_python_install.py
@@ -0,0 +1,175 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.constraints.version.version import Version
+
+from poetry.console.exceptions import PoetryRuntimeError
+from poetry.utils.env.python.installer import PythonDownloadNotFoundError
+from poetry.utils.env.python.installer import PythonInstallationError
+
+
+if TYPE_CHECKING:
+    from unittest.mock import MagicMock
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture(autouse=True)
+def mock_installer(mocker: MockerFixture) -> MagicMock:
+    return mocker.patch("poetry.console.commands.python.install.PythonInstaller")
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("python install")
+
+
+def test_install_invalid_version(tester: CommandTester) -> None:
+    tester.execute("foo")
+
+    assert tester.status_code == 1
+    assert tester.io.fetch_error() == "Invalid Python version requested foo\n"
+
+
+def test_install_free_threaded_not_supported(tester: CommandTester) -> None:
+    tester.execute("-t 3.12")
+
+    assert tester.status_code == 1
+    assert (
+        "Free threading is not supported for Python versions prior to 3.13.0.\n"
+        in tester.io.fetch_error()
+    )
+
+
+def test_install_exists(tester: CommandTester, mock_installer: MagicMock) -> None:
+    mock_installer.return_value.exists.return_value = True
+
+    tester.execute("3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_not_called()
+
+    assert tester.status_code == 1
+    assert "Python version already installed at" in tester.io.fetch_error()
+
+
+def test_install_no_download(tester: CommandTester, mock_installer: MagicMock) -> None:
+    mock_installer.return_value.exists.side_effect = PythonDownloadNotFoundError
+
+    tester.execute("3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_not_called()
+
+    assert tester.status_code == 1
+    assert (
+        "No suitable standalone build found for the requested Python version.\n"
+        in tester.io.fetch_error()
+    )
+
+
+def test_install_failure(tester: CommandTester, mock_installer: MagicMock) -> None:
+    mock_installer.return_value.exists.return_value = False
+    mock_installer.return_value.install.side_effect = PythonInstallationError("foo")
+
+    tester.execute("3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_called_once()
+
+    assert tester.status_code == 1
+    assert (
+        tester.io.fetch_output()
+        == "Downloading and installing 3.11 (cpython) ... Failed\n"
+    )
+    assert "foo\n" in tester.io.fetch_error()
+
+
+@pytest.mark.parametrize("clean", [False, True])
+def test_install_corrupt(
+    tester: CommandTester, mock_installer: MagicMock, config: Config, clean: bool
+) -> None:
+    def create_install_dir() -> None:
+        (config.python_installation_dir / "cpython@3.11.9").mkdir(parents=True)
+
+    mock_installer.return_value.exists.side_effect = [False, PoetryRuntimeError("foo")]
+    mock_installer.return_value.install.side_effect = create_install_dir
+    mock_installer.return_value.version = Version.parse("3.11.9")
+
+    with pytest.raises(PoetryRuntimeError):
+        clean_opt = "-c " if clean else ""
+        tester.execute(f"{clean_opt}3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_called_once()
+
+    expected = (
+        "Downloading and installing 3.11 (cpython) ... Done\n"
+        "Testing 3.11 (cpython) ... Failed\n"
+    )
+    if clean:
+        expected += "Removing installation 3.11.9 (cpython) ... Done\n"
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_install_success(tester: CommandTester, mock_installer: MagicMock) -> None:
+    mock_installer.return_value.exists.return_value = False
+
+    tester.execute("3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_called_once()
+
+    assert tester.status_code == 0
+    assert tester.io.fetch_output() == (
+        "Downloading and installing 3.11 (cpython) ... Done\n"
+        "Testing 3.11 (cpython) ... Done\n"
+    )
+
+
+def test_install_reinstall(tester: CommandTester, mock_installer: MagicMock) -> None:
+    mock_installer.return_value.exists.return_value = True
+
+    tester.execute("-r 3.11")
+
+    mock_installer.assert_called_once_with("3.11", "cpython", False)
+    mock_installer.return_value.install.assert_called_once()
+
+    assert tester.status_code == 0
+    assert tester.io.fetch_output() == (
+        "Downloading and installing 3.11 (cpython) ... Done\n"
+        "Testing 3.11 (cpython) ... Done\n"
+    )
+
+
+@pytest.mark.parametrize("free_threaded", [False, True])
+@pytest.mark.parametrize("implementation", ["cpython", "pypy"])
+def test_install_passes_options_to_installer(
+    tester: CommandTester,
+    mock_installer: MagicMock,
+    free_threaded: bool,
+    implementation: str,
+) -> None:
+    mock_installer.return_value.exists.return_value = False
+
+    free_threaded_opt = "-t " if free_threaded else ""
+    impl_opt = f"-i {implementation} "
+    tester.execute(f"{free_threaded_opt}{impl_opt}3.13")
+
+    mock_installer.assert_called_once_with("3.13", implementation, free_threaded)
+    mock_installer.return_value.install.assert_called_once()
+
+    assert tester.status_code == 0
+    details = f"{implementation}, free-threaded" if free_threaded else implementation
+    assert tester.io.fetch_output() == (
+        f"Downloading and installing 3.13 ({details}) ... Done\n"
+        f"Testing 3.13 ({details}) ... Done\n"
+    )
diff --git b/tests/console/commands/python/test_python_list.py a/tests/console/commands/python/test_python_list.py
new file mode 100644
index 0000000..cb7c399
--- /dev/null
+++ a/tests/console/commands/python/test_python_list.py
@@ -0,0 +1,141 @@
+from __future__ import annotations
+
+import platform
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils._compat import WINDOWS
+from tests.helpers import pbs_installer_supported_arch
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.config.config import Config
+    from tests.types import CommandTesterFactory
+    from tests.types import MockedPoetryPythonRegister
+    from tests.types import MockedPythonRegister
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("python list")
+
+
+def test_list_no_versions(tester: CommandTester) -> None:
+    tester.execute()
+
+    assert tester.io.fetch_output() == "No Python installations found.\n"
+
+
+def test_list_all(tester: CommandTester) -> None:
+    tester.execute("--all")
+
+    if platform.system() == "FreeBSD" or not pbs_installer_supported_arch(
+        platform.machine()
+    ):
+        assert tester.io.fetch_output() == "No Python installations found.\n"
+    else:
+        assert "Available for download" in tester.io.fetch_output()
+
+
+def test_list_invalid_version(tester: CommandTester) -> None:
+    tester.execute("foo")
+
+    assert tester.status_code == 1
+    assert tester.io.fetch_error() == "Invalid Python version requested foo\n"
+
+
+def test_list(
+    tester: CommandTester, mocked_python_register: MockedPythonRegister
+) -> None:
+    mocked_python_register("3.9.1", parent="a")
+    mocked_python_register("3.9.3", parent="b")
+    mocked_python_register("3.10.4", parent="c")
+
+    tester.execute()
+
+    expected = """\
+ Version Implementation Manager Path         \
+
+ 3.10.4  CPython        System  c/python3.10 \
+
+ 3.9.3   CPython        System  b/python3.9  \
+
+ 3.9.1   CPython        System  a/python3.9  \
+
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize("only_poetry_managed", [False, True])
+def test_list_poetry_managed(
+    tester: CommandTester,
+    config: Config,
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+    only_poetry_managed: bool,
+) -> None:
+    mocked_poetry_managed_python_register("3.9.1", "cpython")
+    mocked_poetry_managed_python_register("3.10.8", "pypy")
+
+    tester.execute("-m" if only_poetry_managed else "")
+
+    lines = tester.io.fetch_output().splitlines()
+    system_lines = [line.strip() for line in lines if "System" in line]
+    poetry_lines = [line.strip() for line in lines if "Poetry" in line]
+
+    install_dir = config.python_installation_dir.as_posix()
+    bin_dir = "" if WINDOWS else "bin/"
+    expected = {
+        f"3.10.8  PyPy           Poetry  {install_dir}/pypy@3.10.8/{bin_dir}pypy",
+        f"3.10.8  PyPy           Poetry  {install_dir}/pypy@3.10.8/{bin_dir}python",
+        f"3.9.1   CPython        Poetry  {install_dir}/cpython@3.9.1/{bin_dir}python",
+    }
+
+    assert set(poetry_lines) == expected
+    if only_poetry_managed:
+        assert not system_lines
+    else:
+        assert system_lines
+
+
+@pytest.mark.parametrize(
+    ("version", "expected"),
+    [("3", 3), ("3.9", 2), ("3.9.2", 0), ("3.9.3", 1)],
+)
+def test_list_version(
+    tester: CommandTester,
+    mocked_python_register: MockedPythonRegister,
+    version: str,
+    expected: int,
+) -> None:
+    mocked_python_register("2.7.13", parent="_")
+    mocked_python_register("3.9.1", parent="a")
+    mocked_python_register("3.9.3", parent="b")
+    mocked_python_register("3.10.4", parent="c")
+
+    tester.execute(version)
+
+    assert len(tester.io.fetch_output().splitlines()) - 1 == expected
+
+
+@pytest.mark.parametrize(
+    ("implementation", "expected"),
+    [("PyPy", 1), ("pypy", 1), ("CPython", 2)],
+)
+def test_list_implementation(
+    tester: CommandTester,
+    mocked_python_register: MockedPythonRegister,
+    implementation: str,
+    expected: int,
+) -> None:
+    mocked_python_register("3.9.1", implementation="PyPy", parent="a")
+    mocked_python_register("3.9.3", implementation="CPython", parent="b")
+    mocked_python_register("3.10.4", implementation="CPython", parent="c")
+
+    tester.execute(f"-i {implementation}")
+
+    assert len(tester.io.fetch_output().splitlines()) - 1 == expected
diff --git b/tests/console/commands/python/test_python_remove.py a/tests/console/commands/python/test_python_remove.py
new file mode 100644
index 0000000..cc26c1e
--- /dev/null
+++ a/tests/console/commands/python/test_python_remove.py
@@ -0,0 +1,111 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.config.config import Config
+    from tests.types import CommandTesterFactory
+    from tests.types import MockedPoetryPythonRegister
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("python remove")
+
+
+def test_remove_invalid_version(tester: CommandTester) -> None:
+    tester.execute("foo")
+
+    assert tester.status_code == 1
+    assert tester.io.fetch_error() == "Invalid Python version requested foo\n"
+
+
+def test_remove_version_not_precise_enough(tester: CommandTester) -> None:
+    tester.execute("3.9")
+
+    assert tester.status_code == 1
+    assert (
+        tester.io.fetch_error()
+        == """\
+Invalid Python version requested 3.9
+
+You need to provide an exact Python version in the format X.Y.Z to be removed.
+
+You can use poetry python list -m to list installed Poetry managed Python versions.
+"""
+    )
+
+
+def test_remove_version_no_installation(tester: CommandTester, config: Config) -> None:
+    tester.execute("3.9.1")
+
+    location = config.python_installation_dir / "cpython@3.9.1"
+    assert tester.io.fetch_output() == f"No installation was found at {location}.\n"
+
+
+def test_remove_version(
+    tester: CommandTester,
+    config: Config,
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+) -> None:
+    cpython_path = mocked_poetry_managed_python_register("3.9.1", "cpython")
+    other_cpython_path = mocked_poetry_managed_python_register("3.9.2", "cpython")
+    pypy_path = mocked_poetry_managed_python_register("3.9.1", "pypy")
+
+    tester.execute("3.9.1")
+
+    assert (
+        tester.io.fetch_output() == "Removing installation 3.9.1 (cpython) ... Done\n"
+    )
+    assert not cpython_path.exists()
+    assert pypy_path.exists()
+    assert other_cpython_path.exists()
+
+
+@pytest.mark.parametrize("implementation", ["cpython", "pypy"])
+def test_remove_version_implementation(
+    tester: CommandTester,
+    config: Config,
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+    implementation: str,
+) -> None:
+    cpython_path = mocked_poetry_managed_python_register("3.9.1", "cpython")
+    pypy_path = mocked_poetry_managed_python_register("3.9.1", "pypy")
+
+    tester.execute(f"3.9.1 -i {implementation}")
+
+    assert (
+        tester.io.fetch_output()
+        == f"Removing installation 3.9.1 ({implementation}) ... Done\n"
+    )
+    if implementation == "cpython":
+        assert not cpython_path.exists()
+        assert pypy_path.exists()
+    else:
+        assert cpython_path.exists()
+        assert not pypy_path.exists()
+
+
+def test_remove_multiple_versions(
+    tester: CommandTester,
+    config: Config,
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+) -> None:
+    cpython_path_1 = mocked_poetry_managed_python_register("3.9.1", "cpython")
+    cpython_path_2 = mocked_poetry_managed_python_register("3.9.2", "cpython")
+    cpython_path_3 = mocked_poetry_managed_python_register("3.9.3", "cpython")
+
+    tester.execute("3.9.1 3.9.3")
+
+    assert tester.io.fetch_output() == (
+        "Removing installation 3.9.1 (cpython) ... Done\n"
+        "Removing installation 3.9.3 (cpython) ... Done\n"
+    )
+    assert not cpython_path_1.exists()
+    assert cpython_path_2.exists()
+    assert not cpython_path_3.exists()
diff --git b/tests/console/commands/self/conftest.py a/tests/console/commands/self/conftest.py
new file mode 100644
index 0000000..82efafa
--- /dev/null
+++ a/tests/console/commands/self/conftest.py
@@ -0,0 +1,87 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Callable
+
+import pytest
+
+from poetry.core.packages.package import Package
+
+from poetry.__version__ import __version__
+from poetry.factory import Factory
+from poetry.repositories import RepositoryPool
+from poetry.utils.env import EnvManager
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterable
+
+    import httpretty
+
+    from cleo.io.io import IO
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from poetry.repositories.repository import Repository
+    from poetry.utils.env import VirtualEnv
+    from tests.helpers import TestRepository
+
+
+@pytest.fixture
+def poetry_package() -> Package:
+    return Package("poetry", __version__)
+
+
+@pytest.fixture(autouse=True)
+def _patch_repos(
+    repo: TestRepository, installed: Repository, poetry_package: Package
+) -> None:
+    repo.add_package(poetry_package)
+    installed.add_package(poetry_package)
+
+
+@pytest.fixture()
+def pool(repo: TestRepository) -> RepositoryPool:
+    return RepositoryPool([repo])
+
+
+def create_pool_factory(
+    repo: Repository,
+) -> Callable[[Config, Iterable[dict[str, Any]], IO, bool], RepositoryPool]:
+    def _create_pool(
+        config: Config,
+        sources: Iterable[dict[str, Any]] = (),
+        io: IO | None = None,
+        disable_cache: bool = False,
+    ) -> RepositoryPool:
+        pool = RepositoryPool()
+        pool.add_repository(repo)
+
+        return pool
+
+    return _create_pool
+
+
+@pytest.fixture(autouse=True)
+def setup_mocks(
+    mocker: MockerFixture,
+    tmp_venv: VirtualEnv,
+    installed: Repository,
+    pool: RepositoryPool,
+    http: type[httpretty.httpretty],
+    repo: Repository,
+) -> None:
+    mocker.patch.object(EnvManager, "get_system_env", return_value=tmp_venv)
+    mocker.patch(
+        "poetry.repositories.repository_pool.RepositoryPool.find_packages",
+        pool.find_packages,
+    )
+    mocker.patch(
+        "poetry.repositories.repository_pool.RepositoryPool.package", pool.package
+    )
+    mocker.patch(
+        "poetry.installation.installer.Installer._get_installed",
+        return_value=installed,
+    )
+    mocker.patch.object(Factory, "create_pool", side_effect=create_pool_factory(repo))
diff --git b/tests/console/commands/self/test_add_plugins.py a/tests/console/commands/self/test_add_plugins.py
new file mode 100644
index 0000000..bfbed48
--- /dev/null
+++ a/tests/console/commands/self/test_add_plugins.py
@@ -0,0 +1,299 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.packages.package import Package
+
+from poetry.console.commands.add import AddCommand
+from poetry.console.commands.self.self_command import SelfCommand
+from poetry.factory import Factory
+from tests.console.commands.self.utils import get_self_command_dependencies
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("self add")
+
+
+def assert_plugin_add_result(
+    tester: CommandTester,
+    expected: str,
+    constraint: str,
+) -> None:
+    assert tester.io.fetch_output() == expected
+    dependencies: list[str] | None = get_self_command_dependencies()
+
+    assert dependencies
+    assert "poetry-plugin" in dependencies[0]
+    assert constraint in dependencies[0]
+
+
+def test_add_no_constraint(
+    tester: CommandTester,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(Package("poetry-plugin", "0.1.0"))
+
+    tester.execute("poetry-plugin")
+
+    expected = """\
+Using version ^0.1.0 for poetry-plugin
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing poetry-plugin (0.1.0)
+
+Writing lock file
+"""
+    assert_plugin_add_result(tester, expected, "(>=0.1.0,<0.2.0)")
+
+
+def test_add_with_constraint(
+    tester: CommandTester,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(Package("poetry-plugin", "0.1.0"))
+    repo.add_package(Package("poetry-plugin", "0.2.0"))
+
+    tester.execute("poetry-plugin@^0.2.0")
+
+    expected = """
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing poetry-plugin (0.2.0)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(tester, expected, "(>=0.2.0,<0.3.0)")
+
+
+def test_add_with_git_constraint(
+    tester: CommandTester,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(Package("pendulum", "2.0.5"))
+
+    tester.execute("git+https://github.com/demo/poetry-plugin.git")
+
+    expected = """
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (2.0.5)
+  - Installing poetry-plugin (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(
+        tester, expected, "https://github.com/demo/poetry-plugin.git"
+    )
+
+
+def test_add_with_git_constraint_with_extras(
+    tester: CommandTester,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(Package("pendulum", "2.0.5"))
+    repo.add_package(Package("tomlkit", "0.7.0"))
+
+    tester.execute("git+https://github.com/demo/poetry-plugin.git[foo]")
+
+    expected = """
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 3 installs, 0 updates, 0 removals
+
+  - Installing pendulum (2.0.5)
+  - Installing tomlkit (0.7.0)
+  - Installing poetry-plugin (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(
+        tester,
+        expected,
+        "poetry-plugin[foo] @ git+https://github.com/demo/poetry-plugin.git",
+    )
+
+
+@pytest.mark.parametrize(
+    "url, rev",
+    [
+        ("git+https://github.com/demo/poetry-plugin2.git#subdirectory=subdir", None),
+        (
+            "git+https://github.com/demo/poetry-plugin2.git@master#subdirectory=subdir",
+            "master",
+        ),
+    ],
+)
+def test_add_with_git_constraint_with_subdirectory(
+    url: str,
+    rev: str | None,
+    tester: CommandTester,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(Package("pendulum", "2.0.5"))
+
+    tester.execute(url)
+
+    expected = """
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (2.0.5)
+  - Installing poetry-plugin (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(tester, expected, url)
+
+
+def test_add_existing_plugin_warns_about_no_operation(
+    tester: CommandTester,
+    repo: TestRepository,
+    installed: TestRepository,
+) -> None:
+    pyproject = SelfCommand.get_default_system_pyproject_file()
+    with open(pyproject, "w", encoding="utf-8", newline="") as f:
+        f.write(
+            f"""\
+[tool.poetry]
+name = "poetry-instance"
+version = "1.2.0"
+description = "Python dependency management and packaging made easy."
+authors = []
+
+[tool.poetry.dependencies]
+python = "^3.6"
+
+[tool.poetry.group.{SelfCommand.ADDITIONAL_PACKAGE_GROUP}.dependencies]
+poetry-plugin = "^1.2.3"
+"""
+        )
+
+    installed.add_package(Package("poetry-plugin", "1.2.3"))
+
+    repo.add_package(Package("poetry-plugin", "1.2.3"))
+
+    tester.execute("poetry-plugin")
+
+    assert isinstance(tester.command, AddCommand)
+    expected = f"""\
+The following packages are already present in the pyproject.toml and will be\
+ skipped:
+
+  - poetry-plugin
+{tester.command._hint_update_packages}
+Nothing to add.
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_add_existing_plugin_updates_if_requested(
+    tester: CommandTester,
+    repo: TestRepository,
+    installed: TestRepository,
+) -> None:
+    pyproject = SelfCommand.get_default_system_pyproject_file()
+    with open(pyproject, "w", encoding="utf-8", newline="") as f:
+        f.write(
+            f"""\
+[tool.poetry]
+name = "poetry-instance"
+version = "1.2.0"
+description = "Python dependency management and packaging made easy."
+authors = []
+
+[tool.poetry.dependencies]
+python = "^3.6"
+
+[dependency-groups]
+{SelfCommand.ADDITIONAL_PACKAGE_GROUP} = [
+    "poetry-plugin (>=1.2.3,<2.0.0)"
+]
+"""
+        )
+
+    installed.add_package(Package("poetry-plugin", "1.2.3"))
+
+    repo.add_package(Package("poetry-plugin", "1.2.3"))
+    repo.add_package(Package("poetry-plugin", "2.3.4"))
+
+    tester.execute("poetry-plugin@latest")
+
+    expected = """\
+Using version ^2.3.4 for poetry-plugin
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 0 installs, 1 update, 0 removals
+
+  - Updating poetry-plugin (1.2.3 -> 2.3.4)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(tester, expected, "(>=2.3.4,<3.0.0)")
+
+
+def test_adding_a_plugin_can_update_poetry_dependencies_if_needed(
+    tester: CommandTester,
+    repo: TestRepository,
+    installed: TestRepository,
+    poetry_package: Package,
+) -> None:
+    poetry_package.add_dependency(Factory.create_dependency("tomlkit", "^0.7.0"))
+
+    plugin_package = Package("poetry-plugin", "1.2.3")
+    plugin_package.add_dependency(Factory.create_dependency("tomlkit", "^0.7.2"))
+
+    installed.add_package(poetry_package)
+    installed.add_package(Package("tomlkit", "0.7.1"))
+
+    repo.add_package(plugin_package)
+    repo.add_package(Package("tomlkit", "0.7.1"))
+    repo.add_package(Package("tomlkit", "0.7.2"))
+
+    tester.execute("poetry-plugin")
+
+    expected = """\
+Using version ^1.2.3 for poetry-plugin
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 1 update, 0 removals
+
+  - Updating tomlkit (0.7.1 -> 0.7.2)
+  - Installing poetry-plugin (1.2.3)
+
+Writing lock file
+"""
+
+    assert_plugin_add_result(tester, expected, "(>=1.2.3,<2.0.0)")
diff --git b/tests/console/commands/self/test_install.py a/tests/console/commands/self/test_install.py
new file mode 100644
index 0000000..0cd9663
--- /dev/null
+++ a/tests/console/commands/self/test_install.py
@@ -0,0 +1,74 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.console.commands.self.install import SelfInstallCommand
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def command() -> str:
+    return "self install"
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory, command: str) -> CommandTester:
+    return command_tester_factory(command)
+
+
+@pytest.mark.parametrize(
+    "pyproject_content",
+    (
+        None,
+        """\
+[tool.poetry]
+name = "poetry-instance"
+version = "1.2"
+description = ""
+authors = []
+license = ""
+# no package-mode -> defaults to true
+
+[tool.poetry.dependencies]
+python = "3.9"
+poetry = "1.2"
+""",
+    ),
+)
+def test_self_install(
+    tester: CommandTester,
+    pyproject_content: str | None,
+) -> None:
+    command = tester.command
+    assert isinstance(command, SelfInstallCommand)
+    pyproject_path = command.system_pyproject
+    if pyproject_content:
+        pyproject_path.write_text(pyproject_content, encoding="utf-8")
+    else:
+        assert not pyproject_path.exists()
+
+    tester.execute()
+
+    output = tester.io.fetch_output()
+    assert output.startswith("Updating dependencies")
+    assert output.endswith("Writing lock file\n")
+    assert tester.io.fetch_error() == ""
+
+
+@pytest.mark.parametrize("sync", [True, False])
+def test_sync_deprecation(tester: CommandTester, sync: bool) -> None:
+    tester.execute("--sync" if sync else "")
+
+    error = tester.io.fetch_error()
+    if sync:
+        assert "deprecated" in error
+        assert "poetry self sync" in error
+    else:
+        assert error == ""
diff --git b/tests/console/commands/self/test_remove_plugins.py a/tests/console/commands/self/test_remove_plugins.py
new file mode 100644
index 0000000..2e70872
--- /dev/null
+++ a/tests/console/commands/self/test_remove_plugins.py
@@ -0,0 +1,112 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+import tomlkit
+
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.package import Package
+from poetry.core.packages.project_package import ProjectPackage
+
+from poetry.__version__ import __version__
+from poetry.console.commands.self.self_command import SelfCommand
+from poetry.factory import Factory
+from tests.console.commands.self.utils import get_self_command_dependencies
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.repositories import Repository
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("self remove")
+
+
+@pytest.fixture(autouse=True)
+def install_plugin(installed: Repository) -> None:
+    package = ProjectPackage("poetry-instance", __version__)
+    plugin = Package("poetry-plugin", "1.2.3")
+
+    content = Factory.create_legacy_pyproject_from_package(package)
+    content["dependency-groups"] = tomlkit.table()
+    content["dependency-groups"][SelfCommand.ADDITIONAL_PACKAGE_GROUP] = tomlkit.array(  # type: ignore[index]
+        "[\n]"
+    )
+    content["dependency-groups"][SelfCommand.ADDITIONAL_PACKAGE_GROUP].append(  # type: ignore[index, union-attr, call-arg]
+        Dependency(plugin.name, "^1.2.3").to_pep_508()
+    )
+
+    system_pyproject_file = SelfCommand.get_default_system_pyproject_file()
+    with open(system_pyproject_file, "w", encoding="utf-8", newline="") as f:
+        f.write(content.as_string())
+
+    lock_content = {
+        "package": [
+            {
+                "name": "poetry-plugin",
+                "version": "1.2.3",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "files": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": "2.0",
+            "python-versions": "^3.6",
+            "content-hash": "123456789",
+        },
+    }
+    system_pyproject_file.parent.joinpath("poetry.lock").write_text(
+        tomlkit.dumps(lock_content), encoding="utf-8"
+    )
+
+    installed.add_package(plugin)
+
+
+def test_remove_installed_package(tester: CommandTester) -> None:
+    tester.execute("poetry-plugin")
+
+    expected = """\
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 0 installs, 0 updates, 1 removal
+
+  - Removing poetry-plugin (1.2.3)
+
+Writing lock file
+"""
+    assert tester.io.fetch_output() == expected
+
+    dependencies = get_self_command_dependencies()
+
+    assert not dependencies
+
+
+def test_remove_installed_package_dry_run(tester: CommandTester) -> None:
+    tester.execute("poetry-plugin --dry-run")
+
+    expected = f"""\
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 0 installs, 0 updates, 1 removal, 1 skipped
+
+  - Removing poetry-plugin (1.2.3)
+  - Installing poetry ({__version__}): Skipped for the following reason: Already \
+installed
+"""
+
+    assert tester.io.fetch_output() == expected
+
+    dependencies = get_self_command_dependencies()
+
+    assert dependencies
+    assert len(dependencies) == 1
+    assert "poetry-plugin" in dependencies[0]
diff --git b/tests/console/commands/self/test_self_command.py a/tests/console/commands/self/test_self_command.py
new file mode 100644
index 0000000..b5cfe6a
--- /dev/null
+++ a/tests/console/commands/self/test_self_command.py
@@ -0,0 +1,53 @@
+from __future__ import annotations
+
+import pytest
+
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.package import Package
+from poetry.core.packages.project_package import ProjectPackage
+
+from poetry.__version__ import __version__
+from poetry.console.commands.self.self_command import SelfCommand
+from poetry.factory import Factory
+
+
+@pytest.fixture
+def example_system_pyproject() -> str:
+    package = ProjectPackage("poetry-instance", __version__)
+    plugin = Package("poetry-plugin", "1.2.3")
+
+    package.add_dependency(
+        Dependency(plugin.name, "^1.2.3", groups=[SelfCommand.ADDITIONAL_PACKAGE_GROUP])
+    )
+    content = Factory.create_legacy_pyproject_from_package(package)
+    return content.as_string().rstrip("\n")
+
+
+@pytest.mark.parametrize("existing_newlines", [0, 2])
+def test_generate_system_pyproject_trailing_newline(
+    existing_newlines: int,
+    example_system_pyproject: str,
+) -> None:
+    cmd = SelfCommand()
+    cmd.system_pyproject.write_text(
+        example_system_pyproject + "\n" * existing_newlines, encoding="utf-8"
+    )
+    cmd.generate_system_pyproject()
+    generated = cmd.system_pyproject.read_text(encoding="utf-8")
+
+    assert len(generated) - len(generated.rstrip("\n")) == existing_newlines
+
+
+def test_generate_system_pyproject_carriage_returns(
+    example_system_pyproject: str,
+) -> None:
+    cmd = SelfCommand()
+    cmd.system_pyproject.write_text(example_system_pyproject + "\n", encoding="utf-8")
+    cmd.generate_system_pyproject()
+
+    with open(
+        cmd.system_pyproject, newline="", encoding="utf-8"
+    ) as f:  # do not translate newlines
+        generated = f.read()
+
+    assert "\r\r" not in generated
diff --git b/tests/console/commands/self/test_show.py a/tests/console/commands/self/test_show.py
new file mode 100644
index 0000000..d1b553a
--- /dev/null
+++ a/tests/console/commands/self/test_show.py
@@ -0,0 +1,72 @@
+from __future__ import annotations
+
+import json
+
+from typing import TYPE_CHECKING
+
+import pytest
+import tomlkit
+
+from poetry.__version__ import __version__
+from poetry.console.commands.self.self_command import SelfCommand
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("self show")
+
+
+@pytest.mark.parametrize("options", ["", "--format json", "--format text"])
+def test_show_format(tester: CommandTester, options: str) -> None:
+    pyproject_content = {
+        "tool": {
+            "poetry": {
+                "name": "poetry-instance",
+                "version": __version__,
+                "dependencies": {"python": "^3.9", "poetry": __version__},
+            }
+        }
+    }
+    lock_content = {
+        "package": [
+            {
+                "name": "poetry",
+                "version": __version__,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "files": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": "2.0",
+            "python-versions": "^3.9",
+            "content-hash": "123456789",
+        },
+    }
+    if "json" in options:
+        expected = json.dumps(
+            [
+                {
+                    "name": "poetry",
+                    "installed_status": "installed",
+                    "version": __version__,
+                    "description": "",
+                }
+            ]
+        )
+    else:
+        expected = f"poetry {__version__}"
+    system_pyproject_file = SelfCommand.get_default_system_pyproject_file()
+    system_pyproject_file.write_text(tomlkit.dumps(pyproject_content), encoding="utf-8")
+    system_pyproject_file.parent.joinpath("poetry.lock").write_text(
+        tomlkit.dumps(lock_content), encoding="utf-8"
+    )
+    assert tester.execute(options) == 0
+    assert tester.io.fetch_output().strip() == expected
diff --git b/tests/console/commands/self/test_show_plugins.py a/tests/console/commands/self/test_show_plugins.py
new file mode 100644
index 0000000..e80afa8
--- /dev/null
+++ a/tests/console/commands/self/test_show_plugins.py
@@ -0,0 +1,226 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Callable
+
+import pytest
+
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.package import Package
+
+from poetry.plugins.application_plugin import ApplicationPlugin
+from poetry.plugins.plugin import Plugin
+from poetry.utils._compat import metadata
+
+
+if TYPE_CHECKING:
+    from os import PathLike
+    from pathlib import Path
+
+    from cleo.io.io import IO
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.plugins.base_plugin import BasePlugin
+    from poetry.poetry import Poetry
+    from poetry.repositories import Repository
+    from poetry.utils.env import Env
+    from tests.helpers import PoetryTestApplication
+    from tests.types import CommandTesterFactory
+
+
+class DoNothingPlugin(Plugin):
+    def activate(self, poetry: Poetry, io: IO) -> None:
+        pass
+
+
+class EntryPoint(metadata.EntryPoint):
+    def load(self) -> type[BasePlugin]:
+        if self.group == ApplicationPlugin.group:
+            return ApplicationPlugin
+
+        return DoNothingPlugin
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("self show plugins")
+
+
+@pytest.fixture()
+def plugin_package_requires_dist() -> list[str]:
+    return []
+
+
+@pytest.fixture()
+def plugin_package(plugin_package_requires_dist: list[str]) -> Package:
+    package = Package("poetry-plugin", "1.2.3")
+
+    for requirement in plugin_package_requires_dist:
+        package.add_dependency(Dependency.create_from_pep_508(requirement))
+
+    return package
+
+
+@pytest.fixture()
+def plugin_distro(plugin_package: Package, tmp_path: Path) -> metadata.Distribution:
+    class MockDistribution(metadata.Distribution):
+        def read_text(self, filename: str) -> str | None:
+            if filename == "METADATA":
+                return "\n".join(
+                    [
+                        f"Name: {plugin_package.name}",
+                        f"Version: {plugin_package.version}",
+                        *[
+                            f"Requires-Dist: {dep.to_pep_508()}"
+                            for dep in plugin_package.requires
+                        ],
+                    ]
+                )
+            return None
+
+        def locate_file(self, path: str | PathLike[str]) -> Path:
+            return tmp_path / path
+
+    return MockDistribution()  # type: ignore[no-untyped-call]
+
+
+@pytest.fixture
+def entry_point_name() -> str:
+    return "poetry-plugin"
+
+
+@pytest.fixture
+def entry_point_values_by_group() -> dict[str, list[str]]:
+    return {}
+
+
+@pytest.fixture
+def entry_points(
+    entry_point_name: str,
+    entry_point_values_by_group: dict[str, list[str]],
+    plugin_distro: metadata.Distribution,
+) -> Callable[..., list[metadata.EntryPoint]]:
+    by_group = {
+        key: [
+            EntryPoint(  # type: ignore[no-untyped-call]
+                name=entry_point_name,
+                group=key,
+                value=value,
+            )._for(  # type: ignore[attr-defined]
+                plugin_distro
+            )
+            for value in values
+        ]
+        for key, values in entry_point_values_by_group.items()
+    }
+
+    def _entry_points(**params: Any) -> list[metadata.EntryPoint]:
+        group = params.get("group")
+
+        if group not in by_group:
+            return []
+
+        eps: list[metadata.EntryPoint] = by_group[group]
+
+        return eps
+
+    return _entry_points
+
+
+@pytest.fixture(autouse=True)
+def mock_metadata_entry_points(
+    plugin_package: Package,
+    plugin_distro: metadata.Distribution,
+    installed: Repository,
+    mocker: MockerFixture,
+    tmp_venv: Env,
+    entry_points: Callable[..., metadata.EntryPoint],
+) -> None:
+    installed.add_package(plugin_package)
+
+    mocker.patch.object(
+        tmp_venv.site_packages, "find_distribution", return_value=plugin_distro
+    )
+    mocker.patch.object(metadata, "entry_points", entry_points)
+
+
+@pytest.mark.parametrize("entry_point_name", ["poetry-plugin", "not-package-name"])
+@pytest.mark.parametrize(
+    "entry_point_values_by_group",
+    [
+        {
+            ApplicationPlugin.group: ["FirstApplicationPlugin"],
+            Plugin.group: ["FirstPlugin"],
+        }
+    ],
+)
+def test_show_displays_installed_plugins(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    tester.execute("")
+
+    expected = """
+  - poetry-plugin (1.2.3)
+      1 plugin and 1 application plugin
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    "entry_point_values_by_group",
+    [
+        {
+            ApplicationPlugin.group: [
+                "FirstApplicationPlugin",
+                "SecondApplicationPlugin",
+            ],
+            Plugin.group: ["FirstPlugin", "SecondPlugin"],
+        }
+    ],
+)
+def test_show_displays_installed_plugins_with_multiple_plugins(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    tester.execute("")
+
+    expected = """
+  - poetry-plugin (1.2.3)
+      2 plugins and 2 application plugins
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    "plugin_package_requires_dist", [["foo (>=1.2.3)", "bar (<4.5.6)"]]
+)
+@pytest.mark.parametrize(
+    "entry_point_values_by_group",
+    [
+        {
+            ApplicationPlugin.group: ["FirstApplicationPlugin"],
+            Plugin.group: ["FirstPlugin"],
+        }
+    ],
+)
+def test_show_displays_installed_plugins_with_dependencies(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    tester.execute("")
+
+    expected = """
+  - poetry-plugin (1.2.3)
+      1 plugin and 1 application plugin
+
+      Dependencies
+        - foo (>=1.2.3)
+        - bar (<4.5.6)
+"""
+
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/self/test_sync.py a/tests/console/commands/self/test_sync.py
new file mode 100644
index 0000000..d1c351c
--- /dev/null
+++ a/tests/console/commands/self/test_sync.py
@@ -0,0 +1,45 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.exceptions import CleoNoSuchOptionError
+
+from poetry.console.commands.self.sync import SelfSyncCommand
+
+# import all tests from the self install command
+# and run them for sync by overriding the command fixture
+from tests.console.commands.self.test_install import *  # noqa: F403
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+
+@pytest.fixture  # type: ignore[no-redef]
+def command() -> str:
+    return "self sync"
+
+
+@pytest.mark.skip("Only relevant for `poetry self install`")  # type: ignore[no-redef]
+def test_sync_deprecation() -> None:
+    """The only test from the self install command that does not work for self sync."""
+
+
+def test_sync_option_not_available(tester: CommandTester) -> None:
+    with pytest.raises(CleoNoSuchOptionError):
+        tester.execute("--sync")
+
+
+def test_synced_installer(tester: CommandTester, mocker: MockerFixture) -> None:
+    assert isinstance(tester.command, SelfSyncCommand)
+    mock = mocker.patch(
+        "poetry.console.commands.install.InstallCommand.installer",
+        new_callable=mocker.PropertyMock,
+    )
+
+    tester.execute()
+
+    mock.return_value.requires_synchronization.assert_called_with(True)
diff --git b/tests/console/commands/self/test_update.py a/tests/console/commands/self/test_update.py
new file mode 100644
index 0000000..808a766
--- /dev/null
+++ a/tests/console/commands/self/test_update.py
@@ -0,0 +1,80 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.constraints.version import Version
+from poetry.core.packages.package import Package
+
+from poetry.__version__ import __version__
+from poetry.factory import Factory
+from poetry.installation.executor import Executor
+from poetry.installation.wheel_installer import WheelInstaller
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+
+
+@pytest.fixture
+def setup(mocker: MockerFixture, fixture_dir: FixtureDirGetter) -> None:
+    mocker.patch.object(
+        Executor,
+        "_download",
+        return_value=fixture_dir("distributions").joinpath(
+            "demo-0.1.2-py2.py3-none-any.whl"
+        ),
+    )
+
+    mocker.patch.object(WheelInstaller, "install")
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("self update")
+
+
+def test_self_update_can_update_from_recommended_installation(
+    tester: CommandTester,
+    repo: TestRepository,
+    installed: TestRepository,
+) -> None:
+    new_version = Version.parse(__version__).next_minor().text
+
+    old_poetry = Package("poetry", __version__)
+    old_poetry.add_dependency(Factory.create_dependency("cleo", "^0.8.2"))
+
+    new_poetry = Package("poetry", new_version)
+    new_poetry.add_dependency(Factory.create_dependency("cleo", "^1.0.0"))
+
+    installed.add_package(old_poetry)
+    installed.add_package(Package("cleo", "0.8.2"))
+
+    repo.add_package(new_poetry)
+    repo.add_package(Package("cleo", "1.0.0"))
+
+    tester.execute()
+
+    expected_output = f"""\
+Updating Poetry version ...
+
+Using version ^{new_version} for poetry
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 0 installs, 2 updates, 0 removals
+
+  - Updating cleo (0.8.2 -> 1.0.0)
+  - Updating poetry ({__version__} -> {new_version})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected_output
diff --git b/tests/console/commands/self/utils.py a/tests/console/commands/self/utils.py
new file mode 100644
index 0000000..2844891
--- /dev/null
+++ a/tests/console/commands/self/utils.py
@@ -0,0 +1,33 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Any
+
+from tomlkit.items import Array
+
+from poetry.factory import Factory
+
+
+def get_self_command_dependencies(locked: bool = True) -> Array | None:
+    from poetry.console.commands.self.self_command import SelfCommand
+    from poetry.locations import CONFIG_DIR
+
+    system_pyproject_file = SelfCommand.get_default_system_pyproject_file()
+
+    assert system_pyproject_file.exists()
+    assert system_pyproject_file.parent == Path(CONFIG_DIR)
+
+    if locked:
+        assert system_pyproject_file.parent.joinpath("poetry.lock").exists()
+
+    poetry = Factory().create_poetry(system_pyproject_file.parent, disable_plugins=True)
+
+    pyproject: dict[str, Any] = poetry.file.read()
+    content = pyproject.get("dependency-groups", {})
+
+    if SelfCommand.ADDITIONAL_PACKAGE_GROUP not in content:
+        return None
+
+    dependencies = content[SelfCommand.ADDITIONAL_PACKAGE_GROUP]
+    assert isinstance(dependencies, Array)
+    return dependencies
diff --git b/tests/console/commands/source/conftest.py a/tests/console/commands/source/conftest.py
new file mode 100644
index 0000000..9951edc
--- /dev/null
+++ a/tests/console/commands/source/conftest.py
@@ -0,0 +1,160 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.config.source import Source
+from poetry.repositories.repository_pool import Priority
+
+
+if TYPE_CHECKING:
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def source_one() -> Source:
+    return Source(name="one", url="https://one.com")
+
+
+@pytest.fixture
+def source_two() -> Source:
+    return Source(name="two", url="https://two.com")
+
+
+@pytest.fixture
+def source_primary() -> Source:
+    return Source(name="primary", url="https://primary.com", priority=Priority.PRIMARY)
+
+
+@pytest.fixture
+def source_supplemental() -> Source:
+    return Source(
+        name="supplemental",
+        url="https://supplemental.com",
+        priority=Priority.SUPPLEMENTAL,
+    )
+
+
+@pytest.fixture
+def source_explicit() -> Source:
+    return Source(
+        name="explicit", url="https://explicit.com", priority=Priority.EXPLICIT
+    )
+
+
+@pytest.fixture
+def source_pypi() -> Source:
+    return Source(name="PyPI")
+
+
+@pytest.fixture
+def source_pypi_explicit() -> Source:
+    return Source(name="PyPI", priority=Priority.EXPLICIT)
+
+
+_existing_source = Source(name="existing", url="https://existing.com")
+
+
+@pytest.fixture
+def source_existing() -> Source:
+    return _existing_source
+
+
+PYPROJECT_WITHOUT_POETRY_SECTION = """
+[project]
+name = "source-command-test"
+version = "0.1.0"
+"""
+
+
+PYPROJECT_WITHOUT_SOURCES = """
+[tool.poetry]
+name = "source-command-test"
+version = "0.1.0"
+description = ""
+authors = ["Poetry Tester <tester@poetry.org>"]
+
+[tool.poetry.dependencies]
+python = "^3.9"
+
+[tool.poetry.dev-dependencies]
+"""
+
+
+PYPROJECT_WITH_SOURCES = f"""{PYPROJECT_WITHOUT_SOURCES}
+
+[[tool.poetry.source]]
+name = "{_existing_source.name}"
+url = "{_existing_source.url}"
+"""
+
+
+PYPROJECT_WITH_PYPI = f"""{PYPROJECT_WITHOUT_SOURCES}
+
+[[tool.poetry.source]]
+name = "PyPI"
+"""
+
+
+PYPROJECT_WITH_PYPI_AND_OTHER = f"""{PYPROJECT_WITH_SOURCES}
+
+[[tool.poetry.source]]
+name = "PyPI"
+"""
+
+
+@pytest.fixture
+def poetry_without_poetry_section(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(pyproject_content=PYPROJECT_WITHOUT_POETRY_SECTION)
+
+
+@pytest.fixture
+def poetry_without_source(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(pyproject_content=PYPROJECT_WITHOUT_SOURCES)
+
+
+@pytest.fixture
+def poetry_with_source(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(pyproject_content=PYPROJECT_WITH_SOURCES)
+
+
+@pytest.fixture
+def poetry_with_pypi(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(pyproject_content=PYPROJECT_WITH_PYPI)
+
+
+@pytest.fixture
+def poetry_with_pypi_and_other(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(pyproject_content=PYPROJECT_WITH_PYPI_AND_OTHER)
+
+
+@pytest.fixture
+def add_multiple_sources(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_source: Poetry,
+    source_one: Source,
+    source_two: Source,
+) -> None:
+    add = command_tester_factory("source add", poetry=poetry_with_source)
+    for source in [source_one, source_two]:
+        add.execute(f"{source.name} {source.url}")
+
+
+@pytest.fixture
+def add_all_source_types(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_source: Poetry,
+    source_primary: Source,
+    source_supplemental: Source,
+    source_explicit: Source,
+) -> None:
+    add = command_tester_factory("source add", poetry=poetry_with_source)
+    for source in [
+        source_primary,
+        source_supplemental,
+        source_explicit,
+    ]:
+        add.execute(f"{source.name} {source.url} --priority={source.name}")
diff --git b/tests/console/commands/source/test_add.py a/tests/console/commands/source/test_add.py
new file mode 100644
index 0000000..6829faf
--- /dev/null
+++ a/tests/console/commands/source/test_add.py
@@ -0,0 +1,176 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.config.source import Source
+from poetry.repositories.repository_pool import Priority
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterable
+
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(
+    command_tester_factory: CommandTesterFactory, poetry_with_source: Poetry
+) -> CommandTester:
+    return command_tester_factory("source add", poetry=poetry_with_source)
+
+
+def assert_source_added(
+    tester: CommandTester,
+    poetry: Poetry,
+    added_source: Source,
+    existing_sources: Iterable[Source] = (),
+) -> None:
+    expected_error = ""
+    if tester.io.input.option("priority") is None:
+        expected_error = f"The default priority will change to supplemental in a future release.\n{expected_error}"
+    assert tester.io.fetch_error().strip() == expected_error.strip()
+
+    expected_output = f"Adding source with name {added_source.name}."
+    assert tester.io.fetch_output().strip() == expected_output
+
+    poetry.pyproject.reload()
+    sources = poetry.get_sources()
+    assert sources == [*existing_sources, added_source]
+    assert tester.status_code == 0
+
+
+def test_source_add_simple(
+    tester: CommandTester,
+    source_existing: Source,
+    source_one: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    tester.execute(f"{source_one.name} {source_one.url}")
+    assert_source_added(tester, poetry_with_source, source_one, [source_existing])
+
+
+def test_source_add_simple_without_existing_sources(
+    tester: CommandTester,
+    source_one: Source,
+    poetry_without_source: Poetry,
+) -> None:
+    tester.execute(f"{source_one.name} {source_one.url}")
+    assert_source_added(tester, poetry_without_source, source_one)
+
+
+def test_source_add_supplemental(
+    tester: CommandTester,
+    source_existing: Source,
+    source_supplemental: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    tester.execute(
+        f"--priority=supplemental {source_supplemental.name} {source_supplemental.url}"
+    )
+    assert_source_added(
+        tester, poetry_with_source, source_supplemental, [source_existing]
+    )
+
+
+def test_source_add_explicit(
+    tester: CommandTester,
+    source_existing: Source,
+    source_explicit: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    tester.execute(f"--priority=explicit {source_explicit.name} {source_explicit.url}")
+    assert_source_added(tester, poetry_with_source, source_explicit, [source_existing])
+
+
+def test_source_add_error_no_url(tester: CommandTester) -> None:
+    tester.execute("foo")
+    assert (
+        tester.io.fetch_error().strip()
+        == "A custom source cannot be added without a URL."
+    )
+    assert tester.status_code == 1
+
+
+def test_source_add_error_pypi(tester: CommandTester) -> None:
+    tester.execute("pypi https://test.pypi.org/simple/")
+    assert (
+        tester.io.fetch_error().strip() == "The URL of PyPI is fixed and cannot be set."
+    )
+    assert tester.status_code == 1
+
+
+@pytest.mark.parametrize("name", ["pypi", "PyPI"])
+def test_source_add_pypi(
+    name: str,
+    tester: CommandTester,
+    source_existing: Source,
+    source_pypi: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    tester.execute(name)
+    assert_source_added(tester, poetry_with_source, source_pypi, [source_existing])
+
+
+def test_source_add_pypi_explicit(
+    tester: CommandTester,
+    source_existing: Source,
+    source_pypi_explicit: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    tester.execute("--priority=explicit PyPI")
+    assert_source_added(
+        tester, poetry_with_source, source_pypi_explicit, [source_existing]
+    )
+
+
+@pytest.mark.parametrize("modifier", ["lower", "upper"])
+def test_source_add_existing_no_change_except_case_of_name(
+    modifier: str,
+    tester: CommandTester,
+    source_existing: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    name = getattr(source_existing.name, modifier)()
+    tester.execute(f"--priority=primary {name} {source_existing.url}")
+    assert (
+        tester.io.fetch_output().strip()
+        == f"Source with name {name} already exists. Updating."
+    )
+
+    poetry_with_source.pyproject.reload()
+    sources = poetry_with_source.get_sources()
+
+    assert len(sources) == 1
+    assert sources[0].name == getattr(source_existing.name, modifier)()
+    assert sources[0].url == source_existing.url
+    assert sources[0].priority == source_existing.priority
+
+
+@pytest.mark.parametrize("modifier", ["lower", "upper"])
+def test_source_add_existing_updating(
+    modifier: str,
+    tester: CommandTester,
+    source_existing: Source,
+    poetry_with_source: Poetry,
+) -> None:
+    name = getattr(source_existing.name, modifier)()
+    tester.execute(f"--priority=supplemental {name} {source_existing.url}")
+    assert (
+        tester.io.fetch_output().strip()
+        == f"Source with name {name} already exists. Updating."
+    )
+
+    poetry_with_source.pyproject.reload()
+    sources = poetry_with_source.get_sources()
+
+    assert len(sources) == 1
+    assert sources[0] != source_existing
+    expected_source = Source(
+        name=name, url=source_existing.url, priority=Priority.SUPPLEMENTAL
+    )
+    assert sources[0] == expected_source
diff --git b/tests/console/commands/source/test_remove.py a/tests/console/commands/source/test_remove.py
new file mode 100644
index 0000000..7237a68
--- /dev/null
+++ a/tests/console/commands/source/test_remove.py
@@ -0,0 +1,101 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.config.source import Source
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_source: Poetry,
+    add_multiple_sources: None,
+) -> CommandTester:
+    return command_tester_factory("source remove", poetry=poetry_with_source)
+
+
+@pytest.fixture
+def tester_pypi(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_pypi: Poetry,
+) -> CommandTester:
+    return command_tester_factory("source remove", poetry=poetry_with_pypi)
+
+
+@pytest.fixture
+def tester_pypi_and_other(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_pypi_and_other: Poetry,
+) -> CommandTester:
+    return command_tester_factory("source remove", poetry=poetry_with_pypi_and_other)
+
+
+@pytest.mark.parametrize("modifier", ["lower", "upper"])
+def test_source_remove_simple(
+    tester: CommandTester,
+    poetry_with_source: Poetry,
+    source_existing: Source,
+    source_one: Source,
+    source_two: Source,
+    modifier: str,
+) -> None:
+    tester.execute(getattr(f"{source_existing.name}", modifier)())
+    assert (
+        tester.io.fetch_output().strip()
+        == f"Removing source with name {source_existing.name}."
+    )
+
+    poetry_with_source.pyproject.reload()
+    sources = poetry_with_source.get_sources()
+    assert sources == [source_one, source_two]
+
+    assert tester.status_code == 0
+
+
+@pytest.mark.parametrize("name", ["pypi", "PyPI"])
+def test_source_remove_pypi(
+    name: str, tester_pypi: CommandTester, poetry_with_pypi: Poetry
+) -> None:
+    tester_pypi.execute(name)
+    assert tester_pypi.io.fetch_output().strip() == "Removing source with name PyPI."
+
+    poetry_with_pypi.pyproject.reload()
+    sources = poetry_with_pypi.get_sources()
+    assert sources == []
+
+    assert tester_pypi.status_code == 0
+
+
+@pytest.mark.parametrize("name", ["pypi", "PyPI"])
+def test_source_remove_pypi_and_other(
+    name: str,
+    tester_pypi_and_other: CommandTester,
+    poetry_with_pypi_and_other: Poetry,
+    source_existing: Source,
+) -> None:
+    tester_pypi_and_other.execute(name)
+    assert (
+        tester_pypi_and_other.io.fetch_output().strip()
+        == "Removing source with name PyPI."
+    )
+
+    poetry_with_pypi_and_other.pyproject.reload()
+    sources = poetry_with_pypi_and_other.get_sources()
+    assert sources == [source_existing]
+
+    assert tester_pypi_and_other.status_code == 0
+
+
+@pytest.mark.parametrize("name", ["foo", "pypi", "PyPI"])
+def test_source_remove_error(name: str, tester: CommandTester) -> None:
+    tester.execute(name)
+    assert tester.io.fetch_error().strip() == f"Source with name {name} was not found."
+    assert tester.status_code == 1
diff --git b/tests/console/commands/source/test_show.py a/tests/console/commands/source/test_show.py
new file mode 100644
index 0000000..d598034
--- /dev/null
+++ a/tests/console/commands/source/test_show.py
@@ -0,0 +1,200 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.repositories.pypi_repository import PyPiRepository
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.config.source import Source
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_source: Poetry,
+    add_multiple_sources: None,
+) -> CommandTester:
+    return command_tester_factory("source show", poetry=poetry_with_source)
+
+
+@pytest.fixture
+def tester_no_sources(
+    command_tester_factory: CommandTesterFactory,
+    poetry_without_source: Poetry,
+) -> CommandTester:
+    return command_tester_factory("source show", poetry=poetry_without_source)
+
+
+@pytest.fixture
+def tester_pypi(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_pypi: Poetry,
+) -> CommandTester:
+    return command_tester_factory("source show", poetry=poetry_with_pypi)
+
+
+@pytest.fixture
+def tester_pypi_and_other(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_pypi_and_other: Poetry,
+) -> CommandTester:
+    return command_tester_factory("source show", poetry=poetry_with_pypi_and_other)
+
+
+@pytest.fixture
+def tester_all_types(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_source: Poetry,
+    add_all_source_types: None,
+) -> CommandTester:
+    return command_tester_factory("source show", poetry=poetry_with_source)
+
+
+def test_source_show_simple(tester: CommandTester) -> None:
+    tester.execute("")
+
+    expected = """\
+name      : existing
+url       : https://existing.com
+priority  : primary
+
+name      : one
+url       : https://one.com
+priority  : primary
+
+name      : two
+url       : https://two.com
+priority  : primary
+""".splitlines()
+    assert [
+        line.strip() for line in tester.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester.status_code == 0
+
+
+@pytest.mark.parametrize("modifier", ["lower", "upper"])
+def test_source_show_one(
+    tester: CommandTester, source_one: Source, modifier: str
+) -> None:
+    tester.execute(getattr(f"{source_one.name}", modifier)())
+
+    expected = """\
+name      : one
+url       : https://one.com
+priority  : primary
+""".splitlines()
+    assert [
+        line.strip() for line in tester.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester.status_code == 0
+
+
+@pytest.mark.parametrize("modifier", ["lower", "upper"])
+def test_source_show_two(
+    tester: CommandTester, source_one: Source, source_two: Source, modifier: str
+) -> None:
+    tester.execute(getattr(f"{source_one.name} {source_two.name}", modifier)())
+
+    expected = """\
+name      : one
+url       : https://one.com
+priority  : primary
+
+name      : two
+url       : https://two.com
+priority  : primary
+""".splitlines()
+    assert [
+        line.strip() for line in tester.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester.status_code == 0
+
+
+@pytest.mark.parametrize(
+    "source_str",
+    (
+        "source_primary",
+        "source_supplemental",
+        "source_explicit",
+    ),
+)
+def test_source_show_given_priority(
+    tester_all_types: CommandTester, source_str: str, request: pytest.FixtureRequest
+) -> None:
+    source = request.getfixturevalue(source_str)
+    tester_all_types.execute(f"{source.name}")
+
+    expected = f"""\
+name      : {source.name}
+url       : {source.url}
+priority  : {source.name}
+""".splitlines()
+    assert [
+        line.strip() for line in tester_all_types.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester_all_types.status_code == 0
+
+
+def test_source_show_pypi(tester_pypi: CommandTester) -> None:
+    tester_pypi.execute("")
+    expected = """\
+name      : PyPI
+priority  : primary
+""".splitlines()
+    assert [
+        line.strip() for line in tester_pypi.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester_pypi.status_code == 0
+
+
+def test_source_show_pypi_and_other(tester_pypi_and_other: CommandTester) -> None:
+    tester_pypi_and_other.execute("")
+    expected = """\
+name      : existing
+url       : https://existing.com
+priority  : primary
+
+name      : PyPI
+priority  : primary
+""".splitlines()
+    assert [
+        line.strip()
+        for line in tester_pypi_and_other.io.fetch_output().strip().splitlines()
+    ] == expected
+    assert tester_pypi_and_other.status_code == 0
+
+
+def test_source_show_no_sources(tester_no_sources: CommandTester) -> None:
+    tester_no_sources.execute("error")
+    assert (
+        tester_no_sources.io.fetch_output().strip()
+        == "No sources configured for this project."
+    )
+    assert tester_no_sources.status_code == 0
+
+
+def test_source_show_no_sources_implicit_pypi(
+    tester_no_sources: CommandTester, poetry_without_source: Poetry
+) -> None:
+    poetry_without_source.pool.add_repository(PyPiRepository())
+    tester_no_sources.execute("")
+
+    output = tester_no_sources.io.fetch_output().strip()
+
+    assert "No sources configured for this project." in output
+    assert "PyPI is implicitly enabled as a primary source." in output
+
+    assert tester_no_sources.status_code == 0
+
+
+def test_source_show_error(tester: CommandTester) -> None:
+    tester.execute("error")
+    assert tester.io.fetch_error().strip() == "No source found with name(s): error"
+    assert tester.status_code == 1
diff --git b/tests/console/commands/test_about.py a/tests/console/commands/test_about.py
new file mode 100644
index 0000000..6a59b04
--- /dev/null
+++ a/tests/console/commands/test_about.py
@@ -0,0 +1,16 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("about")
diff --git b/tests/console/commands/test_add.py a/tests/console/commands/test_add.py
new file mode 100644
index 0000000..745c574
--- /dev/null
+++ a/tests/console/commands/test_add.py
@@ -0,0 +1,1994 @@
+from __future__ import annotations
+
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import cast
+
+import pytest
+import tomlkit
+
+from packaging.utils import canonicalize_name
+from poetry.core.constraints.version import Version
+from poetry.core.packages.package import Package
+
+from poetry.console.commands.installer_command import InstallerCommand
+from poetry.puzzle.exceptions import SolverProblemError
+from poetry.repositories.legacy_repository import LegacyRepository
+from poetry.utils.dependency_specification import RequirementsParser
+from tests.helpers import TestLocker
+from tests.helpers import get_dependency
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from typing import Any
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+    from tomlkit import TOMLDocument
+
+    from poetry.config.config import Config
+    from poetry.poetry import Poetry
+    from poetry.utils.env import MockEnv
+    from poetry.utils.env import VirtualEnv
+    from tests.helpers import PoetryTestApplication
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture(autouse=True)
+def config(config: Config) -> Config:
+    # Disable parallel installs to get reproducible output.
+    config.merge({"installer": {"parallel": False}})
+    return config
+
+
+@pytest.fixture
+def poetry_with_up_to_date_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    source = fixture_dir("up_to_date_lock")
+
+    return project_factory(
+        name="foobar",
+        pyproject_content=(source / "pyproject.toml").read_text(encoding="utf-8"),
+        poetry_lock_content=(source / "poetry.lock").read_text(encoding="utf-8"),
+    )
+
+
+@pytest.fixture
+def poetry_with_path_dependency(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    source = fixture_dir("with_path_dependency")
+
+    poetry = project_factory(
+        name="foobar",
+        source=source,
+        use_test_locker=False,
+    )
+    return poetry
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("add")
+
+
+@pytest.fixture(autouse=True)
+def repo_add_default_packages(repo: TestRepository) -> None:
+    msgpack_optional_dep = get_dependency("msgpack-python", ">=0.5 <0.6", optional=True)
+    msgpack_dep = get_dependency("msgpack-python", ">=0.5 <0.6")
+    msgpack = get_package("msgpack-python", "0.5.6")
+    repo.add_package(msgpack)
+
+    redis_dep = get_dependency("redis", ">=3.3.6 <4.0.0", optional=True)
+    redis = get_package("redis", "3.4.0")
+    repo.add_package(redis)
+
+    cachy010 = get_package("cachy", "0.1.0")
+    cachy010.extras = {canonicalize_name("msgpack"): [msgpack_dep]}
+    cachy010.add_dependency(msgpack_optional_dep)
+    repo.add_package(cachy010)
+
+    cachy020 = get_package("cachy", "0.2.0")
+    cachy020.extras = {canonicalize_name("msgpack"): [get_dependency("msgpack-python")]}
+    cachy020.add_dependency(msgpack_dep)
+    repo.add_package(cachy020)
+
+    cleo065 = get_package("cleo", "0.6.5")
+    cleo065.add_dependency(msgpack_optional_dep)
+    cleo065.add_dependency(redis_dep)
+    cleo065.extras = {
+        canonicalize_name("redis"): [redis_dep],
+        canonicalize_name("msgpack"): [msgpack_dep],
+    }
+    repo.add_package(cleo065)
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("tomlkit", "0.5.5"))
+    repo.add_package(get_package("pyyaml", "3.13"))
+    repo.add_package(get_package("pyyaml", "4.2b2"))
+    repo.add_package(get_package("torch", "2.4.0+cpu"))
+
+
+def test_add_no_constraint(app: PoetryTestApplication, tester: CommandTester) -> None:
+    tester.execute("cachy")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == "^0.2.0"
+
+
+def test_add_local_version(app: PoetryTestApplication, tester: CommandTester) -> None:
+    tester.execute("torch")
+
+    expected = """\
+Using version ^2.4.0 for torch
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing torch (2.4.0+cpu)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "torch" in content["dependencies"]
+    assert content["dependencies"]["torch"] == "^2.4.0"
+
+
+def test_add_non_package_mode_no_name(
+    project_factory: ProjectFactory,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    poetry = project_factory(
+        name="foobar", pyproject_content="[tool.poetry]\npackage-mode = false\n"
+    )
+    tester = command_tester_factory("add", poetry=poetry)
+    tester.execute("cachy")
+
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == "^0.2.0"
+
+
+def test_add_replace_by_constraint(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    tester.execute("cachy")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == "^0.2.0"
+
+    tester.execute("cachy@0.1.0")
+    expected = """
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing cachy (0.1.0)
+
+Writing lock file
+"""
+    assert tester.io.fetch_output() == expected
+
+    pyproject2: dict[str, Any] = app.poetry.file.read()
+    content = pyproject2["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == "0.1.0"
+
+
+def test_add_no_constraint_editable_error(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    tester.execute("-e cachy")
+
+    expected = """
+Failed to add packages. Only vcs/path dependencies support editable installs.\
+ cachy is neither.
+
+No changes were applied.
+"""
+    assert tester.status_code == 1
+    assert tester.io.fetch_error() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 0
+
+    pyproject2: dict[str, Any] = app.poetry.file.read()
+    assert content == pyproject2["tool"]["poetry"]
+
+
+def test_add_equal_constraint(tester: CommandTester) -> None:
+    tester.execute("cachy==0.1.0")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing cachy (0.1.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+
+def test_add_greater_constraint(tester: CommandTester) -> None:
+    tester.execute("cachy>=0.1.0")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+
+@pytest.mark.parametrize("extra_name", ["msgpack", "MsgPack"])
+def test_add_constraint_with_extras(
+    tester: CommandTester,
+    extra_name: str,
+) -> None:
+    tester.execute(f"cachy[{extra_name}]>=0.1.0,<0.2.0")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.1.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+
+def test_add_constraint_dependencies(tester: CommandTester) -> None:
+    tester.execute("cachy=0.2.0")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+
+def test_add_with_markers(app: PoetryTestApplication, tester: CommandTester) -> None:
+    marker = "python_version <= '3.4' or sys_platform == 'win32'"
+    tester.execute(f"""cachy --markers "{marker}" """)
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"]["version"] == "^0.2.0"
+    assert content["dependencies"]["cachy"]["markers"] == marker
+
+
+def test_add_git_constraint(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    tmp_venv: VirtualEnv,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    tester.command.set_env(tmp_venv)
+
+    tester.execute("git+https://github.com/demo/demo.git")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {
+        "git": "https://github.com/demo/demo.git"
+    }
+
+
+def test_add_git_constraint_with_poetry(
+    tester: CommandTester,
+    tmp_venv: VirtualEnv,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    tester.command.set_env(tmp_venv)
+
+    tester.execute("git+https://github.com/demo/pyproject-demo.git")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert tester.command.installer.executor.installations_count == 2
+
+
+@pytest.mark.parametrize("extra_name", ["foo", "FOO"])
+def test_add_git_constraint_with_extras(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    tmp_venv: VirtualEnv,
+    extra_name: str,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    tester.command.set_env(tmp_venv)
+
+    tester.execute(f"git+https://github.com/demo/demo.git[{extra_name},bar]")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 4 installs, 0 updates, 0 removals
+
+  - Installing cleo (0.6.5)
+  - Installing pendulum (1.4.4)
+  - Installing tomlkit (0.5.5)
+  - Installing demo (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output().strip() == expected.strip()
+    assert tester.command.installer.executor.installations_count == 4
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {
+        "git": "https://github.com/demo/demo.git",
+        "extras": [extra_name, "bar"],
+    }
+
+
+@pytest.mark.parametrize(
+    "url, rev",
+    [
+        ("git+https://github.com/demo/subdirectories.git#subdirectory=two", None),
+        (
+            "git+https://github.com/demo/subdirectories.git@master#subdirectory=two",
+            "master",
+        ),
+    ],
+)
+def test_add_git_constraint_with_subdirectory(
+    url: str,
+    rev: str | None,
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    tester.execute(url)
+
+    expected = """\
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing two (2.0.0 9cf87a2)
+
+Writing lock file
+"""
+    assert tester.io.fetch_output().strip() == expected.strip()
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    constraint = {
+        "git": "https://github.com/demo/subdirectories.git",
+        "subdirectory": "two",
+    }
+
+    if rev:
+        constraint["rev"] = rev
+
+    assert "two" in content["dependencies"]
+    assert content["dependencies"]["two"] == constraint
+
+
+@pytest.mark.parametrize("editable", [False, True])
+def test_add_git_ssh_constraint(
+    editable: bool,
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    tmp_venv: VirtualEnv,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    tester.command.set_env(tmp_venv)
+
+    url = "git+ssh://git@github.com/demo/demo.git@develop"
+    tester.execute(f"{url}" if not editable else f"-e {url}")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 9cf87a2)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+
+    expected_content: dict[str, Any] = {
+        "git": "ssh://git@github.com/demo/demo.git",
+        "rev": "develop",
+    }
+    if editable:
+        expected_content["develop"] = True
+
+    assert content["dependencies"]["demo"] == expected_content
+
+
+@pytest.mark.parametrize(
+    "required_fixtures",
+    [["git/github.com/demo/demo"]],
+)
+@pytest.mark.parametrize("editable", [False, True])
+def test_add_directory_constraint(
+    editable: bool,
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    path = "../git/github.com/demo/demo"
+    tester.execute(f"{path}" if not editable else f"-e {path}")
+
+    demo_path = app.poetry.file.path.parent.joinpath(path).resolve().as_posix()
+    expected = f"""\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 {demo_path})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+
+    expected_content: dict[str, Any] = {"path": path}
+    if editable:
+        expected_content["develop"] = True
+
+    assert content["dependencies"]["demo"] == expected_content
+
+
+def test_add_to_new_group_keeps_existing_group(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    groups_content: dict[str, Any] = tomlkit.parse(
+        """\
+[dependency-groups]
+example = [
+    "cachy (>=0.2.0,<0.3.0)",
+]
+"""
+    )
+    pyproject["dependency-groups"] = groups_content["dependency-groups"]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    tester.execute("-G foo pendulum")
+
+    expected = """\
+Using version ^1.4.4 for pendulum
+"""
+
+    assert tester.io.fetch_output().startswith(expected)
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    assert "example" in pyproject["dependency-groups"]
+    assert pyproject["dependency-groups"]["example"] == [
+        "cachy (>=0.2.0,<0.3.0)",
+    ]
+    assert pyproject["dependency-groups"]["foo"] == [
+        "pendulum (>=1.4.4,<2.0.0)",
+    ]
+
+
+@pytest.mark.parametrize("additional_poetry_group", [False, True])
+def test_add_to_existing_group(
+    app: PoetryTestApplication, tester: CommandTester, additional_poetry_group: bool
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    groups_content: dict[str, Any] = tomlkit.parse(
+        """\
+[dependency-groups]
+example = [
+    "cachy (>=0.2.0,<0.3.0)",
+]
+"""
+    )
+    pyproject["dependency-groups"] = groups_content["dependency-groups"]
+    if additional_poetry_group:
+        poetry_groups_content: dict[str, Any] = tomlkit.parse(
+            """\
+[tool.poetry.group.example.dependencies]
+cachy = { allow-prereleases = true }
+"""
+        )
+        pyproject["tool"]["poetry"]["group"] = poetry_groups_content["tool"]["poetry"][
+            "group"
+        ]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    tester.execute("-G example pendulum")
+
+    expected = """\
+Using version ^1.4.4 for pendulum
+"""
+
+    assert tester.io.fetch_output().startswith(expected)
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    assert "example" in pyproject["dependency-groups"]
+    assert pyproject["dependency-groups"]["example"] == [
+        "cachy (>=0.2.0,<0.3.0)",
+        "pendulum (>=1.4.4,<2.0.0)",
+    ]
+    if additional_poetry_group:
+        assert "example" in pyproject["tool"]["poetry"]["group"]
+        assert pyproject["tool"]["poetry"]["group"]["example"]["dependencies"] == {
+            "cachy": {"allow-prereleases": True},
+        }
+    else:
+        assert "group" not in pyproject["tool"]["poetry"]
+
+
+def test_add_to_group_with_latest_overwrite_existing(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    groups_content: dict[str, Any] = tomlkit.parse(
+        """\
+[dependency-groups]
+example = [
+    "cachy (>=0.1.0,<0.2.0)",
+    "pendulum (>=1.4.4,<2.0.0)",
+]
+"""
+    )
+    pyproject["dependency-groups"] = groups_content["dependency-groups"]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    tester.execute("-G example cachy@latest")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+"""
+
+    assert tester.io.fetch_output().startswith(expected)
+    assert isinstance(tester.command, InstallerCommand)
+    # `cachy` has `msgpack-python` as dependency. So installation count increases by 1.
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    assert "example" in pyproject["dependency-groups"]
+    assert pyproject["dependency-groups"]["example"] == [
+        "cachy (>=0.2.0,<0.3.0)",
+        "pendulum (>=1.4.4,<2.0.0)",
+    ]
+
+
+def test_add_multiple_dependencies_to_dependency_group(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    tester.execute("-G example cachy pendulum")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+Using version ^1.4.4 for pendulum
+"""
+
+    assert tester.io.fetch_output().startswith(expected)
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    assert isinstance(tester.command, InstallerCommand)
+    # `cachy` has `msgpack-python` as dependency. So installation count increases by 1.
+    assert tester.command.installer.executor.installations_count == 3
+
+    assert "example" in pyproject["dependency-groups"]
+    assert pyproject["dependency-groups"]["example"] == [
+        "cachy (>=0.2.0,<0.3.0)",
+        "pendulum (>=1.4.4,<2.0.0)",
+    ]
+
+
+def test_add_to_group_uses_existing_legacy_group(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    groups_content: dict[str, Any] = tomlkit.parse(
+        """\
+[tool.poetry.group.example.dependencies]
+pendulum = "^1.4.4"
+"""
+    )
+    pyproject["tool"]["poetry"]["group"] = groups_content["tool"]["poetry"]["group"]
+
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    tester.execute("-G example cachy")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+"""
+
+    assert tester.io.fetch_output().startswith(expected)
+    assert isinstance(tester.command, InstallerCommand)
+    # `cachy` has `msgpack-python` as dependency. So installation count increases by 1.
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    assert "dependency-groups" not in pyproject
+    assert "example" in pyproject["tool"]["poetry"]["group"]
+    assert "pendulum" in pyproject["tool"]["poetry"]["group"]["example"]["dependencies"]
+    assert "cachy" in pyproject["tool"]["poetry"]["group"]["example"]["dependencies"]
+
+
+@pytest.mark.parametrize(
+    "required_fixtures",
+    [["git/github.com/demo/demo"]],
+)
+def test_add_group_directory_constraint_mix_pep735(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    path = "../git/github.com/demo/demo"
+    tester.execute(f"-G example -e {path}")
+
+    demo_path = app.poetry.file.path.parent.joinpath(path).resolve().as_posix()
+    expected = f"""\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 {demo_path})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+
+    assert "demo @ file://" in pyproject["dependency-groups"]["example"][0]
+    assert demo_path in pyproject["dependency-groups"]["example"][0]
+    assert "demo" in pyproject["tool"]["poetry"]["group"]["example"]["dependencies"]
+    assert pyproject["tool"]["poetry"]["group"]["example"]["dependencies"]["demo"] == {
+        "develop": True
+    }
+
+
+@pytest.mark.parametrize(
+    "required_fixtures",
+    [["git/github.com/demo/pyproject-demo"]],
+)
+def test_add_directory_with_poetry(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    path = "../git/github.com/demo/pyproject-demo"
+    tester.execute(f"{path}")
+
+    demo_path = app.poetry.file.path.parent.joinpath(path).resolve().as_posix()
+    expected = f"""\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.2 {demo_path})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+
+@pytest.mark.parametrize(
+    "required_fixtures",
+    [["distributions/demo-0.1.0-py2.py3-none-any.whl"]],
+)
+def test_add_file_constraint_wheel(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    path = "../distributions/demo-0.1.0-py2.py3-none-any.whl"
+    tester.execute(f"{path}")
+
+    demo_path = app.poetry.file.path.parent.joinpath(path).resolve().as_posix()
+    expected = f"""\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.0 {demo_path})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {"path": path}
+
+
+@pytest.mark.parametrize(
+    "required_fixtures",
+    [["distributions/demo-0.1.0.tar.gz"]],
+)
+def test_add_file_constraint_sdist(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    path = "../distributions/demo-0.1.0.tar.gz"
+    tester.execute(f"{path}")
+
+    demo_path = app.poetry.file.path.parent.joinpath(path).resolve().as_posix()
+    expected = f"""\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo (0.1.0 {demo_path})
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {"path": path}
+
+
+@pytest.mark.parametrize("extra_name", ["msgpack", "MsgPack"])
+def test_add_constraint_with_extras_option(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    extra_name: str,
+) -> None:
+    tester.execute(f"cachy=0.2.0 --extras {extra_name}")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == {
+        "version": "0.2.0",
+        "extras": [extra_name],
+    }
+
+
+def test_add_url_constraint_wheel(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    p = mocker.patch("pathlib.Path.cwd")
+    p.return_value = Path(__file__) / ".."
+
+    tester.execute(
+        "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+    )
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing pendulum (1.4.4)
+  - Installing demo\
+ (0.1.0 https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {
+        "url": "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+    }
+
+
+@pytest.mark.parametrize("extra_name", ["foo", "FOO"])
+def test_add_url_constraint_wheel_with_extras(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    extra_name: str,
+) -> None:
+    tester.execute(
+        "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+        f"[{extra_name},bar]"
+    )
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 4 installs, 0 updates, 0 removals
+
+  - Installing cleo (0.6.5)
+  - Installing pendulum (1.4.4)
+  - Installing tomlkit (0.5.5)
+  - Installing demo\
+ (0.1.0 https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl)
+
+Writing lock file
+"""
+    # Order might be different, split into lines and compare the overall output.
+    expected_lines = set(expected.splitlines())
+    output = set(tester.io.fetch_output().splitlines())
+    assert output == expected_lines
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 4
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "demo" in content["dependencies"]
+    assert content["dependencies"]["demo"] == {
+        "url": (
+            "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+        ),
+        "extras": [extra_name, "bar"],
+    }
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+@pytest.mark.parametrize(
+    ("existing_extras", "expected_extras"),
+    [
+        (None, {"my-extra": ["cachy (==0.2.0)"]}),
+        (
+            {"other": ["tomlkit (<2)"]},
+            {"other": ["tomlkit (<2)"], "my-extra": ["cachy (==0.2.0)"]},
+        ),
+        (
+            {"my-extra": ["tomlkit (<2)"]},
+            {"my-extra": ["tomlkit (<2)", "cachy (==0.2.0)"]},
+        ),
+        (
+            {"my-extra": ["tomlkit (<2)", "cachy (==0.1.0)", "pendulum (>1)"]},
+            {"my-extra": ["tomlkit (<2)", "cachy (==0.2.0)", "pendulum (>1)"]},
+        ),
+    ],
+)
+def test_add_constraint_with_optional(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    project_dependencies: bool,
+    existing_extras: dict[str, list[str]] | None,
+    expected_extras: dict[str, list[str]],
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    if project_dependencies:
+        pyproject["project"]["dependencies"] = ["tomlkit (<1)"]
+        if existing_extras:
+            pyproject["project"]["optional-dependencies"] = existing_extras
+    else:
+        pyproject["tool"]["poetry"]["dependencies"]["tomlkit"] = "<1"
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+    app.reset_poetry()
+
+    tester.execute("cachy=0.2.0 --optional my-extra")
+
+    assert tester.io.fetch_output().endswith("Writing lock file\n")
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count > 0
+
+    # check pyproject content
+    pyproject2: dict[str, Any] = app.poetry.file.read()
+    project_content = pyproject2["project"]
+    poetry_content = pyproject2["tool"]["poetry"]
+
+    if project_dependencies:
+        assert "cachy" not in poetry_content["dependencies"]
+        assert "cachy" not in project_content["dependencies"]
+        assert "my-extra" in project_content["optional-dependencies"]
+        assert project_content["optional-dependencies"] == expected_extras
+        assert not tester.io.fetch_error()
+    else:
+        assert "dependencies" not in project_content
+        assert "optional-dependencies" not in project_content
+        assert "cachy" in poetry_content["dependencies"]
+        assert poetry_content["dependencies"]["cachy"] == {
+            "version": "0.2.0",
+            "optional": True,
+        }
+        assert (
+            "Optional dependencies will not be added to extras in legacy mode."
+            in tester.io.fetch_error()
+        )
+
+    # check lock content
+    if project_dependencies:
+        lock_data = app.poetry.locker.lock_data
+
+        extras = lock_data["extras"]
+        assert list(extras) == sorted(expected_extras)
+        assert extras["my-extra"] == sorted(
+            e.split(" ")[0] for e in expected_extras["my-extra"]
+        )
+
+        added_package: dict[str, Any] | None = None
+        for package in lock_data["package"]:
+            if package["name"] == "cachy":
+                added_package = package
+                break
+        assert added_package is not None
+        assert added_package.get("markers") == 'extra == "my-extra"'
+
+
+def test_add_constraint_with_optional_not_main_group(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("cachy=0.2.0 --group dev --optional my-extra")
+
+    assert str(e.value) == "You can only add optional dependencies to the main group"
+
+
+def test_add_constraint_with_python(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    tester.execute("cachy=0.2.0 --python >=2.7")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == {"version": "0.2.0", "python": ">=2.7"}
+
+
+def test_add_constraint_with_platform(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    env: MockEnv,
+) -> None:
+    platform = sys.platform
+    env._platform = platform
+
+    tester.execute(f"cachy=0.2.0 --platform {platform} -vvv")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == {
+        "version": "0.2.0",
+        "platform": platform,
+    }
+
+
+def test_add_constraint_with_source(
+    app: PoetryTestApplication,
+    poetry: Poetry,
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    repo = LegacyRepository(name="my-index", url="https://my-index.fake")
+    package = Package(
+        "cachy",
+        Version.parse("0.2.0"),
+        source_type="legacy",
+        source_reference=repo.name,
+        source_url=repo._url,
+        yanked=False,
+    )
+    mocker.patch.object(repo, "package", return_value=package)
+    mocker.patch.object(repo, "_find_packages", wraps=lambda _, name: [package])
+
+    poetry.pool.add_repository(repo)
+
+    tester.execute("cachy=0.2.0 --source my-index")
+
+    expected = """\
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cachy" in content["dependencies"]
+    assert content["dependencies"]["cachy"] == {
+        "version": "0.2.0",
+        "source": "my-index",
+    }
+
+
+def test_add_constraint_with_source_that_does_not_exist(tester: CommandTester) -> None:
+    with pytest.raises(IndexError) as e:
+        tester.execute("foo --source i-dont-exist")
+
+    assert str(e.value) == 'Repository "i-dont-exist" does not exist.'
+
+
+def test_add_constraint_not_found_with_source(
+    poetry: Poetry,
+    mocker: MockerFixture,
+    tester: CommandTester,
+) -> None:
+    repo = LegacyRepository(name="my-index", url="https://my-index.fake")
+    mocker.patch.object(repo, "find_packages", return_value=[])
+
+    poetry.pool.add_repository(repo)
+
+    pypi = poetry.pool.repositories[0]
+    pypi.add_package(get_package("cachy", "0.2.0"))
+
+    with pytest.raises(ValueError) as e:
+        tester.execute("cachy --source my-index")
+
+    assert str(e.value) == "Could not find a matching version of package cachy"
+
+
+@pytest.mark.parametrize("group_name", ["dev", "foo.BAR"])
+def test_add_to_section_that_does_not_exist_yet(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+    group_name: str,
+) -> None:
+    tester.execute(f"cachy --group {group_name}")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["dependency-groups"]
+
+    assert content[group_name][0] == "cachy (>=0.2.0,<0.3.0)"
+
+    escaped_group_name = f'"{group_name}"' if "." in group_name else group_name
+    expected = f"""\
+{escaped_group_name} = [
+    "cachy (>=0.2.0,<0.3.0)"
+]
+"""
+    string_content = content.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected = expected.replace("\n", "\r\n")
+
+    assert expected in string_content
+
+
+def test_add_creating_poetry_section_does_not_remove_existing_tools(
+    repo: TestRepository,
+    project_factory: ProjectFactory,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    repo.add_package(get_package("cachy", "0.2.0"))
+
+    poetry = project_factory(
+        name="foobar",
+        pyproject_content=(
+            '[project]\nname = "foobar"\nversion="0"\n[tool.foo]\nkey = "value"\n'
+        ),
+    )
+    tester = command_tester_factory("add", poetry=poetry)
+    tester.execute("--group dev cachy")
+
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = poetry.file.read()
+    content = pyproject["dependency-groups"]
+
+    assert content["dev"][0] == "cachy (>=0.2.0,<0.3.0)"
+    assert "foo" in pyproject["tool"]
+    assert pyproject["tool"]["foo"]["key"] == "value"
+
+
+def test_add_to_dev_group(app: PoetryTestApplication, tester: CommandTester) -> None:
+    tester.execute("cachy --dev")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing cachy (0.2.0)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_error() == ""
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 2
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["dependency-groups"]
+
+    assert content["dev"][0] == "cachy (>=0.2.0,<0.3.0)"
+
+
+def test_add_should_not_select_prereleases(
+    app: PoetryTestApplication, tester: CommandTester
+) -> None:
+    tester.execute("pyyaml")
+
+    expected = """\
+Using version ^3.13 for pyyaml
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing pyyaml (3.13)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert isinstance(tester.command, InstallerCommand)
+    assert tester.command.installer.executor.installations_count == 1
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "pyyaml" in content["dependencies"]
+    assert content["dependencies"]["pyyaml"] == "^3.13"
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+def test_add_should_skip_when_adding_existing_package_with_no_constraint(
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    tester: CommandTester,
+    project_dependencies: bool,
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    if project_dependencies:
+        pyproject["project"]["dependencies"] = ["foo>1"]
+    else:
+        pyproject["tool"]["poetry"]["dependencies"]["foo"] = "^1.0"
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    repo.add_package(get_package("foo", "1.1.2"))
+    tester.execute("foo")
+
+    expected = """\
+The following packages are already present in the pyproject.toml and will be skipped:
+
+  - foo
+
+If you want to update it to the latest compatible version,\
+ you can use `poetry update package`.
+If you prefer to upgrade it to the latest available version,\
+ you can use `poetry add package@latest`.
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+def test_add_should_skip_when_adding_canonicalized_existing_package_with_no_constraint(
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    tester: CommandTester,
+    project_dependencies: bool,
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    if project_dependencies:
+        pyproject["project"]["dependencies"] = ["foo-bar>1"]
+    else:
+        pyproject["tool"]["poetry"]["dependencies"]["foo-bar"] = "^1.0"
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    repo.add_package(get_package("foo-bar", "1.1.2"))
+    tester.execute("Foo_Bar")
+
+    expected = """\
+The following packages are already present in the pyproject.toml and will be skipped:
+
+  - Foo_Bar
+
+If you want to update it to the latest compatible version,\
+ you can use `poetry update package`.
+If you prefer to upgrade it to the latest available version,\
+ you can use `poetry add package@latest`.
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_add_should_fail_circular_dependency(
+    repo: TestRepository, tester: CommandTester
+) -> None:
+    repo.add_package(get_package("simple-project", "1.1.2"))
+    result = tester.execute("simple-project")
+
+    assert result == 1
+
+    expected = "Cannot add dependency on simple-project to project with the same name."
+    assert expected in tester.io.fetch_error()
+
+
+def test_add_latest_should_strip_out_invalid_pep508_path(
+    tester: CommandTester, repo: TestRepository, mocker: MockerFixture
+) -> None:
+    spy = mocker.spy(RequirementsParser, "parse")
+    repo.add_package(get_package("foo", "1.1.1"))
+    repo.add_package(get_package("foo", "1.1.2"))
+    tester.execute("foo@latest")
+
+    assert tester.status_code == 0
+    assert "Using version ^1.1.2 for foo" in tester.io.fetch_output()
+
+    assert spy.call_count == 1
+    assert spy.call_args_list[0].args[1] == "foo"
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+def test_add_latest_should_not_create_duplicate_keys(
+    project_factory: ProjectFactory,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    project_dependencies: bool,
+) -> None:
+    if project_dependencies:
+        pyproject_content = """\
+        [project]
+        name = "simple-project"
+        version = "1.2.3"
+        dependencies = [
+            "Foo >= 0.6,<0.7",
+        ]
+        """
+    else:
+        pyproject_content = """\
+        [tool.poetry]
+        name = "simple-project"
+        version = "1.2.3"
+
+        [tool.poetry.dependencies]
+        python = "^3.6"
+        Foo = "^0.6"
+        """
+
+    poetry = project_factory(name="simple-project", pyproject_content=pyproject_content)
+    pyproject: dict[str, Any] = poetry.file.read()
+
+    if project_dependencies:
+        assert "tool" not in pyproject
+        assert pyproject["project"]["dependencies"] == ["Foo >= 0.6,<0.7"]
+    else:
+        assert "project" not in pyproject
+        assert "Foo" in pyproject["tool"]["poetry"]["dependencies"]
+        assert pyproject["tool"]["poetry"]["dependencies"]["Foo"] == "^0.6"
+        assert "foo" not in pyproject["tool"]["poetry"]["dependencies"]
+
+    tester = command_tester_factory("add", poetry=poetry)
+    repo.add_package(get_package("foo", "1.1.2"))
+    tester.execute("foo@latest")
+
+    updated_pyproject: dict[str, Any] = poetry.file.read()
+    if project_dependencies:
+        assert "tool" not in updated_pyproject
+        assert updated_pyproject["project"]["dependencies"] == ["foo (>=1.1.2,<2.0.0)"]
+    else:
+        assert "project" not in updated_pyproject
+        assert "Foo" in updated_pyproject["tool"]["poetry"]["dependencies"]
+        assert updated_pyproject["tool"]["poetry"]["dependencies"]["Foo"] == "^1.1.2"
+        assert "foo" not in updated_pyproject["tool"]["poetry"]["dependencies"]
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+def test_add_should_work_when_adding_existing_package_with_latest_constraint(
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    tester: CommandTester,
+    project_dependencies: bool,
+) -> None:
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    if project_dependencies:
+        pyproject["project"]["dependencies"] = ["foo>1"]
+    else:
+        pyproject["tool"]["poetry"]["dependencies"]["foo"] = "^1.0"
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    repo.add_package(get_package("foo", "1.1.2"))
+
+    tester.execute("foo@latest")
+
+    expected = """\
+Using version ^1.1.2 for foo
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing foo (1.1.2)
+
+Writing lock file
+"""
+
+    assert expected in tester.io.fetch_output()
+
+    pyproject2: dict[str, Any] = app.poetry.file.read()
+    project_content = pyproject2["project"]
+    poetry_content = pyproject2["tool"]["poetry"]
+
+    if project_dependencies:
+        assert "foo" not in poetry_content["dependencies"]
+        assert project_content["dependencies"] == ["foo (>=1.1.2,<2.0.0)"]
+    else:
+        assert "dependencies" not in project_content
+        assert "foo" in poetry_content["dependencies"]
+        assert poetry_content["dependencies"]["foo"] == "^1.1.2"
+
+
+def test_add_chooses_prerelease_if_only_prereleases_are_available(
+    repo: TestRepository, tester: CommandTester
+) -> None:
+    repo.add_package(get_package("foo", "1.2.3b0"))
+    repo.add_package(get_package("foo", "1.2.3b1"))
+
+    tester.execute("foo")
+
+    expected = """\
+Using version ^1.2.3b1 for foo
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing foo (1.2.3b1)
+
+Writing lock file
+"""
+    assert expected in tester.io.fetch_output()
+
+
+def test_add_prefers_stable_releases(
+    repo: TestRepository, tester: CommandTester
+) -> None:
+    repo.add_package(get_package("foo", "1.2.3"))
+    repo.add_package(get_package("foo", "1.2.4b1"))
+
+    tester.execute("foo")
+
+    expected = """\
+Using version ^1.2.3 for foo
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing foo (1.2.3)
+
+Writing lock file
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_add_with_lock(app: PoetryTestApplication, tester: CommandTester) -> None:
+    content_hash = app.poetry.locker._get_content_hash()
+
+    tester.execute("cachy --lock")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+    assert content_hash != app.poetry.locker.lock_data["metadata"]["content-hash"]
+
+
+def test_add_keyboard_interrupt_restore_content(
+    poetry_with_up_to_date_lockfile: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    mocker: MockerFixture,
+) -> None:
+    tester = command_tester_factory("add", poetry=poetry_with_up_to_date_lockfile)
+
+    mocker.patch(
+        "poetry.installation.installer.Installer._execute",
+        side_effect=KeyboardInterrupt(),
+    )
+    original_pyproject_content = poetry_with_up_to_date_lockfile.file.read()
+    original_lockfile_content = poetry_with_up_to_date_lockfile._locker.lock_data
+
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    tester.execute("cachy")
+
+    assert poetry_with_up_to_date_lockfile.file.read() == original_pyproject_content
+    assert (
+        poetry_with_up_to_date_lockfile._locker.lock_data == original_lockfile_content
+    )
+
+
+@pytest.mark.parametrize(
+    "command",
+    [
+        "cachy --dry-run",
+        "cachy --lock --dry-run",
+    ],
+)
+def test_add_with_dry_run_keep_files_intact(
+    command: str,
+    poetry_with_up_to_date_lockfile: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    tester = command_tester_factory("add", poetry=poetry_with_up_to_date_lockfile)
+
+    original_pyproject_content = poetry_with_up_to_date_lockfile.file.read()
+    original_lockfile_content = poetry_with_up_to_date_lockfile._locker.lock_data
+
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    tester.execute(command)
+
+    assert poetry_with_up_to_date_lockfile.file.read() == original_pyproject_content
+    assert (
+        poetry_with_up_to_date_lockfile._locker.lock_data == original_lockfile_content
+    )
+
+
+def test_add_should_not_change_lock_file_when_dependency_installation_fail(
+    poetry_with_up_to_date_lockfile: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    mocker: MockerFixture,
+) -> None:
+    tester = command_tester_factory("add", poetry=poetry_with_up_to_date_lockfile)
+
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    original_pyproject_content = poetry_with_up_to_date_lockfile.file.read()
+    original_lockfile_content = poetry_with_up_to_date_lockfile.locker.lock_data
+
+    def error(_: Any) -> int:
+        tester.io.write("\n  BuildError\n\n")
+        return 1
+
+    mocker.patch("poetry.installation.installer.Installer._execute", side_effect=error)
+    tester.execute("cachy")
+
+    expected = """\
+Using version ^0.2.0 for cachy
+
+Updating dependencies
+Resolving dependencies...
+
+  BuildError
+
+"""
+
+    assert poetry_with_up_to_date_lockfile.file.read() == original_pyproject_content
+    assert poetry_with_up_to_date_lockfile.locker.lock_data == original_lockfile_content
+    assert tester.io.fetch_output() == expected
+
+
+def test_add_with_path_dependency_no_loopiness(
+    poetry_with_path_dependency: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    """https://github.com/python-poetry/poetry/issues/7398"""
+    tester = command_tester_factory("add", poetry=poetry_with_path_dependency)
+
+    requests_old = get_package("requests", "2.25.1")
+    requests_new = get_package("requests", "2.28.2")
+
+    repo.add_package(requests_old)
+    repo.add_package(requests_new)
+
+    with pytest.raises(SolverProblemError):
+        tester.execute("requests")
+
+
+def test_add_extras_are_parsed_and_included(
+    app: PoetryTestApplication,
+    tester: CommandTester,
+) -> None:
+    tester.execute('cleo --extras "redis msgpack"')
+
+    expected = """\
+Using version ^0.6.5 for cleo
+
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 3 installs, 0 updates, 0 removals
+
+  - Installing msgpack-python (0.5.6)
+  - Installing redis (3.4.0)
+  - Installing cleo (0.6.5)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    content = pyproject["tool"]["poetry"]
+
+    assert "cleo" in content["dependencies"]
+    assert content["dependencies"]["cleo"] == {
+        "version": "^0.6.5",
+        "extras": ["redis", "msgpack"],
+    }
+
+
+@pytest.mark.parametrize(
+    "command",
+    [
+        "requests --extras security socks",
+    ],
+)
+def test_add_extras_only_accepts_one_package(
+    command: str, tester: CommandTester, repo: TestRepository
+) -> None:
+    """
+    You cannot pass in multiple package values to a single --extras flag.\
+    e.g. --extras security socks is not allowed.
+    """
+    repo.add_package(get_package("requests", "2.30.0"))
+
+    with pytest.raises(ValueError) as e:
+        tester.execute(command)
+        assert (
+            str(e.value)
+            == "You can only specify one package when using the --extras option"
+        )
+
+
+@pytest.mark.parametrize("command", ["foo", "foo --lock"])
+@pytest.mark.parametrize(
+    ("locked", "expected_docker"), [(True, "4.3.1"), (False, "4.3.2")]
+)
+def test_add_does_not_update_locked_dependencies(
+    repo: TestRepository,
+    poetry_with_up_to_date_lockfile: Poetry,
+    tester: CommandTester,
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    locked: bool,
+    expected_docker: str,
+) -> None:
+    assert isinstance(poetry_with_up_to_date_lockfile.locker, TestLocker)
+    poetry_with_up_to_date_lockfile.locker.locked(locked)
+    tester = command_tester_factory("add", poetry=poetry_with_up_to_date_lockfile)
+    docker_locked = get_package("docker", "4.3.1")
+    docker_new = get_package("docker", "4.3.2")
+    docker_dep = get_dependency("docker", ">=4.0.0")
+    foo = get_package("foo", "0.1.0")
+    foo.add_dependency(docker_dep)
+    for package in docker_locked, docker_new, foo:
+        repo.add_package(package)
+
+    tester.execute(command)
+
+    lock_data = poetry_with_up_to_date_lockfile.locker.lock_data
+    docker_locked_after_command = next(
+        p for p in lock_data["package"] if p["name"] == "docker"
+    )
+    assert docker_locked_after_command["version"] == expected_docker
+
+
+def test_add_creates_dependencies_array_if_necessary(
+    project_factory: ProjectFactory,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    pyproject_content = """\
+    [project]
+    name = "simple-project"
+    version = "1.2.3"
+
+    [project.optional-dependencies]
+    test = ["foo"]
+    """
+
+    poetry = project_factory(name="simple-project", pyproject_content=pyproject_content)
+
+    repo.add_package(get_package("foo", "2.0"))
+    repo.add_package(get_package("bar", "2.0"))
+
+    tester = command_tester_factory("add", poetry=poetry)
+    tester.execute("bar>=1.0")
+
+    updated_pyproject: dict[str, Any] = poetry.file.read()
+    assert updated_pyproject["project"]["dependencies"] == ["bar (>=1.0)"]
+
+
+@pytest.mark.parametrize("has_poetry_section", [True, False])
+def test_add_does_not_add_poetry_dependencies_if_not_necessary(
+    project_factory: ProjectFactory,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    has_poetry_section: bool,
+) -> None:
+    pyproject_content = """\
+    [project]
+    name = "simple-project"
+    version = "1.2.3"
+    dependencies = [
+        "foo >= 1.0",
+    ]
+    """
+    if has_poetry_section:
+        pyproject_content += """\
+    [tool.poetry]
+    packages = [ { include = "simple" } ]
+    """
+
+    poetry = project_factory(name="simple-project", pyproject_content=pyproject_content)
+    pyproject: dict[str, Any] = poetry.file.read()
+
+    if has_poetry_section:
+        assert "dependencies" not in pyproject["tool"]["poetry"]
+    else:
+        assert "tool" not in pyproject
+
+    repo.add_package(get_package("foo", "2.0"))
+    repo.add_package(get_package("bar", "2.0"))
+
+    tester = command_tester_factory("add", poetry=poetry)
+    tester.execute("bar>=1.0 --platform linux")
+
+    updated_pyproject: dict[str, Any] = poetry.file.read()
+    if has_poetry_section:
+        assert "dependencies" not in pyproject["tool"]["poetry"]
+    else:
+        assert "tool" not in pyproject
+    assert updated_pyproject["project"]["dependencies"] == [
+        "foo >= 1.0",
+        'bar (>=1.0) ; sys_platform == "linux"',
+    ]
+
+
+@pytest.mark.parametrize("has_poetry_section", [True, False])
+def test_add_poetry_dependencies_if_necessary(
+    project_factory: ProjectFactory,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    mocker: MockerFixture,
+    has_poetry_section: bool,
+) -> None:
+    pyproject_content = """\
+    [project]
+    name = "simple-project"
+    version = "1.2.3"
+    dependencies = [
+        "foo >= 1.0",
+    ]
+    """
+    if has_poetry_section:
+        pyproject_content += """\
+    [tool.poetry]
+    packages = [ { include = "simple" } ]
+    """
+
+    poetry = project_factory(name="simple-project", pyproject_content=pyproject_content)
+    pyproject: dict[str, Any] = poetry.file.read()
+
+    if has_poetry_section:
+        assert "dependencies" not in pyproject["tool"]["poetry"]
+    else:
+        assert "tool" not in pyproject
+
+    repo.add_package(get_package("foo", "2.0"))
+    other_repo = LegacyRepository(name="my-index", url="https://my-index.fake")
+    poetry.pool.add_repository(other_repo)
+    package = Package(
+        "bar",
+        "2.0",
+        source_type="legacy",
+        source_url=other_repo.url,
+        source_reference=other_repo.name,
+    )
+    mocker.patch.object(other_repo, "package", return_value=package)
+    mocker.patch.object(other_repo, "_find_packages", wraps=lambda _, name: [package])
+    repo.add_package(package)
+
+    tester = command_tester_factory("add", poetry=poetry)
+    tester.execute("bar>=1.0 --platform linux --allow-prereleases --source my-index")
+
+    updated_pyproject: dict[str, Any] = poetry.file.read()
+    if has_poetry_section:
+        assert "dependencies" not in pyproject["tool"]["poetry"]
+    else:
+        assert "tool" not in pyproject
+    assert updated_pyproject["project"]["dependencies"] == [
+        "foo >= 1.0",
+        'bar (>=1.0) ; sys_platform == "linux"',
+    ]
+    assert updated_pyproject["tool"]["poetry"]["dependencies"] == {
+        "bar": {
+            "platform": "linux",
+            "source": "my-index",
+            "allow-prereleases": True,
+        }
+    }
diff --git b/tests/console/commands/test_build.py a/tests/console/commands/test_build.py
new file mode 100644
index 0000000..babba74
--- /dev/null
+++ a/tests/console/commands/test_build.py
@@ -0,0 +1,304 @@
+from __future__ import annotations
+
+import shutil
+import tarfile
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.io.null_io import NullIO
+from cleo.testers.application_tester import ApplicationTester
+
+from poetry.console.application import Application
+from poetry.console.commands.build import BuildCommand
+from poetry.console.commands.build import BuildHandler
+from poetry.console.commands.build import BuildOptions
+from poetry.factory import Factory
+from poetry.utils.helpers import remove_directory
+from tests.helpers import with_working_directory
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from poetry.utils.env import VirtualEnv
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+
+
+@pytest.fixture
+def tmp_project_path(tmp_path: Path) -> Path:
+    return tmp_path / "project"
+
+
+@pytest.fixture
+def tmp_poetry(tmp_project_path: Path, fixture_dir: FixtureDirGetter) -> Poetry:
+    # copy project so that we start with a clean directory
+    shutil.copytree(fixture_dir("simple_project"), tmp_project_path)
+    poetry = Factory().create_poetry(tmp_project_path)
+    return poetry
+
+
+@pytest.fixture
+def tmp_tester(
+    tmp_poetry: Poetry, command_tester_factory: CommandTesterFactory
+) -> CommandTester:
+    return command_tester_factory("build", tmp_poetry)
+
+
+def get_package_glob(poetry: Poetry, local_version: str | None = None) -> str:
+    version = poetry.package.version
+
+    if local_version:
+        version = version.replace(local=local_version)
+
+    return f"{poetry.package.name.replace('-', '_')}-{version}*"
+
+
+def test_build_format_is_not_valid(tmp_tester: CommandTester) -> None:
+    with pytest.raises(ValueError, match=r"Invalid format.*"):
+        tmp_tester.execute("--format not_valid")
+
+
+@pytest.mark.parametrize("format", ["sdist", "wheel", "all"])
+def test_build_creates_packages_in_dist_directory_if_no_output_is_specified(
+    tmp_tester: CommandTester, tmp_project_path: Path, tmp_poetry: Poetry, format: str
+) -> None:
+    shutil.rmtree(tmp_project_path / "dist")
+    tmp_tester.execute(f"--format {format}")
+    build_artifacts = tuple(
+        (tmp_project_path / "dist").glob(get_package_glob(tmp_poetry))
+    )
+    assert len(build_artifacts) > 0
+    assert all(archive.exists() for archive in build_artifacts)
+
+
+def test_build_with_local_version_label(
+    tmp_tester: CommandTester, tmp_project_path: Path, tmp_poetry: Poetry
+) -> None:
+    shutil.rmtree(tmp_project_path / "dist")
+    local_version_label = "local-version"
+    tmp_tester.execute(f"--local-version {local_version_label}")
+    build_artifacts = tuple(
+        (tmp_project_path / "dist").glob(
+            get_package_glob(tmp_poetry, local_version=local_version_label)
+        )
+    )
+
+    assert len(build_artifacts) > 0
+    assert all(archive.exists() for archive in build_artifacts)
+
+
+@pytest.mark.parametrize("clean", [True, False])
+def test_build_with_clean(
+    tmp_tester: CommandTester, tmp_project_path: Path, tmp_poetry: Poetry, clean: bool
+) -> None:
+    dist_dir = tmp_project_path.joinpath("dist")
+    dist_dir.joinpath("hello").touch(exist_ok=True)
+
+    tmp_tester.execute("--clean" if clean else "")
+    build_artifacts = tuple(dist_dir.glob("*"))
+
+    assert len(build_artifacts) == 2 if clean else 3
+    assert all(archive.exists() for archive in build_artifacts)
+
+
+def test_build_with_clean_non_existing_output(
+    tmp_tester: CommandTester, tmp_project_path: Path, tmp_poetry: Poetry
+) -> None:
+    dist_dir = tmp_project_path.joinpath("dist")
+
+    remove_directory(dist_dir, force=True)
+    assert not dist_dir.exists()
+
+    tmp_tester.execute("--clean")
+    build_artifacts = tuple(dist_dir.glob("*"))
+
+    assert len(build_artifacts) == 2
+    assert all(archive.exists() for archive in build_artifacts)
+
+
+def test_build_not_possible_in_non_package_mode(
+    fixture_dir: FixtureDirGetter,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    source_dir = fixture_dir("non_package_mode")
+
+    poetry = Factory().create_poetry(source_dir)
+    tester = command_tester_factory("build", poetry)
+
+    assert tester.execute() == 1
+    assert (
+        tester.io.fetch_error()
+        == "Building a package is not possible in non-package mode.\n"
+    )
+
+
+def test_build_with_multiple_readme_files(
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    tmp_venv: VirtualEnv,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    source_dir = fixture_dir("with_multiple_readme_files")
+    target_dir = tmp_path / "project"
+    shutil.copytree(str(source_dir), str(target_dir))
+
+    poetry = Factory().create_poetry(target_dir)
+    tester = command_tester_factory("build", poetry, environment=tmp_venv)
+    tester.execute()
+
+    build_dir = target_dir / "dist"
+    assert build_dir.exists()
+
+    sdist_file = build_dir / "my_package-0.1.tar.gz"
+    assert sdist_file.exists()
+    assert sdist_file.stat().st_size > 0
+
+    (wheel_file,) = build_dir.glob("my_package-0.1-*.whl")
+    assert wheel_file.exists()
+    assert wheel_file.stat().st_size > 0
+
+    with tarfile.open(sdist_file) as tf:
+        sdist_content = tf.getnames()
+
+    assert "my_package-0.1/README-1.rst" in sdist_content
+    assert "my_package-0.1/README-2.rst" in sdist_content
+
+
+@pytest.mark.parametrize(
+    "output_dir", [None, "dist", "test/dir", "../dist", "absolute"]
+)
+def test_build_output_option(
+    tmp_tester: CommandTester,
+    tmp_project_path: Path,
+    tmp_poetry: Poetry,
+    output_dir: str,
+) -> None:
+    shutil.rmtree(tmp_project_path / "dist")
+    if output_dir is None:
+        tmp_tester.execute()
+        build_dir = tmp_project_path / "dist"
+    elif output_dir == "absolute":
+        tmp_tester.execute(f"--output {tmp_project_path / 'tmp/dist'}")
+        build_dir = tmp_project_path / "tmp/dist"
+    else:
+        tmp_tester.execute(f"--output {output_dir}")
+        build_dir = tmp_project_path / output_dir
+
+    build_artifacts = tuple(build_dir.glob(get_package_glob(tmp_poetry)))
+    assert len(build_artifacts) > 0
+    assert all(archive.exists() for archive in build_artifacts)
+
+
+def test_build_relative_directory_src_layout(
+    tmp_path: Path, fixture_dir: FixtureDirGetter
+) -> None:
+    tmp_project_path = tmp_path / "project"
+    with with_working_directory(fixture_dir("simple_project"), tmp_project_path):
+        shutil.rmtree(tmp_project_path / "dist")
+        (tmp_project_path / "src").mkdir()
+        (tmp_project_path / "simple_project").rename(
+            tmp_project_path / "src" / "simple_project"
+        )
+
+        # We have to use ApplicationTester because CommandTester
+        # initializes Poetry before passing the directory.
+        app = Application()
+        tester = ApplicationTester(app)
+        tester.execute("build --project .")
+
+        build_dir = tmp_project_path / "dist"
+
+        assert len(list(build_dir.iterdir())) == 2
+
+
+def test_build_options_validate_formats() -> None:
+    with pytest.raises(ValueError, match="Invalid format: UNKNOWN"):
+        _ = BuildOptions(clean=True, formats=["sdist", "UNKNOWN"], output="dist")  # type: ignore[list-item]
+
+
+def test_prepare_config_settings() -> None:
+    config_settings = BuildCommand._prepare_config_settings(
+        local_version="42",
+        config_settings=["setting_1=value_1", "setting_2=value_2"],
+        io=NullIO(),
+    )
+
+    assert config_settings == {
+        "local-version": "42",
+        "setting_1": "value_1",
+        "setting_2": "value_2",
+    }
+
+
+def test_prepare_config_settings_raise_on_invalid_setting() -> None:
+    with pytest.raises(ValueError, match="Invalid config setting format: value_2"):
+        _ = BuildCommand._prepare_config_settings(
+            local_version="42",
+            config_settings=["setting_1=value_1", "value_2"],
+            io=NullIO(),
+        )
+
+
+@pytest.mark.parametrize(
+    ["fmt", "expected_formats"],
+    [
+        ("all", ["sdist", "wheel"]),
+        (None, ["sdist", "wheel"]),
+        ("sdist", ["sdist"]),
+        ("wheel", ["wheel"]),
+    ],
+)
+def test_prepare_formats(fmt: str | None, expected_formats: list[str]) -> None:
+    formats = BuildCommand._prepare_formats(fmt)
+    assert formats == expected_formats
+
+
+@pytest.mark.parametrize(
+    ["project", "isolated_build"],
+    [
+        ("core_in_range", False),
+        ("core_not_in_range", True),
+        ("has_build_script", True),
+        ("multiple_build_deps", True),
+        ("no_core", True),
+        ("core_from_git", True),
+        ("no_build_system", False),
+        ("no_build_backend", False),
+    ],
+)
+def test_requires_isolated_build(
+    project: str,
+    isolated_build: bool,
+    fixture_dir: FixtureDirGetter,
+    mocker: MockerFixture,
+) -> None:
+    poetry = Factory().create_poetry(fixture_dir(f"build_systems/{project}"))
+    handler = BuildHandler(poetry=poetry, env=mocker.Mock(), io=NullIO())
+
+    assert handler._requires_isolated_build() is isolated_build
+
+
+def test_build_handler_build_isolated(
+    fixture_dir: FixtureDirGetter, mocker: MockerFixture
+) -> None:
+    from build import ProjectBuilder
+
+    poetry = Factory().create_poetry(fixture_dir("build_systems/has_build_script"))
+
+    mock_builder = mocker.MagicMock(spec=ProjectBuilder)
+    mock_isolated_builder = mocker.patch(
+        "poetry.console.commands.build.isolated_builder"
+    )
+    mock_isolated_builder.return_value.__enter__.return_value = mock_builder
+
+    handler = BuildHandler(poetry=poetry, env=mocker.Mock(), io=NullIO())
+    handler.build(BuildOptions(clean=True, formats=["wheel"], output="dist"))
+
+    assert mock_builder.build.call_count == 1
diff --git b/tests/console/commands/test_check.py a/tests/console/commands/test_check.py
new file mode 100644
index 0000000..1f16ecb
--- /dev/null
+++ a/tests/console/commands/test_check.py
@@ -0,0 +1,313 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.factory import Factory
+from poetry.packages import Locker
+from poetry.toml import TOMLFile
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import SetProjectContext
+
+
+@pytest.fixture
+def poetry_simple_project(set_project_context: SetProjectContext) -> Iterator[Poetry]:
+    with set_project_context("simple_project", in_place=False) as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+@pytest.fixture
+def poetry_with_outdated_lockfile(
+    set_project_context: SetProjectContext,
+) -> Iterator[Poetry]:
+    with set_project_context("outdated_lock", in_place=False) as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+@pytest.fixture
+def poetry_with_up_to_date_lockfile(
+    set_project_context: SetProjectContext,
+) -> Iterator[Poetry]:
+    with set_project_context("up_to_date_lock", in_place=False) as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+@pytest.fixture
+def poetry_with_pypi_reference(
+    set_project_context: SetProjectContext,
+) -> Iterator[Poetry]:
+    with set_project_context("pypi_reference", in_place=False) as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+@pytest.fixture
+def poetry_with_invalid_pyproject(
+    set_project_context: SetProjectContext,
+) -> Iterator[Poetry]:
+    with set_project_context("invalid_pyproject", in_place=False) as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+@pytest.fixture()
+def tester(
+    command_tester_factory: CommandTesterFactory, poetry_simple_project: Poetry
+) -> CommandTester:
+    return command_tester_factory("check", poetry=poetry_simple_project)
+
+
+def test_check_valid(tester: CommandTester) -> None:
+    tester.execute()
+
+    expected = """\
+All set!
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    ["args", "expected_status"],
+    [
+        ([], 0),
+        (["--strict"], 1),
+    ],
+)
+def test_check_valid_legacy(
+    args: list[str],
+    expected_status: int,
+    mocker: MockerFixture,
+    tester: CommandTester,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    mocker.patch(
+        "poetry.poetry.Poetry.file",
+        return_value=TOMLFile(fixture_dir("simple_project_legacy") / "pyproject.toml"),
+        new_callable=mocker.PropertyMock,
+    )
+    tester.execute(" ".join(args))
+
+    expected = (
+        "Warning: [tool.poetry.name] is deprecated. Use [project.name] instead.\n"
+        "Warning: [tool.poetry.version] is set but 'version' is not in "
+        "[project.dynamic]. If it is static use [project.version]. If it is dynamic, "
+        "add 'version' to [project.dynamic].\n"
+        "If you want to set the version dynamically via `poetry build "
+        "--local-version` or you are using a plugin, which sets the version "
+        "dynamically, you should define the version in [tool.poetry] and add "
+        "'version' to [project.dynamic].\n"
+        "Warning: [tool.poetry.description] is deprecated. Use [project.description] "
+        "instead.\n"
+        "Warning: [tool.poetry.readme] is set but 'readme' is not in "
+        "[project.dynamic]. If it is static use [project.readme]. If it is dynamic, "
+        "add 'readme' to [project.dynamic].\n"
+        "If you want to define multiple readmes, you should define them in "
+        "[tool.poetry] and add 'readme' to [project.dynamic].\n"
+        "Warning: [tool.poetry.license] is deprecated. Use [project.license] instead.\n"
+        "Warning: [tool.poetry.authors] is deprecated. Use [project.authors] instead.\n"
+        "Warning: [tool.poetry.keywords] is deprecated. Use [project.keywords] "
+        "instead.\n"
+        "Warning: [tool.poetry.classifiers] is set but 'classifiers' is not in "
+        "[project.dynamic]. If it is static use [project.classifiers]. If it is "
+        "dynamic, add 'classifiers' to [project.dynamic].\n"
+        "ATTENTION: Per default Poetry determines classifiers for supported Python "
+        "versions and license automatically. If you define classifiers in [project], "
+        "you disable the automatic enrichment. In other words, you have to define all "
+        "classifiers manually. If you want to use Poetry's automatic enrichment of "
+        "classifiers, you should define them in [tool.poetry] and add 'classifiers' "
+        "to [project.dynamic].\n"
+        "Warning: [tool.poetry.homepage] is deprecated. Use [project.urls] instead.\n"
+        "Warning: [tool.poetry.repository] is deprecated. Use [project.urls] instead.\n"
+        "Warning: [tool.poetry.documentation] is deprecated. Use [project.urls] "
+        "instead.\n"
+        "Warning: Defining console scripts in [tool.poetry.scripts] is deprecated. "
+        "Use [project.scripts] instead. ([tool.poetry.scripts] should only be used "
+        "for scripts of type 'file').\n"
+    )
+
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == expected_status
+
+
+def test_check_invalid_dep_name_same_as_project_name(
+    mocker: MockerFixture, tester: CommandTester, fixture_dir: FixtureDirGetter
+) -> None:
+    mocker.patch(
+        "poetry.poetry.Poetry.file",
+        return_value=TOMLFile(
+            fixture_dir("invalid_pyproject_dep_name") / "pyproject.toml"
+        ),
+        new_callable=mocker.PropertyMock,
+    )
+    tester.execute("")
+
+    expected = """\
+Error: Project name (invalid) is same as one of its dependencies
+"""
+
+    assert tester.io.fetch_error() == expected
+
+
+def test_check_invalid(
+    tester: CommandTester,
+    fixture_dir: FixtureDirGetter,
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_invalid_pyproject: Poetry,
+) -> None:
+    tester = command_tester_factory("check", poetry=poetry_with_invalid_pyproject)
+    tester.execute("--lock")
+
+    expected = """\
+Error: Unrecognized classifiers: ['Intended Audience :: Clowns'].
+Error: Declared README file does not exist: never/exists.md
+Error: Invalid source "not-exists" referenced in dependencies.
+Error: Invalid source "not-exists2" referenced in dependencies.
+Error: poetry.lock was not found.
+Warning: [project.license] is not a valid SPDX expression.\
+ This is deprecated and will raise an error in the future.
+Warning: A wildcard Python dependency is ambiguous.\
+ Consider specifying a more explicit one.
+Warning: The "pendulum" dependency specifies the "allows-prereleases" property,\
+ which is deprecated. Use "allow-prereleases" instead.
+Warning: Deprecated classifier 'Natural Language :: Ukranian'.\
+ Must be replaced by ['Natural Language :: Ukrainian'].
+Warning: Deprecated classifier\
+ 'Topic :: Communications :: Chat :: AOL Instant Messenger'.\
+ Must be removed.
+"""
+
+    assert tester.io.fetch_error() == expected
+
+
+def test_check_private(
+    mocker: MockerFixture, tester: CommandTester, fixture_dir: FixtureDirGetter
+) -> None:
+    mocker.patch(
+        "poetry.poetry.Poetry.file",
+        return_value=TOMLFile(fixture_dir("private_pyproject") / "pyproject.toml"),
+        new_callable=mocker.PropertyMock,
+    )
+
+    tester.execute()
+
+    expected = """\
+All set!
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_check_non_package_mode(
+    mocker: MockerFixture, tester: CommandTester, fixture_dir: FixtureDirGetter
+) -> None:
+    mocker.patch(
+        "poetry.poetry.Poetry.file",
+        return_value=TOMLFile(fixture_dir("non_package_mode") / "pyproject.toml"),
+        new_callable=mocker.PropertyMock,
+    )
+
+    tester.execute()
+
+    expected = """\
+All set!
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    ("options", "expected", "expected_status"),
+    [
+        ("", "All set!\n", 0),
+        ("--lock", "Error: poetry.lock was not found.\n", 1),
+    ],
+)
+def test_check_lock_missing(
+    mocker: MockerFixture,
+    tester: CommandTester,
+    fixture_dir: FixtureDirGetter,
+    options: str,
+    expected: str,
+    expected_status: int,
+) -> None:
+    mocker.patch(
+        "poetry.poetry.Poetry.file",
+        return_value=TOMLFile(fixture_dir("private_pyproject") / "pyproject.toml"),
+        new_callable=mocker.PropertyMock,
+    )
+
+    status_code = tester.execute(options)
+
+    assert status_code == expected_status
+
+    if status_code == 0:
+        assert tester.io.fetch_output() == expected
+    else:
+        assert tester.io.fetch_error() == expected
+
+
+@pytest.mark.parametrize("options", ["", "--lock"])
+def test_check_lock_outdated(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_outdated_lockfile: Poetry,
+    options: str,
+) -> None:
+    locker = Locker(
+        lock=poetry_with_outdated_lockfile.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry_with_outdated_lockfile.locker._pyproject_data,
+    )
+    poetry_with_outdated_lockfile.set_locker(locker)
+
+    tester = command_tester_factory("check", poetry=poetry_with_outdated_lockfile)
+    status_code = tester.execute(options)
+    expected = (
+        "Error: pyproject.toml changed significantly since poetry.lock was last generated. "
+        "Run `poetry lock` to fix the lock file.\n"
+    )
+
+    assert tester.io.fetch_error() == expected
+
+    # exit with an error
+    assert status_code == 1
+
+
+@pytest.mark.parametrize("options", ["", "--lock"])
+def test_check_lock_up_to_date(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_up_to_date_lockfile: Poetry,
+    options: str,
+) -> None:
+    locker = Locker(
+        lock=poetry_with_up_to_date_lockfile.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry_with_up_to_date_lockfile.locker._pyproject_data,
+    )
+    poetry_with_up_to_date_lockfile.set_locker(locker)
+
+    tester = command_tester_factory("check", poetry=poetry_with_up_to_date_lockfile)
+    status_code = tester.execute(options)
+    expected = "All set!\n"
+    assert tester.io.fetch_output() == expected
+
+    # exit with an error
+    assert status_code == 0
+
+
+def test_check_does_not_error_on_pypi_reference(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_pypi_reference: Poetry,
+) -> None:
+    tester = command_tester_factory("check", poetry=poetry_with_pypi_reference)
+    status_code = tester.execute("")
+
+    assert tester.io.fetch_output() == "All set!\n"
+    assert status_code == 0
diff --git b/tests/console/commands/test_config.py a/tests/console/commands/test_config.py
new file mode 100644
index 0000000..d8ab82b
--- /dev/null
+++ a/tests/console/commands/test_config.py
@@ -0,0 +1,782 @@
+from __future__ import annotations
+
+import json
+import os
+import textwrap
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from deepdiff.diff import DeepDiff
+from poetry.core.pyproject.exceptions import PyProjectError
+
+from poetry.config.config_source import ConfigSource
+from poetry.config.config_source import PropertyNotFoundError
+from poetry.console.commands.install import InstallCommand
+from poetry.factory import Factory
+from poetry.repositories.legacy_repository import LegacyRepository
+from tests.conftest import Config
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.config.dict_config_source import DictConfigSource
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("config")
+
+
+def test_show_config_with_local_config_file_empty(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "poetry.factory.Factory.create_poetry",
+        side_effect=PyProjectError("[tool.poetry] section not found"),
+    )
+    tester.execute()
+
+    assert tester.io.fetch_output() == ""
+
+
+def test_list_displays_default_value_if_not_set(
+    tester: CommandTester, config_cache_dir: Path, config_data_dir: Path
+) -> None:
+    tester.execute("--list")
+
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = true
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_list_displays_set_get_setting(
+    tester: CommandTester, config: Config, config_cache_dir: Path, config_data_dir: Path
+) -> None:
+    tester.execute("virtualenvs.create false")
+
+    tester.execute("--list")
+
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = false
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+
+    assert config.set_config_source.call_count == 0  # type: ignore[attr-defined]
+    assert tester.io.fetch_output() == expected
+
+
+def test_cannot_set_with_multiple_values(tester: CommandTester) -> None:
+    with pytest.raises(RuntimeError) as e:
+        tester.execute("virtualenvs.create false true")
+
+    assert str(e.value) == "You can only pass one value."
+
+
+def test_cannot_set_invalid_value(tester: CommandTester) -> None:
+    with pytest.raises(RuntimeError) as e:
+        tester.execute("virtualenvs.create foo")
+
+    assert str(e.value) == '"foo" is an invalid value for virtualenvs.create'
+
+
+def test_cannot_unset_with_value(tester: CommandTester) -> None:
+    with pytest.raises(RuntimeError) as e:
+        tester.execute("virtualenvs.create false --unset")
+
+    assert str(e.value) == "You can not combine a setting value with --unset"
+
+
+def test_unset_setting(
+    tester: CommandTester, config: Config, config_cache_dir: Path, config_data_dir: Path
+) -> None:
+    tester.execute("virtualenvs.path /some/path")
+    tester.execute("virtualenvs.path --unset")
+    tester.execute("--list")
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = true
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+    assert config.set_config_source.call_count == 0  # type: ignore[attr-defined]
+    assert tester.io.fetch_output() == expected
+
+
+def test_unset_repo_setting(
+    tester: CommandTester, config: Config, config_cache_dir: Path, config_data_dir: Path
+) -> None:
+    tester.execute("repositories.foo.url https://bar.com/simple/")
+    tester.execute("repositories.foo.url --unset ")
+    tester.execute("--list")
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = true
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+    assert config.set_config_source.call_count == 0  # type: ignore[attr-defined]
+    assert tester.io.fetch_output() == expected
+
+
+def test_unset_value_not_exists(tester: CommandTester) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("foobar --unset")
+
+    assert str(e.value) == "Setting foobar does not exist"
+
+
+@pytest.mark.parametrize(
+    ("value", "expected"),
+    [
+        ("virtualenvs.create", "true\n"),
+        ("repositories.foo.url", "{'url': 'https://bar.com/simple/'}\n"),
+    ],
+)
+def test_display_single_setting(
+    tester: CommandTester, value: str, expected: str | bool
+) -> None:
+    tester.execute("repositories.foo.url https://bar.com/simple/")
+    tester.execute(value)
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_display_single_local_setting(
+    command_tester_factory: CommandTesterFactory, fixture_dir: FixtureDirGetter
+) -> None:
+    tester = command_tester_factory(
+        "config", poetry=Factory().create_poetry(fixture_dir("with_local_config"))
+    )
+    tester.execute("virtualenvs.create")
+
+    expected = """false
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_display_empty_repositories_setting(
+    command_tester_factory: CommandTesterFactory, fixture_dir: FixtureDirGetter
+) -> None:
+    tester = command_tester_factory(
+        "config",
+        poetry=Factory().create_poetry(fixture_dir("with_local_config")),
+    )
+    tester.execute("repositories")
+
+    expected = """{}
+"""
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    ("setting", "expected"),
+    [
+        ("repositories", "You cannot remove the [repositories] section"),
+        ("repositories.test", "There is no test repository defined"),
+    ],
+)
+def test_unset_nonempty_repositories_section(
+    tester: CommandTester, setting: str, expected: str
+) -> None:
+    tester.execute("repositories.foo.url https://bar.com/simple/")
+
+    with pytest.raises(ValueError) as e:
+        tester.execute(f"{setting} --unset")
+
+    assert str(e.value) == expected
+
+
+def test_set_malformed_repositories_setting(
+    tester: CommandTester,
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("repositories.foo bar baz")
+
+    assert (
+        str(e.value) == "You must pass the url. Example: poetry config repositories.foo"
+        " https://bar.com"
+    )
+
+
+@pytest.mark.parametrize(
+    ("setting", "expected"),
+    [
+        ("repositories.foo", "There is no foo repository defined"),
+        ("foo", "There is no foo setting."),
+    ],
+)
+def test_display_undefined_setting(
+    tester: CommandTester, setting: str, expected: str
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute(setting)
+
+    assert str(e.value) == expected
+
+
+def test_list_displays_set_get_local_setting(
+    tester: CommandTester,
+    config: Config,
+    config_cache_dir: Path,
+    config_data_dir: Path,
+) -> None:
+    tester.execute("virtualenvs.create false --local")
+
+    tester.execute("--list")
+
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = false
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+
+    assert config.set_config_source.call_count == 1  # type: ignore[attr-defined]
+    assert tester.io.fetch_output() == expected
+
+
+def test_list_must_not_display_sources_from_pyproject_toml(
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    command_tester_factory: CommandTesterFactory,
+    config_cache_dir: Path,
+    config_data_dir: Path,
+) -> None:
+    source = fixture_dir("with_primary_source_implicit")
+    pyproject_content = (source / "pyproject.toml").read_text(encoding="utf-8")
+    poetry = project_factory("foo", pyproject_content=pyproject_content)
+    tester = command_tester_factory("config", poetry=poetry)
+
+    tester.execute("--list")
+
+    cache_dir = json.dumps(str(config_cache_dir))
+    data_dir = json.dumps(str(config_data_dir))
+    venv_path = json.dumps(os.path.join("{cache-dir}", "virtualenvs"))
+    expected = f"""cache-dir = {cache_dir}
+data-dir = {data_dir}
+installer.max-workers = null
+installer.no-binary = null
+installer.only-binary = null
+installer.parallel = true
+installer.re-resolve = true
+keyring.enabled = true
+python.installation-dir = {json.dumps(str(Path("{data-dir}/python")))}  # {config_data_dir / "python"}
+repositories.foo.url = "https://foo.bar/simple/"
+requests.max-retries = 0
+solver.lazy-wheel = true
+system-git-client = false
+virtualenvs.create = true
+virtualenvs.in-project = null
+virtualenvs.options.always-copy = false
+virtualenvs.options.no-pip = false
+virtualenvs.options.system-site-packages = false
+virtualenvs.path = {venv_path}  # {config_cache_dir / "virtualenvs"}
+virtualenvs.prompt = "{{project_name}}-py{{python_version}}"
+virtualenvs.use-poetry-python = false
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_set_http_basic(
+    tester: CommandTester, auth_config_source: DictConfigSource
+) -> None:
+    tester.execute("http-basic.foo username password")
+    tester.execute("--list")
+
+    assert auth_config_source.config["http-basic"]["foo"] == {
+        "username": "username",
+        "password": "password",
+    }
+
+
+def test_unset_http_basic(
+    tester: CommandTester, auth_config_source: DictConfigSource
+) -> None:
+    tester.execute("http-basic.foo username password")
+    tester.execute("http-basic.foo --unset")
+    tester.execute("--list")
+
+    assert "foo" not in auth_config_source.config["http-basic"]
+
+
+def test_set_http_basic_unsuccessful_multiple_values(
+    tester: CommandTester,
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("http-basic.foo username password password")
+
+    assert str(e.value) == "Expected one or two arguments (username, password), got 3"
+
+
+def test_set_pypi_token(
+    tester: CommandTester, auth_config_source: DictConfigSource
+) -> None:
+    tester.execute("pypi-token.pypi mytoken")
+    tester.execute("--list")
+
+    assert auth_config_source.config["pypi-token"]["pypi"] == "mytoken"
+
+
+def test_unset_pypi_token(
+    tester: CommandTester, auth_config_source: DictConfigSource
+) -> None:
+    tester.execute("pypi-token.pypi mytoken")
+    tester.execute("pypi-token.pypi --unset")
+    tester.execute("--list")
+
+    assert "pypi" not in auth_config_source.config["pypi-token"]
+
+
+def test_set_pypi_token_unsuccessful_multiple_values(
+    tester: CommandTester,
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("pypi-token.pypi mytoken mytoken")
+
+    assert str(e.value) == "Expected only one argument (token), got 2"
+
+
+def test_set_pypi_token_no_values(
+    tester: CommandTester,
+) -> None:
+    with pytest.raises(ValueError) as e:
+        tester.execute("pypi-token.pypi")
+
+    assert str(e.value) == "Expected a value for pypi-token.pypi setting."
+
+
+def test_set_client_cert(
+    tester: CommandTester,
+    auth_config_source: DictConfigSource,
+    mocker: MockerFixture,
+) -> None:
+    mocker.spy(ConfigSource, "__init__")
+
+    tester.execute("certificates.foo.client-cert path/to/cert.pem")
+
+    assert (
+        auth_config_source.config["certificates"]["foo"]["client-cert"]
+        == "path/to/cert.pem"
+    )
+
+
+def test_set_client_cert_unsuccessful_multiple_values(
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    mocker.spy(ConfigSource, "__init__")
+
+    with pytest.raises(ValueError) as e:
+        tester.execute("certificates.foo.client-cert path/to/cert.pem path/to/cert.pem")
+
+    assert str(e.value) == "You must pass exactly 1 value"
+
+
+@pytest.mark.parametrize(
+    ("value", "result"),
+    [
+        ("path/to/ca.pem", "path/to/ca.pem"),
+        ("true", True),
+        ("false", False),
+    ],
+)
+def test_set_cert(
+    tester: CommandTester,
+    auth_config_source: DictConfigSource,
+    mocker: MockerFixture,
+    value: str,
+    result: str | bool,
+) -> None:
+    mocker.spy(ConfigSource, "__init__")
+
+    tester.execute(f"certificates.foo.cert {value}")
+
+    assert auth_config_source.config["certificates"]["foo"]["cert"] == result
+
+
+def test_unset_cert(
+    tester: CommandTester,
+    auth_config_source: DictConfigSource,
+    mocker: MockerFixture,
+) -> None:
+    mocker.spy(ConfigSource, "__init__")
+
+    tester.execute("certificates.foo.cert path/to/ca.pem")
+
+    assert "cert" in auth_config_source.config["certificates"]["foo"]
+
+    tester.execute("certificates.foo.cert --unset")
+    assert "cert" not in auth_config_source.config["certificates"]["foo"]
+
+
+def test_config_installer_parallel(
+    tester: CommandTester, command_tester_factory: CommandTesterFactory
+) -> None:
+    tester.execute("--local installer.parallel")
+    assert tester.io.fetch_output().strip() == "true"
+
+    command = command_tester_factory("install")._command
+    assert isinstance(command, InstallCommand)
+    workers = command.installer._executor._max_workers
+    assert workers > 1
+
+    tester.io.clear_output()
+    tester.execute("--local installer.parallel false")
+    tester.execute("--local installer.parallel")
+    assert tester.io.fetch_output().strip() == "false"
+
+    command = command_tester_factory("install")._command
+    assert isinstance(command, InstallCommand)
+    workers = command.installer._executor._max_workers
+    assert workers == 1
+
+
+@pytest.mark.parametrize(
+    ("setting",),
+    [
+        ("installer.no-binary",),
+        ("installer.only-binary",),
+    ],
+)
+@pytest.mark.parametrize(
+    ("value", "expected"),
+    [
+        ("true", [":all:"]),
+        ("1", [":all:"]),
+        ("false", [":none:"]),
+        ("0", [":none:"]),
+        ("pytest", ["pytest"]),
+        ("PyTest", ["pytest"]),
+        ("pytest,black", ["pytest", "black"]),
+        ("", []),
+    ],
+)
+def test_config_installer_binary_filter_config(
+    tester: CommandTester, setting: str, value: str, expected: list[str]
+) -> None:
+    tester.execute(setting)
+    assert tester.io.fetch_output().strip() == "null"
+
+    config = Config.create()
+    assert not config.get(setting)
+
+    tester.execute(f"{setting} '{value}'")
+
+    config = Config.create(reload=True)
+    assert not DeepDiff(config.get(setting), expected, ignore_order=True)
+
+
+def test_config_solver_lazy_wheel(
+    tester: CommandTester, command_tester_factory: CommandTesterFactory
+) -> None:
+    tester.execute("--local solver.lazy-wheel")
+    assert tester.io.fetch_output().strip() == "true"
+
+    repo = LegacyRepository("foo", "https://foo.com")
+    assert repo._lazy_wheel
+
+    tester.io.clear_output()
+    tester.execute("--local solver.lazy-wheel false")
+    tester.execute("--local solver.lazy-wheel")
+    assert tester.io.fetch_output().strip() == "false"
+
+    repo = LegacyRepository("foo", "https://foo.com")
+    assert not repo._lazy_wheel
+
+
+current_config = """\
+[experimental]
+system-git-client = true
+
+[virtualenvs]
+prefer-active-python = false
+"""
+
+config_migrated = """\
+system-git-client = true
+
+[virtualenvs]
+use-poetry-python = true
+"""
+
+
+@pytest.mark.parametrize(
+    ["proceed", "expected_config"],
+    [
+        ("yes", config_migrated),
+        ("no", current_config),
+    ],
+)
+def test_config_migrate(
+    proceed: str,
+    expected_config: str,
+    tester: CommandTester,
+    mocker: MockerFixture,
+    tmp_path: Path,
+) -> None:
+    config_dir = tmp_path / "config"
+    mocker.patch("poetry.locations.CONFIG_DIR", config_dir)
+
+    config_file = Path(config_dir / "config.toml")
+    with config_file.open("w", encoding="utf-8") as fh:
+        fh.write(current_config)
+
+    tester.execute("--migrate", inputs=proceed)
+
+    expected_output = textwrap.dedent("""\
+    Checking for required migrations ...
+    experimental.system-git-client = true -> system-git-client = true
+    virtualenvs.prefer-active-python = false -> virtualenvs.use-poetry-python = true
+    """)
+
+    output = tester.io.fetch_output()
+    assert output.startswith(expected_output)
+
+    with config_file.open("r", encoding="utf-8") as fh:
+        assert fh.read() == expected_config
+
+
+def test_config_migrate_local_config(tester: CommandTester, poetry: Poetry) -> None:
+    local_config = poetry.file.path.parent / "poetry.toml"
+    config_data = textwrap.dedent("""\
+    [experimental]
+    system-git-client = true
+
+    [virtualenvs]
+    prefer-active-python = false
+    """)
+
+    with local_config.open("w", encoding="utf-8") as fh:
+        fh.write(config_data)
+
+    tester.execute("--migrate --local", inputs="yes")
+
+    expected_config = textwrap.dedent("""\
+        system-git-client = true
+
+        [virtualenvs]
+        use-poetry-python = true
+        """)
+
+    with local_config.open("r", encoding="utf-8") as fh:
+        assert fh.read() == expected_config
+
+
+def test_config_migrate_local_config_should_raise_if_not_found(
+    tester: CommandTester,
+) -> None:
+    with pytest.raises(RuntimeError, match="No local config file found"):
+        tester.execute("--migrate --local", inputs="yes")
+
+
+def test_config_installer_build_config_settings(
+    tester: CommandTester, config: Config
+) -> None:
+    config_key = "installer.build-config-settings.demo"
+    value = {"CC": "gcc", "--build-option": ["--one", "--two"]}
+
+    tester.execute(f"{config_key} '{json.dumps(value)}'")
+    assert not DeepDiff(config.config_source.get_property(config_key), value)
+
+    value_two = {"CC": "g++"}
+    tester.execute(f"{config_key} '{json.dumps(value_two)}'")
+    assert not DeepDiff(
+        config.config_source.get_property(config_key), {**value, **value_two}
+    )
+
+    value_three = {
+        "--build-option": ["--three", "--four"],
+        "--package-option": ["--name=foo"],
+    }
+    tester.execute(f"{config_key} '{json.dumps(value_three)}'")
+    assert not DeepDiff(
+        config.config_source.get_property(config_key),
+        {
+            **value,
+            **value_two,
+            **value_three,
+        },
+    )
+
+    tester.execute(f"{config_key} --unset")
+
+    with pytest.raises(PropertyNotFoundError):
+        config.config_source.get_property(config_key)
+
+
+@pytest.mark.parametrize(
+    "value",
+    [
+        "BAD=VALUE",
+        "BAD",
+        json.dumps({"key": ["str", 0]}),
+    ],
+)
+def test_config_installer_build_config_settings_bad_values(
+    value: str, tester: CommandTester
+) -> None:
+    config_key = "installer.build-config-settings.demo"
+
+    with pytest.raises(ValueError) as e:
+        tester.execute(f"{config_key} '{value}'")
+
+    assert str(e.value) == (
+        f"Invalid build config setting '{value}'. "
+        f"It must be a valid JSON with each property "
+        f"a string or a list of strings."
+    )
+
+
+def test_command_config_build_config_settings_get(
+    tester: CommandTester, config: Config
+) -> None:
+    setting_group = "installer.build-config-settings"
+    setting = f"{setting_group}.foo"
+
+    # test when no values are configured
+    tester.execute(setting)
+    assert tester.io.fetch_error() == ""
+    assert (
+        tester.io.fetch_output().strip()
+        == "No build config settings configured for foo."
+    )
+
+    tester.execute(setting_group)
+    assert tester.io.fetch_error() == ""
+    assert (
+        tester.io.fetch_output().strip()
+        == "No packages configured with build config settings."
+    )
+
+    # test with one value configured
+    value = {"CC": "gcc", "--build-options": ["--one", "--two"]}
+    tester.execute(f"{setting} '{json.dumps(value)}'")
+    assert tester.status_code == 0
+    assert tester.io.fetch_output() == tester.io.fetch_error() == ""
+
+    tester.execute(setting)
+    assert tester.io.fetch_error() == ""
+    assert tester.io.fetch_output().strip() == json.dumps(value)
+
+    tester.execute(setting_group)
+    assert tester.io.fetch_error() == ""
+    assert tester.io.fetch_output().strip().splitlines() == [
+        'foo.--build-options = "[--one, --two]"',
+        'foo.CC = "gcc"',
+    ]
+
+    # test getting un-configured value
+    tester.execute(f"{setting_group}.bar")
+    assert tester.io.fetch_error() == ""
+    assert (
+        tester.io.fetch_output().strip()
+        == "No build config settings configured for bar."
+    )
diff --git b/tests/console/commands/test_init.py a/tests/console/commands/test_init.py
new file mode 100644
index 0000000..d09d52c
--- /dev/null
+++ a/tests/console/commands/test_init.py
@@ -0,0 +1,1208 @@
+from __future__ import annotations
+
+import os
+import shutil
+import sys
+import textwrap
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.testers.command_tester import CommandTester
+from packaging.utils import canonicalize_name
+from poetry.core.utils.helpers import module_name
+
+from poetry.console.application import Application
+from poetry.console.commands.init import InitCommand
+from poetry.repositories import RepositoryPool
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+    from unittest.mock import MagicMock
+
+    from poetry.core.packages.package import Package
+    from pytest import FixtureRequest
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from poetry.poetry import Poetry
+    from tests.helpers import PoetryTestApplication
+    from tests.helpers import TestRepository
+    from tests.types import FixtureDirGetter
+    from tests.types import MockedPythonRegister
+
+
+@pytest.fixture
+def source_dir(tmp_path: Path) -> Iterator[Path]:
+    cwd = Path.cwd()
+    try:
+        os.chdir(tmp_path)
+        yield tmp_path
+    finally:
+        os.chdir(cwd)
+
+
+@pytest.fixture
+def patches(mocker: MockerFixture, source_dir: Path, repo: TestRepository) -> None:
+    mocker.patch("pathlib.Path.cwd", return_value=source_dir)
+    mocker.patch(
+        "poetry.console.commands.init.InitCommand._get_pool",
+        return_value=RepositoryPool([repo]),
+    )
+
+
+@pytest.fixture
+def tester(patches: None) -> CommandTester:
+    app = Application()
+    return CommandTester(app.find("init"))
+
+
+def test_basic_interactive(
+    tester: CommandTester, init_basic_inputs: str, init_basic_toml: str
+) -> None:
+    tester.execute(inputs=init_basic_inputs)
+    assert init_basic_toml in tester.io.fetch_output()
+
+
+def test_noninteractive(
+    app: PoetryTestApplication,
+    mocker: MockerFixture,
+    poetry: Poetry,
+    repo: TestRepository,
+    tmp_path: Path,
+) -> None:
+    command = app.find("init")
+    assert isinstance(command, InitCommand)
+    command._pool = poetry.pool
+
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    p = mocker.patch("pathlib.Path.cwd")
+    p.return_value = tmp_path
+
+    tester = CommandTester(command)
+    args = "--name my-package --dependency pytest"
+    tester.execute(args=args, interactive=False)
+
+    expected = "Using version ^3.6.0 for pytest\n"
+    assert tester.io.fetch_output() == expected
+    assert tester.io.fetch_error() == ""
+
+    toml_content = (tmp_path / "pyproject.toml").read_text(encoding="utf-8")
+    assert 'name = "my-package"' in toml_content
+    assert '"pytest (>=3.6.0,<4.0.0)"' in toml_content
+
+    expected_build_system = textwrap.dedent("""
+    [build-system]
+    requires = ["poetry-core>=2.0.0,<3.0.0"]
+    build-backend = "poetry.core.masonry.api"
+    """)
+
+    assert expected_build_system in toml_content
+
+
+def test_interactive_with_dependencies(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("django-pendulum", "0.1.6-pre4"))
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+    repo.add_package(get_package("flask", "2.0.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "pendulu",  # Search for package
+        "1",  # Second option is pendulum
+        "",  # Do not set constraint
+        "Flask",
+        "0",
+        "",
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "pendulum (>=2.0.0,<3.0.0)",
+    "flask (>=2.0.0,<3.0.0)"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+
+
+[build-system]
+requires = ["poetry-core>=2.0.0,<3.0.0"]
+build-backend = "poetry.core.masonry.api"
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+# Regression test for https://github.com/python-poetry/poetry/issues/2355
+def test_interactive_with_dependencies_and_no_selection(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("django-pendulum", "0.1.6-pre4"))
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "pendulu",  # Search for package
+        "",  # Do not select an option
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "",  # Do not select an option
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_empty_license(tester: CommandTester) -> None:
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "",  # Description
+        "n",  # Author
+        "",  # License
+        "",  # Python
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    python = ".".join(str(c) for c in sys.version_info[:2])
+    expected = f"""\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = ""
+authors = [
+    {{name = "Your Name",email = "you@example.com"}}
+]
+readme = "README.md"
+requires-python = ">={python}"
+"""
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_git_dependencies(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "git+https://github.com/demo/demo.git",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ git+https://github.com/demo/demo.git"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+_generate_choice_list_packages_params: list[list[Package]] = [
+    [
+        get_package("flask-blacklist", "1.0.0"),
+        get_package("Flask-Shelve", "1.0.0"),
+        get_package("flask-pwa", "1.0.0"),
+        get_package("Flask-test1", "1.0.0"),
+        get_package("Flask-test2", "1.0.0"),
+        get_package("Flask-test3", "1.0.0"),
+        get_package("Flask-test4", "1.0.0"),
+        get_package("Flask-test5", "1.0.0"),
+        get_package("Flask", "1.0.0"),
+        get_package("Flask-test6", "1.0.0"),
+        get_package("Flask-test7", "1.0.0"),
+    ],
+    [
+        get_package("flask-blacklist", "1.0.0"),
+        get_package("Flask-Shelve", "1.0.0"),
+        get_package("flask-pwa", "1.0.0"),
+        get_package("Flask-test1", "1.0.0"),
+        get_package("Flask", "1.0.0"),
+    ],
+]
+
+
+@pytest.fixture(params=_generate_choice_list_packages_params)
+def _generate_choice_list_packages(request: FixtureRequest) -> list[Package]:
+    packages: list[Package] = request.param
+    return packages
+
+
+@pytest.mark.parametrize("package_name", ["flask", "Flask", "flAsK"])
+def test_generate_choice_list(
+    tester: CommandTester,
+    package_name: str,
+    _generate_choice_list_packages: list[Package],
+) -> None:
+    init_command = tester.command
+    assert isinstance(init_command, InitCommand)
+
+    packages = _generate_choice_list_packages
+    choices = init_command._generate_choice_list(
+        packages, canonicalize_name(package_name)
+    )
+
+    assert choices[0] == "Flask"
+
+
+def test_interactive_with_git_dependencies_with_reference(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "git+https://github.com/demo/demo.git@develop",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ git+https://github.com/demo/demo.git@develop"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_git_dependencies_and_other_name(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "git+https://github.com/demo/pyproject-demo.git",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ git+https://github.com/demo/pyproject-demo.git"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_directory_dependency(
+    tester: CommandTester,
+    repo: TestRepository,
+    source_dir: Path,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    demo = fixture_dir("git") / "github.com" / "demo" / "demo"
+    shutil.copytree(str(demo), str(source_dir / "demo"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "./demo",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    demo_uri = (Path.cwd() / "demo").as_uri()
+    expected = f"""\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {{name = "Your Name",email = "you@example.com"}}
+]
+license = {{text = "MIT"}}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ {demo_uri}"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_directory_dependency_and_other_name(
+    tester: CommandTester,
+    repo: TestRepository,
+    source_dir: Path,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    demo = fixture_dir("git") / "github.com" / "demo" / "pyproject-demo"
+    shutil.copytree(str(demo), str(source_dir / "pyproject-demo"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "./pyproject-demo",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    demo_uri = (Path.cwd() / "pyproject-demo").as_uri()
+    expected = f"""\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {{name = "Your Name",email = "you@example.com"}}
+]
+license = {{text = "MIT"}}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ {demo_uri}"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_file_dependency(
+    tester: CommandTester,
+    repo: TestRepository,
+    source_dir: Path,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    demo = fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl"
+    shutil.copyfile(str(demo), str(source_dir / demo.name))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "./demo-0.1.0-py2.py3-none-any.whl",  # Search for package
+        "",  # Stop searching for packages
+        "",  # Interactive dev packages
+        "pytest",  # Search for package
+        "0",
+        "",
+        "",
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    demo_uri = (Path.cwd() / "demo-0.1.0-py2.py3-none-any.whl").as_uri()
+    expected = f"""\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {{name = "Your Name",email = "you@example.com"}}
+]
+license = {{text = "MIT"}}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "demo @ {demo_uri}"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_interactive_with_wrong_dependency_inputs(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.8",  # Python
+        "",  # Interactive packages
+        "foo 1.19.2",
+        "pendulum 2.0.0 foo",  # Package name and constraint (invalid)
+        "pendulum@^2.0.0",  # Package name and constraint (valid)
+        "",  # End package selection
+        "",  # Interactive dev packages
+        "pytest 3.6.0 foo",  # Dev package name and constraint (invalid)
+        "pytest 3.6.0",  # Dev package name and constraint (invalid)
+        "pytest@3.6.0",  # Dev package name and constraint (valid)
+        "",  # End package selection
+        "\n",  # Generate
+    ]
+    tester.execute(inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.8"
+dependencies = [
+    "foo (==1.19.2)",
+    "pendulum (>=2.0.0,<3.0.0)"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (==3.6.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_python_option(tester: CommandTester) -> None:
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+    tester.execute("--python '>=3.6'", inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_predefined_dependency(tester: CommandTester, repo: TestRepository) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+    tester.execute("--dependency pendulum", inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "pendulum (>=2.0.0,<3.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_predefined_and_interactive_dependencies(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pyramid", "1.10"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "",  # Interactive packages
+        "pyramid",  # Search for package
+        "0",  # First option
+        "",  # Do not set constraint
+        "",  # Stop searching for packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute("--dependency pendulum", inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "pendulum (>=2.0.0,<3.0.0)",
+    "pyramid (>=1.10,<2.0)"
+]
+"""
+    assert expected in tester.io.fetch_output()
+
+
+def test_predefined_dev_dependency(tester: CommandTester, repo: TestRepository) -> None:
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute("--dev-dependency pytest", inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    assert expected in tester.io.fetch_output()
+
+
+def test_predefined_and_interactive_dev_dependencies(
+    tester: CommandTester, repo: TestRepository
+) -> None:
+    repo.add_package(get_package("pytest", "3.6.0"))
+    repo.add_package(get_package("pytest-requests", "0.2.0"))
+
+    inputs = [
+        "my-package",  # Package name
+        "1.2.3",  # Version
+        "This is a description",  # Description
+        "n",  # Author
+        "MIT",  # License
+        ">=3.6",  # Python
+        "n",  # Interactive packages
+        "",  # Interactive dev packages
+        "pytest-requests",  # Search for package
+        "0",  # Select first option
+        "",  # Do not set constraint
+        "",  # Stop searching for dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute("--dev-dependency pytest", inputs="\n".join(inputs))
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)",
+    "pytest-requests (>=0.2.0,<0.3.0)"
+]
+"""
+
+    output = tester.io.fetch_output()
+    assert expected in output
+
+
+def test_predefined_all_options(tester: CommandTester, repo: TestRepository) -> None:
+    repo.add_package(get_package("pendulum", "2.0.0"))
+    repo.add_package(get_package("pytest", "3.6.0"))
+
+    inputs = [
+        "1.2.3",  # Version
+        "",  # Author
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute(
+        "--name my-package "
+        "--description 'This is a description' "
+        "--author 'Foo Bar <foo@example.com>' "
+        "--python '>=3.8' "
+        "--license MIT "
+        "--dependency pendulum "
+        "--dev-dependency pytest",
+        inputs="\n".join(inputs),
+    )
+
+    expected = """\
+[project]
+name = "my-package"
+version = "1.2.3"
+description = "This is a description"
+authors = [
+    {name = "Foo Bar",email = "foo@example.com"}
+]
+license = {text = "MIT"}
+readme = "README.md"
+requires-python = ">=3.8"
+dependencies = [
+    "pendulum (>=2.0.0,<3.0.0)"
+]
+
+[dependency-groups]
+dev = [
+    "pytest (>=3.6.0,<4.0.0)"
+]
+"""
+
+    output = tester.io.fetch_output()
+    assert expected in output
+
+
+def test_add_package_with_extras_and_whitespace(tester: CommandTester) -> None:
+    command = tester.command
+    assert isinstance(command, InitCommand)
+    result = command._parse_requirements(["databases[postgresql, sqlite]"])
+
+    assert result[0]["name"] == "databases"
+    assert len(result[0]["extras"]) == 2
+    assert "postgresql" in result[0]["extras"]
+    assert "sqlite" in result[0]["extras"]
+
+
+def test_init_existing_pyproject_simple(
+    tester: CommandTester,
+    source_dir: Path,
+    init_basic_inputs: str,
+    init_basic_toml: str,
+) -> None:
+    pyproject_file = source_dir / "pyproject.toml"
+    existing_section = """
+[tool.black]
+line-length = 88
+"""
+    pyproject_file.write_text(existing_section, encoding="utf-8")
+    tester.execute(inputs=init_basic_inputs)
+    assert f"{existing_section}\n{init_basic_toml}" in pyproject_file.read_text(
+        encoding="utf-8"
+    )
+
+
+@pytest.mark.parametrize("linesep", ["\n", "\r\n"])
+def test_init_existing_pyproject_consistent_linesep(
+    tester: CommandTester,
+    source_dir: Path,
+    init_basic_inputs: str,
+    init_basic_toml: str,
+    linesep: str,
+) -> None:
+    pyproject_file = source_dir / "pyproject.toml"
+    existing_section = """
+[tool.black]
+line-length = 88
+""".replace("\n", linesep)
+    with open(pyproject_file, "w", newline="", encoding="utf-8") as f:
+        f.write(existing_section)
+    tester.execute(inputs=init_basic_inputs)
+    with open(pyproject_file, newline="", encoding="utf-8") as f:
+        content = f.read()
+    init_basic_toml = init_basic_toml.replace("\n", linesep)
+    assert f"{existing_section}{linesep}{init_basic_toml}" in content
+
+
+def test_init_non_interactive_existing_pyproject_add_dependency(
+    tester: CommandTester,
+    source_dir: Path,
+    init_basic_inputs: str,
+    repo: TestRepository,
+) -> None:
+    pyproject_file = source_dir / "pyproject.toml"
+    existing_section = """
+[tool.black]
+line-length = 88
+"""
+    pyproject_file.write_text(existing_section, encoding="utf-8")
+
+    repo.add_package(get_package("foo", "1.19.2"))
+
+    tester.execute(
+        "--author 'Your Name <you@example.com>' "
+        "--name 'my-package' "
+        "--python '>=3.6' "
+        "--dependency foo",
+        interactive=False,
+    )
+
+    expected = """\
+[project]
+name = "my-package"
+version = "0.1.0"
+description = ""
+authors = [
+    {name = "Your Name",email = "you@example.com"}
+]
+readme = "README.md"
+requires-python = ">=3.6"
+dependencies = [
+    "foo (>=1.19.2,<2.0.0)"
+]
+"""
+    assert f"{existing_section}\n{expected}" in pyproject_file.read_text(
+        encoding="utf-8"
+    )
+
+
+def test_init_existing_pyproject_with_build_system_fails(
+    tester: CommandTester, source_dir: Path, init_basic_inputs: str
+) -> None:
+    pyproject_file = source_dir / "pyproject.toml"
+    existing_section = """
+[build-system]
+requires = ["setuptools >= 40.6.0", "wheel"]
+build-backend = "setuptools.build_meta"
+"""
+    pyproject_file.write_text(existing_section, encoding="utf-8")
+    tester.execute(inputs=init_basic_inputs)
+    assert (
+        tester.io.fetch_error().strip()
+        == "A pyproject.toml file with a defined build-system already exists."
+    )
+    assert existing_section in pyproject_file.read_text(encoding="utf-8")
+
+
+@pytest.mark.parametrize(
+    "name",
+    [
+        None,
+        "",
+        "foo",
+        "   foo  ",
+        "foo==2.0",
+        "foo@2.0",
+        "  foo@2.0   ",
+        "foo 2.0",
+        "   foo 2.0  ",
+    ],
+)
+def test_validate_package_valid(name: str | None) -> None:
+    assert InitCommand._validate_package(name) == name
+
+
+@pytest.mark.parametrize(
+    "name", ["foo bar 2.0", "   foo bar 2.0   ", "foo bar foobar 2.0"]
+)
+def test_validate_package_invalid(name: str) -> None:
+    with pytest.raises(ValueError):
+        assert InitCommand._validate_package(name)
+
+
+@pytest.mark.parametrize(
+    "author",
+    [
+        str(b"Jos\x65\xcc\x81 Duarte", "utf-8"),
+        str(b"Jos\xc3\xa9 Duarte", "utf-8"),
+    ],
+)
+def test_validate_author(author: str) -> None:
+    """
+    This test was added following issue #8779, hence, we're looking to see if the test
+    no longer throws an exception, hence the seemingly "useless" test of just running
+    the method.
+    """
+    InitCommand._validate_author(author, "")
+
+
+@pytest.mark.parametrize(
+    "package_name, include",
+    (
+        ("mypackage", None),
+        ("my-package", "my_package"),
+        ("my.package", "my"),
+        ("my-awesome-package", "my_awesome_package"),
+        ("my.awesome.package", "my"),
+    ),
+)
+def test_package_include(
+    tester: CommandTester,
+    package_name: str,
+    include: str | None,
+) -> None:
+    tester.execute(
+        inputs="\n".join(
+            (
+                package_name,
+                "",  # Version
+                "",  # Description
+                "poetry",  # Author
+                "",  # License
+                ">=3.10",  # Python
+                "n",  # Interactive packages
+                "n",  # Interactive dev packages
+                "\n",  # Generate
+            ),
+        ),
+    )
+
+    packages = ""
+    if include and module_name(package_name) != include:
+        packages = f'\n[tool.poetry]\npackages = [{{include = "{include}"}}]\n'
+
+    expected = (
+        "[project]\n"
+        f'name = "{package_name.replace(".", "-")}"\n'  # canonicalized
+        'version = "0.1.0"\n'
+        'description = ""\n'
+        "authors = [\n"
+        '    {name = "poetry"}\n'
+        "]\n"
+        'readme = "README.md"\n'
+        'requires-python = ">=3.10"\n'
+        "dependencies = [\n"
+        "]\n"
+        f"{packages}"  # This line is optional. Thus, no newline here.
+    )
+    assert expected in tester.io.fetch_output()
+
+
+@pytest.mark.parametrize(
+    ["use_poetry_python", "python"],
+    [
+        (False, "1.1"),
+        (True, f"{sys.version_info[0]}.{sys.version_info[1]}"),
+    ],
+)
+def test_respect_use_poetry_python_on_init(
+    use_poetry_python: bool,
+    python: str,
+    config: Config,
+    tester: CommandTester,
+    source_dir: Path,
+    mocked_python_register: MockedPythonRegister,
+    with_no_active_python: MagicMock,
+) -> None:
+    mocked_python_register(f"{python}.1", make_system=True)
+    config.config["virtualenvs"]["use-poetry-python"] = use_poetry_python
+    pyproject_file = source_dir / "pyproject.toml"
+
+    tester.execute(
+        "--author 'Your Name <you@example.com>' --name 'my-package'",
+        interactive=False,
+    )
+
+    expected = f"""\
+requires-python = ">={python}"
+"""
+
+    assert expected in pyproject_file.read_text(encoding="utf-8")
+
+
+def test_get_pool(mocker: MockerFixture, source_dir: Path) -> None:
+    """
+    Since we are mocking _get_pool() in the other tests, we at least should make
+    sure it works in general. See https://github.com/python-poetry/poetry/issues/8634.
+    """
+    mocker.patch("pathlib.Path.cwd", return_value=source_dir)
+
+    app = Application()
+    command = app.find("init")
+    assert isinstance(command, InitCommand)
+    pool = command._get_pool()
+    assert pool.repositories
+
+
+def test_init_does_not_create_project_structure_in_empty_directory(
+    tester: CommandTester, source_dir: Path
+) -> None:
+    """Test that poetry init does not create project structure in empty directory."""
+    inputs = [
+        "my-package",  # Package name
+        "1.0.0",  # Version
+        "",  # Description
+        "n",  # Author
+        "",  # License
+        "",  # Python
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute(inputs="\n".join(inputs))
+
+    # Should only create pyproject.toml
+    assert (source_dir / "pyproject.toml").exists()
+
+    # Should NOT create these
+    assert not (source_dir / "tests").exists()
+    assert not (source_dir / "my_package").exists()
+    assert not (source_dir / "src").exists()
+    assert not (source_dir / "README.md").exists()
+
+
+def test_init_does_not_create_project_structure_in_non_empty_directory(
+    tester: CommandTester, source_dir: Path
+) -> None:
+    """Test that poetry init does not create project structure in non-empty directory."""
+    # Create some existing files
+    (source_dir / "existing_file.txt").write_text("existing content", encoding="utf-8")
+    (source_dir / "existing_dir").mkdir()
+
+    inputs = [
+        "my-package",  # Package name
+        "1.0.0",  # Version
+        "",  # Description
+        "n",  # Author
+        "",  # License
+        "",  # Python
+        "n",  # Interactive packages
+        "n",  # Interactive dev packages
+        "\n",  # Generate
+    ]
+
+    tester.execute(inputs="\n".join(inputs))
+
+    # Should only create pyproject.toml
+    assert (source_dir / "pyproject.toml").exists()
+
+    # Should NOT create these
+    assert not (source_dir / "tests").exists()
+    assert not (source_dir / "my_package").exists()
+    assert not (source_dir / "src").exists()
+    assert not (source_dir / "README.md").exists()
+
+    # Existing files should remain
+    assert (source_dir / "existing_file.txt").exists()
+    assert (source_dir / "existing_dir").exists()
diff --git b/tests/console/commands/test_install.py a/tests/console/commands/test_install.py
new file mode 100644
index 0000000..d5590dd
--- /dev/null
+++ a/tests/console/commands/test_install.py
@@ -0,0 +1,578 @@
+from __future__ import annotations
+
+import re
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.masonry.utils.module import ModuleOrPackageNotFoundError
+from poetry.core.packages.dependency_group import MAIN_GROUP
+
+from poetry.console.commands.installer_command import InstallerCommand
+from poetry.console.exceptions import GroupNotFoundError
+from tests.helpers import TestLocker
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+PYPROJECT_CONTENT = """\
+[tool.poetry]
+name = "simple-project"
+version = "1.2.3"
+description = "Some description."
+authors = [
+    "Python Poetry <tests@python-poetry.org>"
+]
+license = "MIT"
+
+[tool.poetry.dependencies]
+python = "~2.7 || ^3.4"
+fizz = { version = "^1.0", optional = true }
+buzz = { version = "^2.0", optional = true }
+
+[tool.poetry.group.foo.dependencies]
+foo = "^1.0"
+
+[tool.poetry.group.bar.dependencies]
+bar = "^1.1"
+
+[tool.poetry.group.baz.dependencies]
+baz = "^1.2"
+
+[tool.poetry.group.bim.dependencies]
+bim = "^1.3"
+
+[tool.poetry.group.bam]
+optional = true
+
+[tool.poetry.group.bam.dependencies]
+bam = "^1.4"
+
+[tool.poetry.extras]
+extras_a = [ "fizz" ]
+extras_b = [ "buzz" ]
+"""
+
+
+@pytest.fixture
+def command() -> str:
+    return "install"
+
+
+@pytest.fixture
+def poetry(project_factory: ProjectFactory) -> Poetry:
+    return project_factory(name="export", pyproject_content=PYPROJECT_CONTENT)
+
+
+@pytest.fixture
+def tester(
+    command_tester_factory: CommandTesterFactory, command: str, poetry: Poetry
+) -> CommandTester:
+    return command_tester_factory(command)
+
+
+def _project_factory(
+    fixture_name: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+) -> Poetry:
+    source = fixture_dir(fixture_name)
+    pyproject_content = (source / "pyproject.toml").read_text(encoding="utf-8")
+    poetry_lock_content = (source / "poetry.lock").read_text(encoding="utf-8")
+    return project_factory(
+        name="foobar",
+        pyproject_content=pyproject_content,
+        poetry_lock_content=poetry_lock_content,
+        source=source,
+    )
+
+
+@pytest.mark.parametrize(
+    ("options", "groups"),
+    [
+        ("", {MAIN_GROUP, "foo", "bar", "baz", "bim"}),
+        ("--only-root", set()),
+        (f"--only {MAIN_GROUP}", {MAIN_GROUP}),
+        ("--only foo", {"foo"}),
+        ("--only foo,bar", {"foo", "bar"}),
+        ("--only bam", {"bam"}),
+        ("--with bam", {MAIN_GROUP, "foo", "bar", "baz", "bim", "bam"}),
+        ("--without foo,bar", {MAIN_GROUP, "baz", "bim"}),
+        (f"--without {MAIN_GROUP}", {"foo", "bar", "baz", "bim"}),
+        ("--with foo,bar --without baz --without bim --only bam", {"bam"}),
+        ("--all-groups", {MAIN_GROUP, "foo", "bar", "baz", "bim", "bam"}),
+        # net result zero options
+        ("--with foo", {MAIN_GROUP, "foo", "bar", "baz", "bim"}),
+        ("--without bam", {MAIN_GROUP, "foo", "bar", "baz", "bim"}),
+        ("--with bam --without bam", {MAIN_GROUP, "foo", "bar", "baz", "bim"}),
+        ("--with foo --without foo", {MAIN_GROUP, "bar", "baz", "bim"}),
+    ],
+)
+@pytest.mark.parametrize("with_root", [True, False])
+def test_group_options_are_passed_to_the_installer(
+    options: str,
+    groups: set[str],
+    with_root: bool,
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    """
+    Group options are passed properly to the installer.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+    editable_builder_mock = mocker.patch(
+        "poetry.masonry.builders.editable.EditableBuilder",
+        side_effect=ModuleOrPackageNotFoundError(),
+    )
+
+    if not with_root:
+        options = f"--no-root {options}"
+
+    status_code = tester.execute(options)
+
+    if options == "--no-root --only-root" or with_root:
+        assert status_code == 1
+        return
+    else:
+        assert status_code == 0
+
+    package_groups = set(tester.command.poetry.package._dependency_groups)
+    installer_groups = set(tester.command.installer._groups or [])
+
+    assert installer_groups <= package_groups
+    assert set(installer_groups) == groups
+
+    if with_root:
+        assert editable_builder_mock.call_count == 1
+        assert editable_builder_mock.call_args_list[0][0][0] == tester.command.poetry
+    else:
+        assert editable_builder_mock.call_count == 0
+
+
+@pytest.mark.parametrize("sync", [True, False])
+def test_sync_option_is_passed_to_the_installer(
+    tester: CommandTester, mocker: MockerFixture, sync: bool
+) -> None:
+    """
+    The --sync option is passed properly to the installer.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    tester.execute("--sync" if sync else "")
+
+    assert tester.command.installer._requires_synchronization is sync
+
+    error = tester.io.fetch_error()
+    if sync:
+        assert "deprecated" in error
+        assert "poetry sync" in error
+    else:
+        assert error == ""
+
+
+@pytest.mark.parametrize("compile", [False, True])
+def test_compile_option_is_passed_to_the_installer(
+    tester: CommandTester, mocker: MockerFixture, compile: bool
+) -> None:
+    """
+    The --compile option is passed properly to the installer.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+    enable_bytecode_compilation_mock = mocker.patch.object(
+        tester.command.installer.executor._wheel_installer,
+        "enable_bytecode_compilation",
+    )
+
+    tester.execute("--compile" if compile else "")
+
+    enable_bytecode_compilation_mock.assert_called_once_with(compile)
+
+
+@pytest.mark.parametrize("skip_directory_cli_value", [True, False])
+def test_no_directory_is_passed_to_installer(
+    tester: CommandTester, mocker: MockerFixture, skip_directory_cli_value: bool
+) -> None:
+    """
+    The --no-directory option is passed to the installer.
+    """
+
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    if skip_directory_cli_value is True:
+        tester.execute("--no-directory")
+    else:
+        tester.execute()
+
+    assert tester.command.installer._skip_directory is skip_directory_cli_value
+
+
+def test_no_all_extras_doesnt_populate_installer(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    """
+    Not passing --all-extras means the installer doesn't see any extras.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    tester.execute()
+
+    assert not tester.command.installer._extras
+
+
+def test_all_extras_populates_installer(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    """
+    The --all-extras option results in extras passed to the installer.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    tester.execute("--all-extras")
+
+    assert tester.command.installer._extras == ["extras-a", "extras-b"]
+
+
+def test_extras_are_parsed_and_populate_installer(
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+
+    tester.execute('--extras "first second third"')
+
+    assert tester.command.installer._extras == ["first", "second", "third"]
+
+
+@pytest.mark.parametrize(
+    ("options", "call_count"),
+    [
+        ("--no-plugins", 0),
+        ("", 1),
+    ],
+)
+def test_install_ensures_project_plugins(
+    tester: CommandTester, mocker: MockerFixture, options: str, call_count: int
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+    ensure_project_plugins = mocker.patch(
+        "poetry.plugins.plugin_manager.PluginManager.ensure_project_plugins"
+    )
+
+    tester.execute(options)
+
+    assert ensure_project_plugins.call_count == call_count
+
+
+def test_extras_conflicts_all_extras(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    """
+    The --extras doesn't make sense with --all-extras.
+    """
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+
+    tester.execute("--extras foo --all-extras")
+
+    assert tester.status_code == 1
+    assert (
+        tester.io.fetch_error()
+        == "You cannot specify explicit `--extras` while installing using"
+        " `--all-extras`.\n"
+    )
+
+
+@pytest.mark.parametrize(
+    "options",
+    [
+        "--with foo",
+        "--without foo",
+        "--with foo,bar --without baz",
+        "--only foo",
+        "--all-groups",
+    ],
+)
+def test_only_root_conflicts_with_without_only_all_groups(
+    options: str,
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+
+    tester.execute(f"{options} --only-root")
+
+    assert tester.status_code == 1
+    assert (
+        tester.io.fetch_error()
+        == "The `--with`, `--without`, `--only` and `--all-groups` options cannot be used with"
+        " the `--only-root` option.\n"
+    )
+
+
+@pytest.mark.parametrize(
+    "options",
+    [
+        "--with foo",
+        "--without foo",
+        "--with foo,bar --without baz",
+        "--only foo",
+    ],
+)
+def test_all_groups_conflicts_with_only_with_without(
+    options: str,
+    tester: CommandTester,
+    mocker: MockerFixture,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+
+    tester.execute(f"{options} --all-groups")
+
+    assert tester.status_code == 1
+    assert (
+        tester.io.fetch_error()
+        == "You cannot specify `--with`, `--without`, or `--only` when using `--all-groups`.\n"
+    )
+
+
+@pytest.mark.parametrize(
+    ("options", "valid_groups", "should_raise"),
+    [
+        ({"--with": MAIN_GROUP}, {MAIN_GROUP}, False),
+        ({"--with": "spam"}, set(), True),
+        ({"--with": "spam,foo"}, {"foo"}, True),
+        ({"--without": "spam"}, set(), True),
+        ({"--without": "spam,bar"}, {"bar"}, True),
+        ({"--with": "eggs,ham", "--without": "spam"}, set(), True),
+        ({"--with": "eggs,ham", "--without": "spam,baz"}, {"baz"}, True),
+        ({"--only": "spam"}, set(), True),
+        ({"--only": "bim"}, {"bim"}, False),
+        ({"--only": MAIN_GROUP}, {MAIN_GROUP}, False),
+    ],
+)
+def test_invalid_groups_with_without_only(
+    tester: CommandTester,
+    mocker: MockerFixture,
+    options: dict[str, str],
+    valid_groups: set[str],
+    should_raise: bool,
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+
+    cmd_args = " ".join(f"{flag} {groups}" for (flag, groups) in options.items())
+
+    if not should_raise:
+        tester.execute(cmd_args)
+        assert tester.status_code == 1
+    else:
+        with pytest.raises(GroupNotFoundError, match=r"^Group\(s\) not found:") as e:
+            tester.execute(cmd_args)
+        assert tester.status_code is None
+        for opt, groups in options.items():
+            group_list = groups.split(",")
+            invalid_groups = sorted(set(group_list) - valid_groups)
+            for group in invalid_groups:
+                assert (
+                    re.search(rf"{group} \(via .*{opt}.*\)", str(e.value)) is not None
+                )
+
+
+def test_dry_run_populates_installer(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    """
+    The --dry-run option results in extras passed to the installer.
+    """
+
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    tester.execute("--dry-run")
+
+    assert tester.command.installer._dry_run is True
+
+
+def test_dry_run_does_not_build(tester: CommandTester, mocker: MockerFixture) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+    mocked_editable_builder = mocker.patch(
+        "poetry.masonry.builders.editable.EditableBuilder"
+    )
+
+    tester.execute("--dry-run")
+
+    assert mocked_editable_builder.return_value.build.call_count == 0
+
+
+def test_install_logs_output(tester: CommandTester, mocker: MockerFixture) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+    mocker.patch("poetry.masonry.builders.editable.EditableBuilder")
+
+    tester.execute()
+
+    assert tester.status_code == 0
+    assert (
+        tester.io.fetch_output()
+        == "\nInstalling the current project: simple-project (1.2.3)\n"
+    )
+
+
+def test_install_logs_output_decorated(
+    tester: CommandTester, mocker: MockerFixture
+) -> None:
+    assert isinstance(tester.command, InstallerCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=0)
+    mocker.patch("poetry.masonry.builders.editable.EditableBuilder")
+
+    tester.execute(decorated=True)
+
+    expected = (
+        "\n"
+        "\x1b[39;1mInstalling\x1b[39;22m the current project: "
+        "\x1b[36msimple-project\x1b[39m (\x1b[39;1m1.2.3\x1b[39;22m)"
+        "\x1b[1G\x1b[2K"
+        "\x1b[39;1mInstalling\x1b[39;22m the current project: "
+        "\x1b[36msimple-project\x1b[39m (\x1b[32m1.2.3\x1b[39m)"
+        "\n"
+    )
+    assert tester.status_code == 0
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize("with_root", [True, False])
+@pytest.mark.parametrize("error", ["module", "readme", ""])
+def test_install_warning_corrupt_root(
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    project_factory: ProjectFactory,
+    with_root: bool,
+    error: str,
+) -> None:
+    name = "corrupt"
+    content = f"""\
+[tool.poetry]
+name = "{name}"
+version = "1.2.3"
+description = ""
+authors = []
+"""
+    if error == "readme":
+        content += 'readme = "missing_readme.md"\n'
+    poetry = project_factory(name=name, pyproject_content=content)
+    if error != "module":
+        (poetry.pyproject_path.parent / f"{name}.py").touch()
+
+    tester = command_tester_factory(command, poetry=poetry)
+    tester.execute("" if with_root else "--no-root")
+
+    if error and with_root:
+        assert tester.status_code == 1
+    else:
+        assert tester.status_code == 0
+
+    if with_root and error:
+        assert "The current project could not be installed: " in tester.io.fetch_error()
+    else:
+        assert tester.io.fetch_error() == ""
+
+
+@pytest.mark.parametrize("options", ["", "--without dev"])
+@pytest.mark.parametrize(
+    "project", ["missing_directory_dependency", "missing_file_dependency"]
+)
+def test_install_path_dependency_does_not_exist(
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    project: str,
+    options: str,
+) -> None:
+    poetry = _project_factory(project, project_factory, fixture_dir)
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.locked(True)
+    tester = command_tester_factory(command, poetry=poetry)
+    if options:
+        tester.execute(options)
+    else:
+        with pytest.raises(ValueError, match="does not exist"):
+            tester.execute(options)
+
+
+@pytest.mark.parametrize("options", ["", "--extras notinstallable"])
+def test_install_extra_path_dependency_does_not_exist(
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    options: str,
+) -> None:
+    project = "missing_extra_directory_dependency"
+    poetry = _project_factory(project, project_factory, fixture_dir)
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.locked(True)
+    tester = command_tester_factory(command, poetry=poetry)
+    if not options:
+        tester.execute(options)
+    else:
+        with pytest.raises(ValueError, match="does not exist"):
+            tester.execute(options)
+
+
+@pytest.mark.parametrize("options", ["", "--no-directory"])
+def test_install_missing_directory_dependency_with_no_directory(
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    options: str,
+) -> None:
+    poetry = _project_factory(
+        "missing_directory_dependency", project_factory, fixture_dir
+    )
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.locked(True)
+    tester = command_tester_factory(command, poetry=poetry)
+    if options:
+        tester.execute(options)
+    else:
+        with pytest.raises(ValueError, match="does not exist"):
+            tester.execute(options)
+
+
+def test_non_package_mode_does_not_try_to_install_root(
+    command_tester_factory: CommandTesterFactory,
+    command: str,
+    project_factory: ProjectFactory,
+) -> None:
+    content = """\
+[tool.poetry]
+package-mode = false
+"""
+    poetry = project_factory(name="non-package-mode", pyproject_content=content)
+
+    tester = command_tester_factory(command, poetry=poetry)
+    tester.execute()
+
+    assert tester.status_code == 0
+    assert tester.io.fetch_error() == ""
diff --git b/tests/console/commands/test_lock.py a/tests/console/commands/test_lock.py
new file mode 100644
index 0000000..76064cf
--- /dev/null
+++ a/tests/console/commands/test_lock.py
@@ -0,0 +1,267 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.packages import Locker
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.poetry import Poetry
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def source_dir(tmp_path: Path) -> Path:
+    return Path(tmp_path.as_posix())
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("lock")
+
+
+def _project_factory(
+    fixture_name: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+) -> Poetry:
+    source = fixture_dir(fixture_name)
+    pyproject_content = (source / "pyproject.toml").read_text(encoding="utf-8")
+    poetry_lock_content = (source / "poetry.lock").read_text(encoding="utf-8")
+    return project_factory(
+        name="foobar",
+        pyproject_content=pyproject_content,
+        poetry_lock_content=poetry_lock_content,
+        source=source,
+    )
+
+
+@pytest.fixture
+def poetry_with_outdated_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("outdated_lock", project_factory, fixture_dir)
+
+
+@pytest.fixture
+def poetry_with_up_to_date_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("up_to_date_lock", project_factory, fixture_dir)
+
+
+@pytest.fixture
+def poetry_with_old_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("old_lock", project_factory, fixture_dir)
+
+
+@pytest.fixture
+def poetry_with_nested_path_deps_old_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("old_lock_path_dependency", project_factory, fixture_dir)
+
+
+@pytest.fixture
+def poetry_with_incompatible_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("incompatible_lock", project_factory, fixture_dir)
+
+
+@pytest.fixture
+def poetry_with_invalid_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    return _project_factory("invalid_lock", project_factory, fixture_dir)
+
+
+def test_lock_does_not_update_if_not_necessary(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_old_lockfile: Poetry,
+    repo: TestRepository,
+) -> None:
+    repo.add_package(get_package("sampleproject", "1.3.1"))
+    repo.add_package(get_package("sampleproject", "2.0.0"))
+
+    locker = Locker(
+        lock=poetry_with_old_lockfile.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry_with_old_lockfile.locker._pyproject_data,
+    )
+    poetry_with_old_lockfile.set_locker(locker)
+
+    locked_repository = poetry_with_old_lockfile.locker.locked_repository()
+    assert (
+        poetry_with_old_lockfile.locker.lock_data["metadata"].get("lock-version")
+        == "1.0"
+    )
+
+    tester = command_tester_factory("lock", poetry=poetry_with_old_lockfile)
+    tester.execute()
+
+    locker = Locker(
+        lock=poetry_with_old_lockfile.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data={},
+    )
+    packages = locker.locked_repository().packages
+
+    assert len(packages) == len(locked_repository.packages)
+
+    assert locker.lock_data["metadata"].get("lock-version") == "2.1"
+
+    for package in packages:
+        assert locked_repository.find_packages(package.to_dependency())
+
+
+@pytest.mark.parametrize("regenerate", [True, False])
+def test_lock_always_updates_path_dependencies(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_nested_path_deps_old_lockfile: Poetry,
+    repo: TestRepository,
+    regenerate: bool,
+) -> None:
+    """
+    The lock file contains a variant of the directory dependency "quix" that does
+    not depend on "sampleproject". Although the version of "quix" has not been changed,
+    it should be re-solved because there is always only one valid version
+    of a directory dependency at any time.
+    """
+    repo.add_package(get_package("sampleproject", "1.3.1"))
+
+    locker = Locker(
+        lock=poetry_with_nested_path_deps_old_lockfile.pyproject.file.path.parent
+        / "poetry.lock",
+        pyproject_data=poetry_with_nested_path_deps_old_lockfile.locker._pyproject_data,
+    )
+    poetry_with_nested_path_deps_old_lockfile.set_locker(locker)
+
+    tester = command_tester_factory(
+        "lock", poetry=poetry_with_nested_path_deps_old_lockfile
+    )
+    tester.execute("--regenerate" if regenerate else "")
+
+    packages = locker.locked_repository().packages
+
+    assert {p.name for p in packages} == {"quix", "sampleproject"}
+
+
+@pytest.mark.parametrize("regenerate", [True, False])
+@pytest.mark.parametrize(
+    "project", ["missing_directory_dependency", "missing_file_dependency"]
+)
+def test_lock_path_dependency_does_not_exist(
+    command_tester_factory: CommandTesterFactory,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    project: str,
+    regenerate: bool,
+) -> None:
+    poetry = _project_factory(project, project_factory, fixture_dir)
+    locker = Locker(
+        lock=poetry.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry.locker._pyproject_data,
+    )
+    poetry.set_locker(locker)
+    options = "--regenerate" if regenerate else ""
+
+    tester = command_tester_factory("lock", poetry=poetry)
+    if regenerate or "directory" in project:
+        # directory dependencies are always updated
+        with pytest.raises(ValueError, match="does not exist"):
+            tester.execute(options)
+    else:
+        tester.execute(options)
+
+
+@pytest.mark.parametrize("regenerate", [True, False])
+@pytest.mark.parametrize(
+    "project", ["deleted_directory_dependency", "deleted_file_dependency"]
+)
+def test_lock_path_dependency_deleted_from_pyproject(
+    command_tester_factory: CommandTesterFactory,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+    project: str,
+    regenerate: bool,
+) -> None:
+    poetry = _project_factory(project, project_factory, fixture_dir)
+    locker = Locker(
+        lock=poetry.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry.locker._pyproject_data,
+    )
+    poetry.set_locker(locker)
+
+    tester = command_tester_factory("lock", poetry=poetry)
+    tester.execute("--regenerate" if regenerate else "")
+
+    packages = locker.locked_repository().packages
+
+    assert {p.name for p in packages} == set()
+
+
+@pytest.mark.parametrize("regenerate", [True, False])
+def test_lock_with_incompatible_lockfile(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_incompatible_lockfile: Poetry,
+    repo: TestRepository,
+    regenerate: bool,
+) -> None:
+    repo.add_package(get_package("sampleproject", "1.3.1"))
+
+    locker = Locker(
+        lock=poetry_with_incompatible_lockfile.pyproject.file.path.parent
+        / "poetry.lock",
+        pyproject_data=poetry_with_incompatible_lockfile.locker._pyproject_data,
+    )
+    poetry_with_incompatible_lockfile.set_locker(locker)
+
+    tester = command_tester_factory("lock", poetry=poetry_with_incompatible_lockfile)
+    if regenerate:
+        # still possible because lock file is not required
+        status_code = tester.execute("--regenerate")
+        assert status_code == 0
+    else:
+        # not possible because of incompatible lock file
+        expected = (
+            "(?s)lock file is not compatible .*"
+            " regenerate the lock file with the `poetry lock` command"
+        )
+        with pytest.raises(RuntimeError, match=expected):
+            tester.execute()
+
+
+@pytest.mark.parametrize("regenerate", [True, False])
+def test_lock_with_invalid_lockfile(
+    command_tester_factory: CommandTesterFactory,
+    poetry_with_invalid_lockfile: Poetry,
+    repo: TestRepository,
+    regenerate: bool,
+) -> None:
+    repo.add_package(get_package("sampleproject", "1.3.1"))
+
+    locker = Locker(
+        lock=poetry_with_invalid_lockfile.pyproject.file.path.parent / "poetry.lock",
+        pyproject_data=poetry_with_invalid_lockfile.locker._pyproject_data,
+    )
+    poetry_with_invalid_lockfile.set_locker(locker)
+
+    tester = command_tester_factory("lock", poetry=poetry_with_invalid_lockfile)
+    if regenerate:
+        # still possible because lock file is not required
+        status_code = tester.execute("--regenerate")
+        assert status_code == 0
+    else:
+        # not possible because of broken lock file
+        with pytest.raises(RuntimeError, match="Unable to read the lock file"):
+            tester.execute()
diff --git b/tests/console/commands/test_new.py a/tests/console/commands/test_new.py
new file mode 100644
index 0000000..8f0dd36
--- /dev/null
+++ a/tests/console/commands/test_new.py
@@ -0,0 +1,281 @@
+from __future__ import annotations
+
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.utils.helpers import module_name
+
+from poetry.factory import Factory
+
+
+if TYPE_CHECKING:
+    from unittest.mock import MagicMock
+
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.config.config import Config
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import MockedPythonRegister
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("new")
+
+
+def verify_project_directory(
+    path: Path,
+    package_name: str,
+    package_path: str | Path,
+    is_flat: bool = False,
+) -> Poetry:
+    package_path = Path(package_path)
+    assert path.is_dir()
+
+    pyproject = path / "pyproject.toml"
+    assert pyproject.is_file()
+
+    init_file = path / package_path / "__init__.py"
+    assert init_file.is_file()
+
+    tests_init_file = path / "tests" / "__init__.py"
+    assert tests_init_file.is_file()
+
+    poetry = Factory().create_poetry(cwd=path)
+    assert poetry.package.name == package_name
+
+    if is_flat:
+        package_include = {"include": package_path.parts[0]}
+    else:
+        package_include = {
+            "include": package_path.relative_to("src").parts[0],
+            "from": "src",
+        }
+
+    name = poetry.package.name
+    packages = poetry.local_config.get("packages")
+
+    if not packages:
+        assert module_name(name) == package_include.get("include")
+    else:
+        assert len(packages) == 1
+        assert packages[0] == package_include
+
+    return poetry
+
+
+@pytest.mark.parametrize(
+    "options,directory,package_name,package_path,include_from",
+    [
+        (["--flat"], "package", "package", "package", None),
+        ([], "package", "package", "src/package", "src"),
+        (
+            ["--flat", "--name namespace.package"],
+            "namespace-package",
+            "namespace-package",
+            "namespace/package",
+            None,
+        ),
+        (
+            ["--name namespace.package"],
+            "namespace-package",
+            "namespace-package",
+            "src/namespace/package",
+            "src",
+        ),
+        (
+            ["--flat", "--name namespace.package_a"],
+            "namespace-package_a",
+            "namespace-package-a",
+            "namespace/package_a",
+            None,
+        ),
+        (
+            ["--name namespace.package_a"],
+            "namespace-package_a",
+            "namespace-package-a",
+            "src/namespace/package_a",
+            "src",
+        ),
+        (
+            ["--flat", "--name namespace_package"],
+            "namespace-package",
+            "namespace-package",
+            "namespace_package",
+            None,
+        ),
+        (
+            ["--name namespace_package"],
+            "namespace-package",
+            "namespace-package",
+            "src/namespace_package",
+            "src",
+        ),
+        (
+            ["--flat", "--name namespace.package"],
+            "package",
+            "namespace-package",
+            "namespace/package",
+            None,
+        ),
+        (
+            ["--name namespace.package"],
+            "package",
+            "namespace-package",
+            "src/namespace/package",
+            "src",
+        ),
+        (
+            ["--name namespace.package", "--flat"],
+            "package",
+            "namespace-package",
+            "namespace/package",
+            None,
+        ),
+        (
+            ["--name namespace.package"],
+            "package",
+            "namespace-package",
+            "src/namespace/package",
+            "src",
+        ),
+        (
+            ["--flat"],
+            "namespace_package",
+            "namespace-package",
+            "namespace_package",
+            None,
+        ),
+        (
+            ["--name namespace_package"],
+            "namespace_package",
+            "namespace-package",
+            "src/namespace_package",
+            "src",
+        ),
+    ],
+)
+def test_command_new(
+    options: list[str],
+    directory: str,
+    package_name: str,
+    package_path: str,
+    include_from: str | None,
+    tester: CommandTester,
+    tmp_path: Path,
+) -> None:
+    path = tmp_path / directory
+    options.append(str(path))
+    tester.execute(" ".join(options))
+    verify_project_directory(path, package_name, package_path, "--flat" in options)
+
+
+@pytest.mark.parametrize(("fmt",), [(None,), ("md",), ("rst",), ("adoc",), ("creole",)])
+def test_command_new_with_readme(
+    fmt: str | None, tester: CommandTester, tmp_path: Path
+) -> None:
+    package = "package"
+    path = tmp_path / package
+    options = [path.as_posix()]
+
+    if fmt:
+        options.insert(0, f"--readme {fmt}")
+
+    tester.execute(" ".join(options))
+
+    poetry = verify_project_directory(path, package, Path("src") / package)
+    project_section = poetry.pyproject.data["project"]
+    assert isinstance(project_section, dict)
+    assert project_section["readme"] == f"README.{fmt or 'md'}"
+
+
+@pytest.mark.parametrize(
+    ["use_poetry_python", "python"],
+    [
+        (False, "1.1"),
+        (True, f"{sys.version_info[0]}.{sys.version_info[1]}"),
+    ],
+)
+def test_respect_use_poetry_python_on_new(
+    use_poetry_python: bool,
+    python: str,
+    config: Config,
+    tester: CommandTester,
+    tmp_path: Path,
+    mocked_python_register: MockedPythonRegister,
+    with_no_active_python: MagicMock,
+) -> None:
+    mocked_python_register(f"{python}.1", make_system=True)
+    config.config["virtualenvs"]["use-poetry-python"] = use_poetry_python
+
+    package = "package"
+    path = tmp_path / package
+    options = [str(path)]
+    tester.execute(" ".join(options))
+
+    pyproject_file = path / "pyproject.toml"
+
+    expected = f"""\
+requires-python = ">={python}"
+"""
+
+    assert expected in pyproject_file.read_text(encoding="utf-8")
+
+
+def test_basic_interactive_new(
+    tester: CommandTester, tmp_path: Path, init_basic_inputs: str, new_basic_toml: str
+) -> None:
+    path = tmp_path / "somepackage"
+    tester.execute(f"--interactive {path.as_posix()}", inputs=init_basic_inputs)
+    verify_project_directory(path, "my-package", "src/my_package")
+    assert new_basic_toml in tester.io.fetch_output()
+
+
+def test_new_creates_structure_in_empty_existing_directory(
+    tester: CommandTester, tmp_path: Path
+) -> None:
+    """Test that poetry new creates structure in existing but empty directory."""
+    # Create empty directory
+    package_dir = tmp_path / "my-package"
+    package_dir.mkdir()
+
+    tester.execute(str(package_dir))
+
+    # Should create full project structure
+    verify_project_directory(package_dir, "my-package", "src/my_package")
+
+    assert (package_dir / "tests").exists()
+    assert (package_dir / "src" / "my_package").exists()
+    assert (package_dir / "pyproject.toml").exists()
+    assert (package_dir / "README.md").exists()
+
+
+def test_new_with_dot_in_empty_directory(tester: CommandTester, tmp_path: Path) -> None:
+    """Test that poetry new . works in empty directory and creates structure."""
+    import os
+
+    test_dir = "test_new_with_dot_in_empty_directory"
+
+    # Change to the temporary directory
+    original_cwd = os.getcwd()
+    os.chdir(tmp_path)
+    os.mkdir(test_dir)
+    tmp_path = Path(original_cwd) / test_dir
+    os.chdir(tmp_path)
+
+    try:
+        tester.execute(".")
+
+        # Should create full project structure
+        assert (tmp_path / "tests").exists()
+        assert (tmp_path / "src").exists()
+        assert (tmp_path / "pyproject.toml").exists()
+        assert (tmp_path / "README.md").exists()
+    finally:
+        # Always restore original directory
+        os.chdir(original_cwd)
diff --git b/tests/console/commands/test_publish.py a/tests/console/commands/test_publish.py
new file mode 100644
index 0000000..ca841ad
--- /dev/null
+++ a/tests/console/commands/test_publish.py
@@ -0,0 +1,228 @@
+from __future__ import annotations
+
+import shutil
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+import requests
+
+from poetry.factory import Factory
+
+
+if TYPE_CHECKING:
+    import httpretty
+
+    from cleo.testers.application_tester import ApplicationTester
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.env import VirtualEnv
+    from tests.helpers import PoetryTestApplication
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+
+
+def test_publish_not_possible_in_non_package_mode(
+    fixture_dir: FixtureDirGetter,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    source_dir = fixture_dir("non_package_mode")
+
+    poetry = Factory().create_poetry(source_dir)
+    tester = command_tester_factory("publish", poetry)
+
+    assert tester.execute() == 1
+    assert (
+        tester.io.fetch_error()
+        == "Publishing a package is not possible in non-package mode.\n"
+    )
+
+
+def test_publish_returns_non_zero_code_for_upload_errors(
+    app: PoetryTestApplication,
+    app_tester: ApplicationTester,
+    http: type[httpretty.httpretty],
+) -> None:
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", status=400, body="Bad Request"
+    )
+
+    exit_code = app_tester.execute("publish --username foo --password bar")
+
+    assert exit_code == 1
+
+    expected_output = """
+Publishing simple-project (1.2.3) to PyPI
+"""
+    expected_error_output = """\
+HTTP Error 400: Bad Request | b'Bad Request'
+"""
+
+    assert expected_output in app_tester.io.fetch_output()
+    assert expected_error_output in app_tester.io.fetch_error()
+
+
+@pytest.mark.filterwarnings("ignore::pytest.PytestUnhandledThreadExceptionWarning")
+def test_publish_returns_non_zero_code_for_connection_errors(
+    app: PoetryTestApplication,
+    app_tester: ApplicationTester,
+    http: type[httpretty.httpretty],
+) -> None:
+    def request_callback(*_: Any, **__: Any) -> None:
+        raise requests.ConnectionError()
+
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", body=request_callback
+    )
+
+    exit_code = app_tester.execute("publish --username foo --password bar")
+
+    assert exit_code == 1
+
+    assert "Error connecting to repository" in app_tester.io.fetch_error()
+
+
+def test_publish_with_cert(
+    app_tester: ApplicationTester, mocker: MockerFixture
+) -> None:
+    publisher_publish = mocker.patch("poetry.publishing.Publisher.publish")
+
+    app_tester.execute("publish --cert path/to/ca.pem")
+
+    assert [
+        (None, None, None, Path("path/to/ca.pem"), None, False, False)
+    ] == publisher_publish.call_args
+
+
+def test_publish_with_client_cert(
+    app_tester: ApplicationTester, mocker: MockerFixture
+) -> None:
+    publisher_publish = mocker.patch("poetry.publishing.Publisher.publish")
+
+    app_tester.execute("publish --client-cert path/to/client.pem")
+    assert [
+        (None, None, None, None, Path("path/to/client.pem"), False, False)
+    ] == publisher_publish.call_args
+
+
+@pytest.mark.parametrize(
+    "options",
+    [
+        "--dry-run",
+        "--skip-existing",
+        "--dry-run --skip-existing",
+    ],
+)
+def test_publish_dry_run_skip_existing(
+    app_tester: ApplicationTester, http: type[httpretty.httpretty], options: str
+) -> None:
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", status=409, body="Conflict"
+    )
+
+    exit_code = app_tester.execute(f"publish {options} --username foo --password bar")
+
+    assert exit_code == 0
+
+    output = app_tester.io.fetch_output()
+    error = app_tester.io.fetch_error()
+
+    assert "Publishing simple-project (1.2.3) to PyPI" in output
+    assert "- Uploading simple_project-1.2.3.tar.gz" in error
+    assert "- Uploading simple_project-1.2.3-py2.py3-none-any.whl" in error
+
+
+def test_skip_existing_output(
+    app_tester: ApplicationTester, http: type[httpretty.httpretty]
+) -> None:
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", status=409, body="Conflict"
+    )
+
+    exit_code = app_tester.execute(
+        "publish --skip-existing --username foo --password bar"
+    )
+
+    assert exit_code == 0
+
+    error = app_tester.io.fetch_error()
+    assert "- Uploading simple_project-1.2.3.tar.gz File exists. Skipping" in error
+
+
+@pytest.mark.parametrize("dist_dir", [None, "dist", "other_dist/dist", "absolute"])
+def test_publish_dist_dir_option(
+    http: type[httpretty.httpretty],
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    tmp_venv: VirtualEnv,
+    command_tester_factory: CommandTesterFactory,
+    dist_dir: str | None,
+) -> None:
+    source_dir = fixture_dir("with_multiple_dist_dir")
+    target_dir = tmp_path / "project"
+    shutil.copytree(str(source_dir), str(target_dir))
+
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", status=409, body="Conflict"
+    )
+
+    poetry = Factory().create_poetry(target_dir)
+    tester = command_tester_factory("publish", poetry, environment=tmp_venv)
+
+    if dist_dir is None:
+        exit_code = tester.execute("--dry-run")
+    elif dist_dir == "absolute":
+        exit_code = tester.execute(f"--dist-dir {target_dir / 'dist'} --dry-run")
+    else:
+        exit_code = tester.execute(f"--dist-dir {dist_dir} --dry-run")
+
+    assert exit_code == 0
+
+    output = tester.io.fetch_output()
+    error = tester.io.fetch_error()
+
+    assert "Publishing simple-project (1.2.3) to PyPI" in output
+    assert "- Uploading simple_project-1.2.3.tar.gz" in error
+    assert "- Uploading simple_project-1.2.3-py2.py3-none-any.whl" in error
+
+
+@pytest.mark.parametrize("dist_dir", ["../dist", "tmp/dist", "absolute"])
+def test_publish_dist_dir_and_build_options(
+    http: type[httpretty.httpretty],
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    tmp_venv: VirtualEnv,
+    command_tester_factory: CommandTesterFactory,
+    dist_dir: str | None,
+) -> None:
+    source_dir = fixture_dir("simple_project")
+    target_dir = tmp_path / "project"
+    shutil.copytree(str(source_dir), str(target_dir))
+
+    # Remove dist dir because as it will be built again
+    shutil.rmtree(target_dir / "dist")
+
+    http.register_uri(
+        http.POST, "https://upload.pypi.org/legacy/", status=409, body="Conflict"
+    )
+
+    poetry = Factory().create_poetry(target_dir)
+    tester = command_tester_factory("publish", poetry, environment=tmp_venv)
+
+    if dist_dir == "absolute":
+        exit_code = tester.execute(
+            f"--dist-dir {target_dir / 'test/dist'} --dry-run --build"
+        )
+    else:
+        exit_code = tester.execute(f"--dist-dir {dist_dir} --dry-run --build")
+
+    assert exit_code == 0
+
+    output = tester.io.fetch_output()
+    error = tester.io.fetch_error()
+
+    assert "Publishing simple-project (1.2.3) to PyPI" in output
+    assert "- Uploading simple_project-1.2.3.tar.gz" in error
+    assert "- Uploading simple_project-1.2.3-py2.py3-none-any.whl" in error
diff --git b/tests/console/commands/test_remove.py a/tests/console/commands/test_remove.py
new file mode 100644
index 0000000..dda95ca
--- /dev/null
+++ a/tests/console/commands/test_remove.py
@@ -0,0 +1,670 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Callable
+from typing import cast
+
+import pytest
+import tomlkit
+
+from poetry.core.packages.package import Package
+
+from poetry.factory import Factory
+from tests.helpers import TestLocker
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+    from tomlkit import TOMLDocument
+
+    from poetry.poetry import Poetry
+    from poetry.repositories import Repository
+    from tests.helpers import PoetryTestApplication
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def poetry_with_up_to_date_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Callable[[str], Poetry]:
+    def get_poetry(fixture_name: str) -> Poetry:
+        source = fixture_dir(fixture_name)
+
+        poetry = project_factory(
+            name="foobar",
+            pyproject_content=(source / "pyproject.toml").read_text(encoding="utf-8"),
+            poetry_lock_content=(source / "poetry.lock").read_text(encoding="utf-8"),
+        )
+
+        assert isinstance(poetry.locker, TestLocker)
+        poetry.locker.locked(True)
+        return poetry
+
+    return get_poetry
+
+
+@pytest.fixture()
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("remove")
+
+
+def test_remove_from_project_and_poetry(
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    repo.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("bar", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+
+    project_dependencies: dict[str, Any] = tomlkit.parse(
+        """\
+[project]
+dependencies = [
+    "foo>=2.0",
+    "bar>=1.0",
+]
+"""
+    )
+
+    poetry_dependencies: dict[str, Any] = tomlkit.parse(
+        """\
+[tool.poetry.dependencies]
+foo = "^2.0.0"
+bar = "^1.0.0"
+
+"""
+    )
+
+    pyproject["project"]["dependencies"] = project_dependencies["project"][
+        "dependencies"
+    ]
+    pyproject["tool"]["poetry"]["dependencies"] = poetry_dependencies["tool"]["poetry"][
+        "dependencies"
+    ]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(Factory.create_dependency("foo", "^2.0.0"))
+    app.poetry.package.add_dependency(Factory.create_dependency("bar", "^1.0.0"))
+
+    tester.execute("foo")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    project_dependencies = pyproject["project"]["dependencies"]
+    assert "foo>=2.0" not in project_dependencies
+    assert "bar>=1.0" in project_dependencies
+    poetry_dependencies = pyproject["tool"]["poetry"]["dependencies"]
+    assert "foo" not in poetry_dependencies
+    assert "bar" in poetry_dependencies
+
+    expected_project_string = """\
+dependencies = [
+    "bar>=1.0",
+]
+"""
+    expected_poetry_string = """\
+
+[tool.poetry.dependencies]
+bar = "^1.0.0"
+
+"""
+    pyproject = cast("TOMLDocument", pyproject)
+    string_content = pyproject.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected_project_string = expected_project_string.replace("\n", "\r\n")
+        expected_poetry_string = expected_poetry_string.replace("\n", "\r\n")
+
+    assert expected_project_string in string_content
+    assert expected_poetry_string in string_content
+
+
+def test_remove_from_pep735_group_and_poetry_group(
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    repo.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("bar", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+
+    pep735_dependencies: dict[str, Any] = tomlkit.parse(
+        """\
+[dependency-groups]
+dev = [
+    "foo>=2.0",
+    "bar>=1.0",
+]
+"""
+    )
+
+    poetry_dependencies: dict[str, Any] = tomlkit.parse(
+        """\
+[tool.poetry.group.dev.dependencies]
+foo = "^2.0.0"
+bar = "^1.0.0"
+
+"""
+    )
+
+    pyproject["dependency-groups"] = pep735_dependencies["dependency-groups"]
+    pyproject["tool"]["poetry"]["group"] = poetry_dependencies["tool"]["poetry"][
+        "group"
+    ]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("foo", "^2.0.0", groups=["dev"])
+    )
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("bar", "^1.0.0", groups=["dev"])
+    )
+
+    tester.execute("foo")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    pep735_dependencies = pyproject["dependency-groups"]["dev"]
+    assert "foo>=2.0" not in pep735_dependencies
+    assert "bar>=1.0" in pep735_dependencies
+    poetry_dependencies = pyproject["tool"]["poetry"]["group"]["dev"]["dependencies"]
+    assert "foo" not in poetry_dependencies
+    assert "bar" in poetry_dependencies
+
+    expected_pep735_string = """\
+[dependency-groups]
+dev = [
+    "bar>=1.0",
+]
+"""
+    expected_poetry_string = """\
+
+[tool.poetry.group.dev.dependencies]
+bar = "^1.0.0"
+
+"""
+    pyproject = cast("TOMLDocument", pyproject)
+    string_content = pyproject.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected_pep735_string = expected_pep735_string.replace("\n", "\r\n")
+        expected_poetry_string = expected_poetry_string.replace("\n", "\r\n")
+
+    assert expected_pep735_string in string_content
+    assert expected_poetry_string in string_content
+
+
+@pytest.mark.parametrize("pep_735", [True, False])
+def test_remove_without_specific_group_removes_from_all_groups(
+    pep_735: bool,
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    """
+    Removing without specifying a group removes packages from all groups.
+    """
+    installed.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("baz", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    pyproject["tool"]["poetry"]["dependencies"]["foo"] = "^2.0.0"
+
+    if pep_735:
+        groups_content: dict[str, Any] = tomlkit.parse(
+            """\
+[dependency-groups]
+bar = [
+    "foo (>=2.0,<3.0)",
+    "baz (>=1.0,<2.0)",
+]
+"""
+        )
+        pyproject["dependency-groups"] = groups_content["dependency-groups"]
+
+    else:
+        groups_content = tomlkit.parse(
+            """\
+[tool.poetry.group.bar.dependencies]
+foo = "^2.0.0"
+baz = "^1.0.0"
+
+"""
+        )
+        groups_content = cast("dict[str, Any]", groups_content)
+        pyproject["tool"]["poetry"]["group"] = groups_content["tool"]["poetry"]["group"]
+
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(Factory.create_dependency("foo", "^2.0.0"))
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("foo", "^2.0.0", groups=["bar"])
+    )
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("baz", "^1.0.0", groups=["bar"])
+    )
+
+    tester.execute("foo")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    content = pyproject["tool"]["poetry"]
+    assert "foo" not in content["dependencies"]
+
+    if pep_735:
+        assert not any("foo" in dep for dep in pyproject["dependency-groups"]["bar"])
+        assert any("baz" in dep for dep in pyproject["dependency-groups"]["bar"])
+        expected = """\
+[dependency-groups]
+bar = [
+    "baz (>=1.0,<2.0)",
+]
+"""
+    else:
+        assert "foo" not in content["group"]["bar"]["dependencies"]
+        assert "baz" in content["group"]["bar"]["dependencies"]
+
+        expected = """\
+[tool.poetry.group.bar.dependencies]
+baz = "^1.0.0"
+"""
+    pyproject = cast("TOMLDocument", pyproject)
+    string_content = pyproject.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected = expected.replace("\n", "\r\n")
+
+    assert expected in string_content
+
+
+@pytest.mark.parametrize("pep_735", [True, False])
+def test_remove_with_specific_group_removes_from_specific_groups(
+    pep_735: bool,
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    """
+    Removing with a specific group given removes packages only from this group.
+    """
+    installed.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("baz", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    pyproject["tool"]["poetry"]["dependencies"]["foo"] = "^2.0.0"
+
+    if pep_735:
+        groups_content: dict[str, Any] = tomlkit.parse(
+            """\
+[dependency-groups]
+bar = [
+    "foo (>=2.0,<3.0)",
+    "baz (>=1.0,<2.0)",
+]
+    """
+        )
+        pyproject["dependency-groups"] = groups_content["dependency-groups"]
+
+    else:
+        groups_content = tomlkit.parse(
+            """\
+[tool.poetry.group.bar.dependencies]
+foo = "^2.0.0"
+baz = "^1.0.0"
+    """
+        )
+        groups_content = cast("dict[str, Any]", groups_content)
+        pyproject["tool"]["poetry"]["group"] = groups_content["tool"]["poetry"]["group"]
+
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(Factory.create_dependency("foo", "^2.0.0"))
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("foo", "^2.0.0", groups=["bar"])
+    )
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("baz", "^1.0.0", groups=["bar"])
+    )
+
+    tester.execute("foo --group bar")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    content = pyproject["tool"]["poetry"]
+    assert "foo" in content["dependencies"]
+
+    if pep_735:
+        assert not any("foo" in dep for dep in pyproject["dependency-groups"]["bar"])
+        assert any("baz" in dep for dep in pyproject["dependency-groups"]["bar"])
+        expected = """\
+[dependency-groups]
+bar = [
+    "baz (>=1.0,<2.0)",
+]
+"""
+    else:
+        assert "foo" not in content["group"]["bar"]["dependencies"]
+        assert "baz" in content["group"]["bar"]["dependencies"]
+
+        expected = """\
+[tool.poetry.group.bar.dependencies]
+baz = "^1.0.0"
+"""
+    pyproject = cast("TOMLDocument", pyproject)
+    string_content = pyproject.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected = expected.replace("\n", "\r\n")
+
+    assert expected in string_content
+
+
+@pytest.mark.parametrize("pep_735", [True, False])
+def test_remove_does_not_keep_empty_groups(
+    pep_735: bool,
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    """
+    Empty groups are automatically discarded after package removal.
+    """
+    installed.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("foo", "2.0.0"))
+    repo.add_package(Package("baz", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    pyproject["tool"]["poetry"]["dependencies"]["foo"] = "^2.0.0"
+
+    if pep_735:
+        groups_content: dict[str, Any] = tomlkit.parse(
+            """\
+[dependency-groups]
+bar = [
+    "foo (>=2.0,<3.0)",
+    "baz (>=1.0,<2.0)",
+]
+    """
+        )
+        pyproject["dependency-groups"] = groups_content["dependency-groups"]
+    else:
+        groups_content = tomlkit.parse(
+            """\
+[tool.poetry.group.bar.dependencies]
+foo = "^2.0.0"
+baz = "^1.0.0"
+
+"""
+        )
+        groups_content = cast("dict[str, Any]", groups_content)
+        pyproject["tool"]["poetry"]["group"] = groups_content["tool"]["poetry"]["group"]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(Factory.create_dependency("foo", "^2.0.0"))
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("foo", "^2.0.0", groups=["bar"])
+    )
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("baz", "^1.0.0", groups=["bar"])
+    )
+
+    tester.execute("foo baz --group bar")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    content = pyproject["tool"]["poetry"]
+
+    assert "foo" in content["dependencies"]
+
+    if pep_735:
+        assert "bar" not in pyproject.get("dependency-groups", {})
+        assert "dependency-groups" not in pyproject
+    else:
+        assert "foo" not in content["group"]["bar"]["dependencies"]
+        assert "baz" not in content["group"]["bar"]["dependencies"]
+        content = cast("TOMLDocument", content)
+        assert "[tool.poetry.group.bar]" not in content.as_string()
+        assert "[tool.poetry.group]" not in content.as_string()
+
+
+@pytest.mark.parametrize("pep_735", [True, False])
+def test_remove_canonicalized_named_removes_dependency_correctly(
+    pep_735: bool,
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    installed: Repository,
+) -> None:
+    """
+    Removing a dependency using a canonicalized named removes the dependency.
+    """
+    installed.add_package(Package("foo-bar", "2.0.0"))
+    repo.add_package(Package("foo-bar", "2.0.0"))
+    repo.add_package(Package("baz", "1.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    pyproject["tool"]["poetry"]["dependencies"]["foo-bar"] = "^2.0.0"
+
+    if pep_735:
+        groups_content: dict[str, Any] = tomlkit.parse(
+            """\
+[dependency-groups]
+bar = [
+    "foo-bar (>=2.0,<3.0)",
+    "baz (>=1.0,<2.0)",
+]
+"""
+        )
+        pyproject["dependency-groups"] = groups_content["dependency-groups"]
+    else:
+        groups_content = tomlkit.parse(
+            """\
+[tool.poetry.group.bar.dependencies]
+foo-bar = "^2.0.0"
+baz = "^1.0.0"
+
+"""
+        )
+        groups_content = cast("dict[str, Any]", groups_content)
+        pyproject["tool"]["poetry"].value._insert_after(
+            "dependencies", "group", groups_content["tool"]["poetry"]["group"]
+        )
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+
+    app.poetry.package.add_dependency(Factory.create_dependency("foo-bar", "^2.0.0"))
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("foo-bar", "^2.0.0", groups=["bar"])
+    )
+    app.poetry.package.add_dependency(
+        Factory.create_dependency("baz", "^1.0.0", groups=["bar"])
+    )
+
+    tester.execute("Foo_Bar")
+
+    pyproject = app.poetry.file.read()
+    pyproject = cast("dict[str, Any]", pyproject)
+    content = pyproject["tool"]["poetry"]
+
+    assert "foo-bar" not in content["dependencies"]
+
+    if pep_735:
+        assert not any("foo" in dep for dep in pyproject["dependency-groups"]["bar"])
+        assert any("baz" in dep for dep in pyproject["dependency-groups"]["bar"])
+        expected = """\
+[dependency-groups]
+bar = [
+    "baz (>=1.0,<2.0)",
+]
+"""
+    else:
+        assert "foo-bar" not in content["group"]["bar"]["dependencies"]
+        assert "baz" in content["group"]["bar"]["dependencies"]
+
+        expected = """\
+[tool.poetry.group.bar.dependencies]
+baz = "^1.0.0"
+"""
+    pyproject = cast("TOMLDocument", pyproject)
+    string_content = pyproject.as_string()
+    if "\r\n" in string_content:
+        # consistent line endings
+        expected = expected.replace("\n", "\r\n")
+
+    assert expected in string_content
+
+
+def test_remove_package_does_not_exist(
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    repo.add_package(Package("foo", "2.0.0"))
+
+    original_content = app.poetry.file.read().as_string()
+
+    with pytest.raises(ValueError) as e:
+        tester.execute("foo")
+
+    assert str(e.value) == "The following packages were not found: foo"
+    assert app.poetry.file.read().as_string() == original_content
+
+
+def test_remove_package_no_dependencies(
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    repo.add_package(Package("foo", "2.0.0"))
+
+    pyproject: dict[str, Any] = app.poetry.file.read()
+    assert "dependencies" not in pyproject["project"]
+    del pyproject["tool"]["poetry"]["dependencies"]
+    pyproject = cast("TOMLDocument", pyproject)
+    app.poetry.file.write(pyproject)
+    app.poetry.package._dependency_groups = {}
+
+    with pytest.raises(ValueError) as e:
+        tester.execute("foo")
+
+    assert str(e.value) == "The following packages were not found: foo"
+
+
+def test_remove_command_should_not_write_changes_upon_installer_errors(
+    tester: CommandTester,
+    app: PoetryTestApplication,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+    mocker: MockerFixture,
+) -> None:
+    repo.add_package(Package("foo", "2.0.0"))
+
+    command_tester_factory("add").execute("foo")
+
+    mocker.patch("poetry.installation.installer.Installer.run", return_value=1)
+
+    original_content = app.poetry.file.read().as_string()
+
+    tester.execute("foo")
+
+    assert app.poetry.file.read().as_string() == original_content
+
+
+@pytest.mark.parametrize(
+    "fixture_name", ["up_to_date_lock", "up_to_date_lock_non_package"]
+)
+def test_remove_with_dry_run_keep_files_intact(
+    fixture_name: str,
+    poetry_with_up_to_date_lockfile: Callable[[str], Poetry],
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    poetry = poetry_with_up_to_date_lockfile(fixture_name)
+    tester = command_tester_factory("remove", poetry=poetry)
+
+    original_pyproject_content = poetry.file.read()
+    original_lockfile_content = poetry._locker.lock_data
+
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    tester.execute("docker --dry-run")
+
+    assert poetry.file.read() == original_pyproject_content
+    assert poetry._locker.lock_data == original_lockfile_content
+
+
+@pytest.mark.parametrize(
+    "fixture_name", ["up_to_date_lock", "up_to_date_lock_non_package"]
+)
+def test_remove_performs_uninstall_op(
+    fixture_name: str,
+    poetry_with_up_to_date_lockfile: Callable[[str], Poetry],
+    command_tester_factory: CommandTesterFactory,
+    installed: Repository,
+) -> None:
+    installed.add_package(get_package("docker", "4.3.1"))
+    poetry = poetry_with_up_to_date_lockfile(fixture_name)
+    tester = command_tester_factory("remove", poetry=poetry)
+
+    tester.execute("docker")
+
+    expected = """\
+Updating dependencies
+Resolving dependencies...
+
+Package operations: 0 installs, 0 updates, 1 removal
+
+  - Removing docker (4.3.1)
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    "fixture_name", ["up_to_date_lock", "up_to_date_lock_non_package"]
+)
+def test_remove_with_lock_does_not_perform_uninstall_op(
+    fixture_name: str,
+    poetry_with_up_to_date_lockfile: Callable[[str], Poetry],
+    command_tester_factory: CommandTesterFactory,
+    installed: Repository,
+) -> None:
+    installed.add_package(get_package("docker", "4.3.1"))
+    poetry = poetry_with_up_to_date_lockfile(fixture_name)
+    tester = command_tester_factory("remove", poetry=poetry)
+
+    tester.execute("docker --lock")
+
+    expected = """\
+Updating dependencies
+Resolving dependencies...
+
+Writing lock file
+"""
+
+    assert tester.io.fetch_output() == expected
diff --git b/tests/console/commands/test_run.py a/tests/console/commands/test_run.py
new file mode 100644
index 0000000..8fd5f94
--- /dev/null
+++ a/tests/console/commands/test_run.py
@@ -0,0 +1,269 @@
+from __future__ import annotations
+
+import subprocess
+import sys
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils._compat import WINDOWS
+
+
+if TYPE_CHECKING:
+    from cleo.testers.application_tester import ApplicationTester
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from poetry.utils.env import MockEnv
+    from poetry.utils.env import VirtualEnv
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("run")
+
+
+@pytest.fixture(autouse=True)
+def patches(mocker: MockerFixture, env: MockEnv) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=env)
+
+
+@pytest.fixture
+def poetry_with_scripts(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    source = fixture_dir("scripts")
+
+    return project_factory(
+        name="scripts",
+        pyproject_content=(source / "pyproject.toml").read_text(encoding="utf-8"),
+        source=source,
+    )
+
+
+def test_run_passes_all_args(app_tester: ApplicationTester, env: MockEnv) -> None:
+    app_tester.execute("run python -V")
+    assert env.executed == [["python", "-V"]]
+
+
+def test_run_is_not_eager(app_tester: ApplicationTester, env: MockEnv) -> None:
+    app_tester.execute("--no-ansi -C run -install", decorated=True)
+    assert (
+        app_tester.io.fetch_error().strip()
+        == "Specified path 'run' is not a valid directory."
+    )
+    assert env.executed == []
+
+
+def test_run_passes_args_after_run_before_command(
+    app_tester: ApplicationTester, env: MockEnv
+) -> None:
+    app_tester.execute("run -P. python -V", decorated=True)
+    assert env.executed == [["python", "-V"]]
+
+
+@pytest.mark.parametrize(
+    "args",
+    [
+        "-vP run run",
+        "run -vP run",
+        "-vPrun run",
+        "run -vPrun ",
+        "-v --project=run run",
+        "-v run --project=run",
+        "-v --directory=run run",
+        "run -v --directory=run",
+    ],
+)
+def test_run_passes_args_after_run_before_command_name_conflict(
+    args: str,
+    app_tester: ApplicationTester,
+    env: MockEnv,
+    project_factory: ProjectFactory,
+) -> None:
+    poetry = project_factory("run")
+    path = poetry.file.path.parent
+    path.rename(path.parent / "run")
+
+    app_tester.execute(f"{args} python -V", decorated=True)
+    assert (
+        app_tester.io.remove_format(app_tester.io.fetch_error())
+        == f"Using virtualenv: {env.path}\n"
+    )
+    assert env.executed == [["python", "-V"]]
+
+
+def test_run_keeps_options_passed_before_command_args_combined_short_opts(
+    app_tester: ApplicationTester, env: MockEnv
+) -> None:
+    app_tester.execute("run -VP. --no-ansi python", decorated=True)
+
+    assert not app_tester.io.is_decorated()
+    assert app_tester.io.fetch_output() == app_tester.io.remove_format(
+        app_tester.application.long_version + "\n"
+    )
+    assert env.executed == []
+
+
+def test_run_keeps_options_passed_before_command_args(
+    app_tester: ApplicationTester, env: MockEnv
+) -> None:
+    app_tester.execute("run -V --no-ansi python", decorated=True)
+
+    assert not app_tester.io.is_decorated()
+    assert app_tester.io.fetch_output() == app_tester.io.remove_format(
+        app_tester.application.long_version + "\n"
+    )
+    assert env.executed == []
+
+
+def test_run_keeps_options_passed_before_command(
+    app_tester: ApplicationTester, env: MockEnv
+) -> None:
+    app_tester.execute("-V --no-ansi run python", decorated=True)
+
+    assert not app_tester.io.is_decorated()
+    assert app_tester.io.fetch_output() == app_tester.io.remove_format(
+        app_tester.application.long_version + "\n"
+    )
+    assert env.executed == []
+
+
+def test_run_has_helpful_error_when_command_not_found(
+    app_tester: ApplicationTester, env: MockEnv, capfd: pytest.CaptureFixture[str]
+) -> None:
+    nonexistent_command = "nonexistent-command"
+    env._execute = True
+    app_tester.execute(f"run {nonexistent_command}")
+
+    assert env.executed == [[nonexistent_command]]
+    assert app_tester.status_code == 1
+    if WINDOWS:
+        # On Windows we use a shell to run commands which provides its own error
+        # message when a command is not found that is not captured by the
+        # ApplicationTester but is captured by pytest, and we can access it via capfd.
+        # The exact error message depends on the system language. Thus, we check only
+        # for the name of the command.
+        assert nonexistent_command in capfd.readouterr().err
+    else:
+        assert (
+            app_tester.io.fetch_error() == f"Command not found: {nonexistent_command}\n"
+        )
+
+
+@pytest.mark.skipif(
+    not WINDOWS,
+    reason=(
+        "Poetry only installs CMD script files for console scripts of editable"
+        " dependencies on Windows"
+    ),
+)
+def test_run_console_scripts_of_editable_dependencies_on_windows(
+    tmp_venv: VirtualEnv,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    """
+    On Windows, Poetry installs console scripts of editable dependencies by creating
+    in the environment's `Scripts/` directory both:
+
+        A) a Python file named after the console script (no `.py` extension) which
+            imports and calls the console script using Python code
+        B) a CMD script file also named after the console script
+            (with `.cmd` extension) which calls `python.exe` to execute (A)
+
+    This configuration enables calling the console script by name from `cmd.exe`
+    because the `.cmd` file extension appears by default in the PATHEXT environment
+    variable that `cmd.exe` uses to determine which file should be executed if a
+    filename without an extension is executed as a command.
+
+    This test validates that you can also run such a CMD script file via `poetry run`
+    just by providing the script's name without the `.cmd` extension.
+    """
+    tester = command_tester_factory("run", environment=tmp_venv)
+
+    cmd_script_file = tmp_venv._bin_dir / "quix.cmd"
+    # `/b` ensures we only exit the script instead of any cmd.exe proc that called it
+    encoding = "locale" if sys.version_info >= (3, 10) else None
+    cmd_script_file.write_text("exit /b 123", encoding=encoding)
+    # We prove that the CMD script executed successfully by verifying the exit code
+    # matches what we wrote in the script
+    assert tester.execute("quix") == 123
+
+
+def test_run_script_exit_code(
+    poetry_with_scripts: Poetry,
+    command_tester_factory: CommandTesterFactory,
+    tmp_venv: VirtualEnv,
+    mocker: MockerFixture,
+) -> None:
+    mocker.patch(
+        "os.execvpe",
+        lambda file, args, env: subprocess.call([file, *args[1:]], env=env),
+    )
+    install_tester = command_tester_factory(
+        "install",
+        poetry=poetry_with_scripts,
+        environment=tmp_venv,
+    )
+    assert install_tester.execute() == 0
+    tester = command_tester_factory(
+        "run", poetry=poetry_with_scripts, environment=tmp_venv
+    )
+    assert tester.execute("exit-code") == 42
+    assert tester.execute("return-code") == 42
+
+
+@pytest.mark.parametrize(
+    "installed_script", [False, True], ids=["not installed", "installed"]
+)
+def test_run_script_sys_argv0(
+    installed_script: bool,
+    poetry_with_scripts: Poetry,
+    command_tester_factory: CommandTesterFactory,
+    tmp_venv: VirtualEnv,
+    mocker: MockerFixture,
+) -> None:
+    """
+    If RunCommand calls an installed script defined in pyproject.toml,
+    sys.argv[0] must be set to the full path of the script.
+    """
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=tmp_venv)
+    mocker.patch(
+        "os.execvpe",
+        lambda file, args, env: subprocess.call([file, *args[1:]], env=env),
+    )
+
+    install_tester = command_tester_factory(
+        "install",
+        poetry=poetry_with_scripts,
+        environment=tmp_venv,
+    )
+    assert install_tester.execute() == 0
+    if not installed_script:
+        for path in tmp_venv.script_dirs[0].glob("check-argv0*"):
+            path.unlink()
+
+    tester = command_tester_factory(
+        "run", poetry=poetry_with_scripts, environment=tmp_venv
+    )
+    argv1 = "absolute" if installed_script else "relative"
+    assert tester.execute(f"check-argv0 {argv1}") == 0
+
+    if installed_script:
+        expected_message = ""
+    else:
+        expected_message = """\
+Warning: 'check-argv0' is an entry point defined in pyproject.toml, but it's not \
+installed as a script. You may get improper `sys.argv[0]`.
+
+The support to run uninstalled scripts will be removed in a future release.
+
+Run `poetry install` to resolve and get rid of this message.
+
+"""
+    assert tester.io.fetch_error() == expected_message
diff --git b/tests/console/commands/test_search.py a/tests/console/commands/test_search.py
new file mode 100644
index 0000000..d440dcf
--- /dev/null
+++ a/tests/console/commands/test_search.py
@@ -0,0 +1,146 @@
+from __future__ import annotations
+
+import re
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.repositories.pypi_repository import PyPiRepository
+
+
+if TYPE_CHECKING:
+    import httpretty
+
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.poetry import Poetry
+    from poetry.repositories.legacy_repository import LegacyRepository
+    from tests.types import CommandTesterFactory
+
+
+SQLALCHEMY_SEARCH_OUTPUT_PYPI = """\
+ Package                  Version Source Description
+ broadway-sqlalchemy      0.0.1   PyPI   A broadway extension wrapping Flask-SQLAlchemy
+ cherrypy-sqlalchemy      0.5.3   PyPI   Use SQLAlchemy with CherryPy
+ graphene-sqlalchemy      2.2.2   PyPI   Graphene SQLAlchemy integration
+ jsonql-sqlalchemy        1.0.1   PyPI   Simple JSON-Based CRUD Query Language for SQLAlchemy
+ paginate-sqlalchemy      0.3.0   PyPI   Extension to paginate.Page that supports SQLAlchemy queries
+ sqlalchemy               1.3.10  PyPI   Database Abstraction Library
+ sqlalchemy-audit         0.1.0   PyPI   sqlalchemy-audit provides an easy way to set up revision tracking for your data.
+ sqlalchemy-dao           1.3.1   PyPI   Simple wrapper for sqlalchemy.
+ sqlalchemy-diff          0.1.3   PyPI   Compare two database schemas using sqlalchemy.
+ sqlalchemy-equivalence   0.1.1   PyPI   Provides natural equivalence support for SQLAlchemy declarative models.
+ sqlalchemy-filters       0.10.0  PyPI   A library to filter SQLAlchemy queries.
+ sqlalchemy-nav           0.0.2   PyPI   SQLAlchemy-Nav provides SQLAlchemy Mixins for creating navigation bars compatible with Bootstrap
+ sqlalchemy-plus          0.2.0   PyPI   Create Views and Materialized Views with SqlAlchemy
+ sqlalchemy-repr          0.0.1   PyPI   Automatically generates pretty repr of a SQLAlchemy model.
+ sqlalchemy-schemadisplay 1.3     PyPI   Turn SQLAlchemy DB Model into a graph
+ sqlalchemy-sqlany        1.0.3   PyPI   SAP Sybase SQL Anywhere dialect for SQLAlchemy
+ sqlalchemy-traversal     0.5.2   PyPI   UNKNOWN
+ sqlalchemy-utcdatetime   1.0.4   PyPI   Convert to/from timezone aware datetimes when storing in a DBMS
+ sqlalchemy-wrap          2.1.7   PyPI   Python wrapper for the CircleCI API
+ transmogrify-sqlalchemy  1.0.2   PyPI   Feed data from SQLAlchemy into a transmogrifier pipeline
+"""
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("search")
+
+
+def clean_output(text: str) -> str:
+    return re.sub(r"\s+\n", "\n", text)
+
+
+def test_search(
+    tester: CommandTester, http: type[httpretty.httpretty], poetry: Poetry
+) -> None:
+    # we expect PyPI in the default behaviour
+    poetry.pool.add_repository(PyPiRepository())
+
+    tester.execute("sqlalchemy")
+
+    output = clean_output(tester.io.fetch_output())
+
+    assert output == SQLALCHEMY_SEARCH_OUTPUT_PYPI
+
+
+def test_search_empty_results(
+    tester: CommandTester,
+    http: type[httpretty.httpretty],
+    poetry: Poetry,
+    legacy_repository: LegacyRepository,
+) -> None:
+    poetry.pool.add_repository(legacy_repository)
+
+    tester.execute("does-not-exist")
+
+    output = tester.io.fetch_output()
+    assert output.strip() == "No matching packages were found."
+
+
+def test_search_with_legacy_repository(
+    tester: CommandTester,
+    http: type[httpretty.httpretty],
+    poetry: Poetry,
+    legacy_repository: LegacyRepository,
+) -> None:
+    poetry.pool.add_repository(PyPiRepository())
+    poetry.pool.add_repository(legacy_repository)
+
+    tester.execute("sqlalchemy")
+
+    line_before = " sqlalchemy-filters       0.10.0  PyPI   A library to filter SQLAlchemy queries."
+    additional_line = " sqlalchemy-legacy        4.3.4   legacy"
+    expected = SQLALCHEMY_SEARCH_OUTPUT_PYPI.replace(
+        line_before, f"{line_before}\n{additional_line}"
+    )
+
+    output = clean_output(tester.io.fetch_output())
+
+    assert output == expected
+
+
+def test_search_only_legacy_repository(
+    tester: CommandTester,
+    http: type[httpretty.httpretty],
+    poetry: Poetry,
+    legacy_repository: LegacyRepository,
+) -> None:
+    poetry.pool.add_repository(legacy_repository)
+
+    tester.execute("ipython")
+
+    expected = """\
+ Package Version Source Description
+ ipython 5.7.0   legacy
+ ipython 7.5.0   legacy
+"""
+
+    output = clean_output(tester.io.fetch_output())
+    assert output == expected
+
+
+def test_search_multiple_queries(
+    tester: CommandTester,
+    http: type[httpretty.httpretty],
+    poetry: Poetry,
+    legacy_repository: LegacyRepository,
+) -> None:
+    poetry.pool.add_repository(legacy_repository)
+
+    tester.execute("ipython isort")
+
+    expected = """\
+ Package        Version Source Description
+ ipython        5.7.0   legacy
+ ipython        7.5.0   legacy
+ isort          4.3.4   legacy
+ isort-metadata 4.3.4   legacy
+"""
+
+    output = clean_output(tester.io.fetch_output())
+
+    # we use a set here to avoid ordering issues
+    assert set(output.split("\n")) == set(expected.split("\n"))
diff --git b/tests/console/commands/test_show.py a/tests/console/commands/test_show.py
new file mode 100644
index 0000000..961c4a9
--- /dev/null
+++ a/tests/console/commands/test_show.py
@@ -0,0 +1,2810 @@
+from __future__ import annotations
+
+import json
+
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Callable
+from typing import TypeVar
+from typing import cast
+
+import pytest
+
+from poetry.core.packages.dependency_group import MAIN_GROUP
+from poetry.core.packages.dependency_group import DependencyGroup
+
+from poetry.factory import Factory
+from poetry.utils._compat import tomllib
+from tests.helpers import MOCK_DEFAULT_GIT_REVISION
+from tests.helpers import TestLocker
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.poetry import Poetry
+    from poetry.repositories import Repository
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("show")
+
+
+F = TypeVar("F", bound=Callable[..., Any])
+
+
+def output_format_parametrize(func: F) -> F:
+    formats = ["", "--format json"]
+    return cast("F", pytest.mark.parametrize("output_format", formats)(func))
+
+
+@output_format_parametrize
+def test_show_basic_with_installed_packages(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+    poetry.package.add_dependency(
+        Factory.create_dependency("pytest", "^3.7.3", groups=["dev"])
+    )
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    pytest_373 = get_package("pytest", "3.7.3")
+    pytest_373.description = "Pytest package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+    installed.add_package(pytest_373)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": [], "pytest": []},
+            },
+        }
+    )
+
+    tester.execute(output_format)
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "description": "Pendulum package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "pytest",
+                "version": "3.7.3",
+                "description": "Pytest package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy    0.1.0 Cachy package
+pendulum 2.0.0 Pendulum package
+pytest   3.7.3 Pytest package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+def _configure_project_with_groups(poetry: Poetry, installed: Repository) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+
+    poetry.package.add_dependency_group(DependencyGroup(name="time", optional=True))
+    poetry.package.add_dependency(
+        Factory.create_dependency("pendulum", "^2.0.0", groups=["time"])
+    )
+
+    poetry.package.add_dependency(
+        Factory.create_dependency("pytest", "^3.7.3", groups=["test"])
+    )
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    pytest_373 = get_package("pytest", "3.7.3")
+    pytest_373.description = "Pytest package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+    installed.add_package(pytest_373)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": [], "pytest": []},
+            },
+        }
+    )
+
+
+@pytest.mark.parametrize(
+    ("options", "expected"),
+    [
+        (
+            "",
+            """\
+cachy  0.1.0 Cachy package
+pytest 3.7.3 Pytest package
+""",
+        ),
+        (
+            "--format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--with time",
+            """\
+cachy    0.1.0 Cachy package
+pendulum 2.0.0 Pendulum package
+pytest   3.7.3 Pytest package
+""",
+        ),
+        (
+            "--with time --format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--without test",
+            """\
+cachy 0.1.0 Cachy package
+""",
+        ),
+        (
+            "--without test --format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            f"--without {MAIN_GROUP}",
+            """\
+pytest 3.7.3 Pytest package
+""",
+        ),
+        (
+            f"--without {MAIN_GROUP} --format json",
+            [
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            f"--only {MAIN_GROUP}",
+            """\
+cachy 0.1.0 Cachy package
+""",
+        ),
+        (
+            f"--only {MAIN_GROUP} --format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--with time --without test",
+            """\
+cachy    0.1.0 Cachy package
+pendulum 2.0.0 Pendulum package
+""",
+        ),
+        (
+            "--with time --without test --format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            f"--with time --without {MAIN_GROUP},test",
+            """\
+pendulum 2.0.0 Pendulum package
+""",
+        ),
+        (
+            f"--with time --without {MAIN_GROUP},test --format json",
+            [
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--only time",
+            """\
+pendulum 2.0.0 Pendulum package
+""",
+        ),
+        (
+            "--only time --format json",
+            [
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--only time --with test",
+            """\
+pendulum 2.0.0 Pendulum package
+""",
+        ),
+        (
+            "--only time --with test --format json",
+            [
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+        (
+            "--with time",
+            """\
+cachy    0.1.0 Cachy package
+pendulum 2.0.0 Pendulum package
+pytest   3.7.3 Pytest package
+""",
+        ),
+        (
+            "--with time --format json",
+            [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "installed_status": "installed",
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.7.3",
+                    "description": "Pytest package",
+                    "installed_status": "installed",
+                },
+            ],
+        ),
+    ],
+)
+def test_show_basic_with_group_options(
+    options: str,
+    expected: str | list[dict[str, str]],
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    _configure_project_with_groups(poetry, installed)
+
+    tester.execute(options)
+
+    if "json" in options:
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_basic_with_installed_packages_single(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    installed.add_package(cachy_010)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": []},
+            },
+        }
+    )
+
+    tester.execute(f"cachy {output_format}")
+
+    expected: dict[str, str] | list[str] = {}
+    if "json" in output_format:
+        expected = {"name": "cachy", "version": "0.1.0", "description": "Cachy package"}
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = [
+            "name         : cachy",
+            "version      : 0.1.0",
+            "description  : Cachy package",
+        ]
+        assert [
+            line.strip() for line in tester.io.fetch_output().splitlines()
+        ] == expected
+
+
+@output_format_parametrize
+def test_show_basic_with_installed_packages_single_canonicalized(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("foo-bar", "^0.1.0"))
+
+    foo_bar = get_package("foo-bar", "0.1.0")
+    foo_bar.description = "Foobar package"
+
+    installed.add_package(foo_bar)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "foo-bar",
+                    "version": "0.1.0",
+                    "description": "Foobar package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"foo-bar": []},
+            },
+        }
+    )
+
+    tester.execute(f"Foo_Bar {output_format}")
+
+    expected: dict[str, str] | list[str] = {}
+    if "json" in output_format:
+        expected = {
+            "name": "foo-bar",
+            "version": "0.1.0",
+            "description": "Foobar package",
+        }
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = [
+            "name         : foo-bar",
+            "version      : 0.1.0",
+            "description  : Foobar package",
+        ]
+        assert [
+            line.strip() for line in tester.io.fetch_output().splitlines()
+        ] == expected
+
+
+@output_format_parametrize
+def test_show_basic_with_not_installed_packages_non_decorated(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(output_format)
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "description": "Pendulum package",
+                "installed_status": "not-installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy        0.1.0 Cachy package
+pendulum (!) 2.0.0 Pendulum package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+def test_show_basic_with_not_installed_packages_decorated(
+    tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(decorated=True)
+
+    expected = """\
+\033[36mcachy   \033[39m \033[39;1m0.1.0\033[39;22m Cachy package
+\033[31mpendulum\033[39m \033[39;1m2.0.0\033[39;22m Pendulum package
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_latest_non_decorated(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+    pendulum_201 = get_package("pendulum", "2.0.1")
+    pendulum_201.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+    repo.add_package(pendulum_201)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--latest {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "latest_version": "2.0.1",
+                "description": "Pendulum package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy    0.1.0 0.2.0 Cachy package
+pendulum 2.0.0 2.0.1 Pendulum package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+def test_show_latest_decorated(
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+    pendulum_201 = get_package("pendulum", "2.0.1")
+    pendulum_201.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+    repo.add_package(pendulum_201)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute("--latest", decorated=True)
+
+    expected = """\
+\033[36mcachy   \033[39m \033[39;1m0.1.0\033[39;22m\
+ \033[33m0.2.0\033[39m Cachy package
+\033[36mpendulum\033[39m \033[39;1m2.0.0\033[39;22m\
+ \033[31m2.0.1\033[39m Pendulum package
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_outdated(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy 0.1.0 0.2.0 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_outdated_with_only_up_to_date_packages(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    installed.add_package(cachy_020)
+    repo.add_package(cachy_020)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = []
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = ""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_outdated_has_prerelease_but_not_allowed(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+    cachy_030dev = get_package("cachy", "0.3.0.dev123")
+    cachy_030dev.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+
+    # sorting isn't used, so this has to be the first element to
+    # replicate the issue in PR #1548
+    repo.add_package(cachy_030dev)
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy 0.1.0 0.2.0 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_outdated_has_prerelease_and_allowed(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(
+        Factory.create_dependency(
+            "cachy", {"version": ">=0.0.1", "allow-prereleases": True}
+        )
+    )
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010dev = get_package("cachy", "0.1.0.dev1")
+    cachy_010dev.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+    cachy_030dev = get_package("cachy", "0.3.0.dev123")
+    cachy_030dev.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(cachy_010dev)
+    installed.add_package(pendulum_200)
+
+    # sorting isn't used, so this has to be the first element to
+    # replicate the issue in PR #1548
+    repo.add_package(cachy_030dev)
+    repo.add_package(cachy_010dev)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0.dev1",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0.dev1",
+                "latest_version": "0.3.0.dev123",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy 0.1.0.dev1 0.3.0.dev123 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_outdated_formatting(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+    pendulum_201 = get_package("pendulum", "2.0.1")
+    pendulum_201.description = "Pendulum package"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+    repo.add_package(pendulum_201)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "latest_version": "2.0.1",
+                "description": "Pendulum package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy    0.1.0 0.2.0 Cachy package
+pendulum 2.0.0 2.0.1 Pendulum package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize(
+    ("project_directory", "required_fixtures"),
+    [
+        (
+            "project_with_local_dependencies",
+            ["distributions/demo-0.1.0-py2.py3-none-any.whl", "project_with_setup"],
+        ),
+    ],
+)
+@output_format_parametrize
+def test_show_outdated_local_dependencies(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+    cachy_030 = get_package("cachy", "0.3.0")
+    cachy_030.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    demo_010 = get_package("demo", "0.1.0")
+    demo_010.description = ""
+
+    my_package_011 = get_package("project-with-setup", "0.1.1")
+    my_package_011.description = "Demo project."
+
+    installed.add_package(cachy_020)
+    installed.add_package(pendulum_200)
+    installed.add_package(demo_010)
+    installed.add_package(my_package_011)
+
+    repo.add_package(cachy_020)
+    repo.add_package(cachy_030)
+    repo.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "demo",
+                    "version": "0.1.0",
+                    "description": "Demo package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "source": {
+                        "type": "file",
+                        "reference": "",
+                        "url": "../distributions/demo-0.1.0-py2.py3-none-any.whl",
+                    },
+                },
+                {
+                    "name": "project-with-setup",
+                    "version": "0.1.1",
+                    "description": "Demo project.",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {
+                        "pendulum": ">=1.4.4",
+                        "cachy": {"version": ">=0.2.0", "extras": ["msgpack"]},
+                    },
+                    "source": {
+                        "type": "directory",
+                        "reference": "",
+                        "url": "../project_with_setup",
+                    },
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {
+                    "cachy": [],
+                    "pendulum": [],
+                    "demo": [],
+                    "project-with-setup": [],
+                },
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.2.0",
+                "latest_version": "0.3.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "project-with-setup",
+                "version": "0.1.1 ../project_with_setup",
+                "latest_version": "0.1.2 ../project_with_setup",
+                "description": "Demo project.",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy              0.2.0                       0.3.0
+project-with-setup 0.1.1 ../project_with_setup 0.1.2 ../project_with_setup
+"""
+        assert (
+            "\n".join(line.rstrip() for line in tester.io.fetch_output().splitlines())
+            == expected.rstrip()
+        )
+
+
+@pytest.mark.parametrize("project_directory", ["project_with_git_dev_dependency"])
+@output_format_parametrize
+def test_show_outdated_git_dev_dependency(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    demo_011 = get_package("demo", "0.1.1")
+    demo_011.description = "Demo package"
+
+    pytest = get_package("pytest", "3.4.3")
+    pytest.description = "Pytest"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+    installed.add_package(demo_011)
+    installed.add_package(pytest)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+    repo.add_package(pytest)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "demo",
+                    "version": "0.1.1",
+                    "description": "Demo package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "source": {
+                        "type": "git",
+                        "reference": MOCK_DEFAULT_GIT_REVISION,
+                        "resolved_reference": MOCK_DEFAULT_GIT_REVISION,
+                        "url": "https://github.com/demo/demo.git",
+                    },
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.4.3",
+                    "description": "Pytest",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": [], "demo": [], "pytest": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+            {
+                "name": "demo",
+                "version": "0.1.1 9cf87a2",
+                "latest_version": "0.1.2 9cf87a2",
+                "description": "Demo package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy 0.1.0         0.2.0         Cachy package
+demo  0.1.1 9cf87a2 0.1.2 9cf87a2 Demo package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@pytest.mark.parametrize("project_directory", ["project_with_git_dev_dependency"])
+@output_format_parametrize
+def test_show_outdated_no_dev_git_dev_dependency(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+    cachy_020 = get_package("cachy", "0.2.0")
+    cachy_020.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    demo_011 = get_package("demo", "0.1.1")
+    demo_011.description = "Demo package"
+
+    pytest = get_package("pytest", "3.4.3")
+    pytest.description = "Pytest"
+
+    installed.add_package(cachy_010)
+    installed.add_package(pendulum_200)
+    installed.add_package(demo_011)
+    installed.add_package(pytest)
+
+    repo.add_package(cachy_010)
+    repo.add_package(cachy_020)
+    repo.add_package(pendulum_200)
+    repo.add_package(pytest)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "demo",
+                    "version": "0.1.1",
+                    "description": "Demo package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "source": {
+                        "type": "git",
+                        "reference": MOCK_DEFAULT_GIT_REVISION,
+                        "url": "https://github.com/demo/pyproject-demo.git",
+                    },
+                },
+                {
+                    "name": "pytest",
+                    "version": "3.4.3",
+                    "description": "Pytest",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": [], "demo": [], "pytest": []},
+            },
+        }
+    )
+
+    tester.execute(f"--outdated --without dev {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "latest_version": "0.2.0",
+                "description": "Cachy package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy 0.1.0 0.2.0 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_hides_incompatible_package(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(
+        Factory.create_dependency("cachy", {"version": "^0.1.0", "python": "< 2.0"})
+    )
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "^2.0.0"))
+
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(output_format)
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "description": "Pendulum package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+pendulum 2.0.0 Pendulum package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_all_shows_incompatible_package(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    cachy_010 = get_package("cachy", "0.1.0")
+    cachy_010.description = "Cachy package"
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+
+    installed.add_package(pendulum_200)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "requirements": {"python": "1.0"},
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": []},
+            },
+        }
+    )
+
+    tester.execute(f"--all {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "description": "Cachy package",
+                "installed_status": "not-installed",
+            },
+            {
+                "name": "pendulum",
+                "version": "2.0.0",
+                "description": "Pendulum package",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy     0.1.0 Cachy package
+pendulum  2.0.0 Pendulum package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_hides_incompatible_package_with_duplicate(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(
+        Factory.create_dependency("cachy", {"version": "0.1.0", "platform": "linux"})
+    )
+    poetry.package.add_dependency(
+        Factory.create_dependency("cachy", {"version": "0.1.1", "platform": "darwin"})
+    )
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "files": [],
+                },
+                {
+                    "name": "cachy",
+                    "version": "0.1.1",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "files": [],
+                },
+            ],
+            "metadata": {"content-hash": "123456789"},
+        }
+    )
+
+    tester.execute(output_format)
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.1",
+                "description": "Cachy package",
+                "installed_status": "not-installed",
+            }
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy (!) 0.1.1 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_all_shows_all_duplicates(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    poetry.package.add_dependency(
+        Factory.create_dependency("cachy", {"version": "0.1.0", "platform": "linux"})
+    )
+    poetry.package.add_dependency(
+        Factory.create_dependency("cachy", {"version": "0.1.1", "platform": "darwin"})
+    )
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.1.0",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "files": [],
+                },
+                {
+                    "name": "cachy",
+                    "version": "0.1.1",
+                    "description": "Cachy package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "files": [],
+                },
+            ],
+            "metadata": {"content-hash": "123456789"},
+        }
+    )
+
+    tester.execute(f"--all {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.1.0",
+                "description": "Cachy package",
+                "installed_status": "not-installed",
+            },
+            {
+                "name": "cachy",
+                "version": "0.1.1",
+                "description": "Cachy package",
+                "installed_status": "not-installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+cachy     0.1.0 Cachy package
+cachy (!) 0.1.1 Cachy package
+"""
+        assert tester.io.fetch_output() == expected
+
+
+def test_show_tree(
+    tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.2.0"))
+
+    cachy2 = get_package("cachy", "0.2.0")
+    cachy2.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+
+    installed.add_package(cachy2)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+                },
+                {
+                    "name": "msgpack-python",
+                    "version": "0.5.1",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "msgpack-python": []},
+            },
+        }
+    )
+
+    tester.execute("--tree", supports_utf8=False)
+
+    expected = """\
+cachy 0.2.0
+`-- msgpack-python >=0.5 <0.6
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_show_tree_no_dev(
+    tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.2.0"))
+    poetry.package.add_dependency(
+        Factory.create_dependency("pytest", "^6.1.0", groups=["dev"])
+    )
+
+    cachy2 = get_package("cachy", "0.2.0")
+    cachy2.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+    installed.add_package(cachy2)
+
+    pytest = get_package("pytest", "6.1.1")
+    installed.add_package(pytest)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+                },
+                {
+                    "name": "msgpack-python",
+                    "version": "0.5.1",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+                {
+                    "name": "pytest",
+                    "version": "6.1.1",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "msgpack-python": [], "pytest": []},
+            },
+        }
+    )
+
+    tester.execute("--tree --without dev")
+
+    expected = """\
+cachy 0.2.0
+└── msgpack-python >=0.5 <0.6
+"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_show_tree_why_package(
+    tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("a", "=0.0.1"))
+
+    a = get_package("a", "0.0.1")
+    installed.add_package(a)
+    a.add_dependency(Factory.create_dependency("b", "=0.0.1"))
+
+    b = get_package("b", "0.0.1")
+    a.add_dependency(Factory.create_dependency("c", "=0.0.1"))
+    installed.add_package(b)
+
+    c = get_package("c", "0.0.1")
+    installed.add_package(c)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "a",
+                    "version": "0.0.1",
+                    "dependencies": {"b": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "b",
+                    "version": "0.0.1",
+                    "dependencies": {"c": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "c",
+                    "version": "0.0.1",
+                    "python-versions": "*",
+                    "optional": False,
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"a": [], "b": [], "c": []},
+            },
+        }
+    )
+
+    tester.execute("--tree --why b")
+
+    expected = """\
+a 0.0.1
+└── b =0.0.1
+    └── c =0.0.1 \n"""
+
+    assert tester.io.fetch_output() == expected
+
+
+def test_show_tree_why(
+    tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("a", "=0.0.1"))
+
+    a = get_package("a", "0.0.1")
+    installed.add_package(a)
+    a.add_dependency(Factory.create_dependency("b", "=0.0.1"))
+
+    b = get_package("b", "0.0.1")
+    b.add_dependency(Factory.create_dependency("c", "=0.0.1"))
+    installed.add_package(b)
+
+    c = get_package("c", "0.0.1")
+    installed.add_package(c)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "a",
+                    "version": "0.0.1",
+                    "dependencies": {"b": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "b",
+                    "version": "0.0.1",
+                    "dependencies": {"c": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "c",
+                    "version": "0.0.1",
+                    "python-versions": "*",
+                    "optional": False,
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"a": [], "b": [], "c": []},
+            },
+        }
+    )
+
+    tester.execute("--why")
+
+    # this has to be on a single line due to the padding whitespace, which gets stripped
+    # by pre-commit.
+    expected = """a 0.0.1        \nb 0.0.1 from a \nc 0.0.1 from b \n"""
+
+    assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_why(
+    output_format: str, tester: CommandTester, poetry: Poetry, installed: Repository
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("a", "=0.0.1"))
+
+    a = get_package("a", "0.0.1")
+    a.description = "Package A"
+    a.add_dependency(Factory.create_dependency("b", "=0.0.1"))
+    a.add_dependency(Factory.create_dependency("c", "=0.0.1"))
+    installed.add_package(a)
+
+    b = get_package("b", "0.0.1")
+    b.description = "Package B"
+    b.add_dependency(Factory.create_dependency("c", "=0.0.1"))
+    installed.add_package(b)
+
+    c = get_package("c", "0.0.1")
+    c.description = "Package C"
+    installed.add_package(c)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "a",
+                    "version": "0.0.1",
+                    "description": "Package A",
+                    "dependencies": {"b": "=0.0.1", "c": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "b",
+                    "version": "0.0.1",
+                    "description": "Package B",
+                    "dependencies": {"c": "=0.0.1"},
+                    "python-versions": "*",
+                    "optional": False,
+                },
+                {
+                    "name": "c",
+                    "version": "0.0.1",
+                    "description": "Package C",
+                    "python-versions": "*",
+                    "optional": False,
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"a": [], "b": [], "c": []},
+            },
+        }
+    )
+
+    tester.execute(f"--why {output_format}")
+
+    expected: str | list[dict[str, str | list[str]]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "a",
+                "version": "0.0.1",
+                "description": "Package A",
+                "installed_status": "installed",
+            },
+            {
+                "name": "b",
+                "version": "0.0.1",
+                "description": "Package B",
+                "installed_status": "installed",
+                "required_by": ["a"],
+            },
+            {
+                "name": "c",
+                "version": "0.0.1",
+                "description": "Package C",
+                "installed_status": "installed",
+                "required_by": ["a", "b"],
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+a 0.0.1          Package A
+b 0.0.1 from a   Package B
+c 0.0.1 from a,b Package C
+"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_required_by_deps(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.2.0"))
+    poetry.package.add_dependency(Factory.create_dependency("pendulum", "2.0.0"))
+
+    cachy2 = get_package("cachy", "0.2.0")
+    cachy2.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+
+    pendulum = get_package("pendulum", "2.0.0")
+    pendulum.add_dependency(Factory.create_dependency("CachY", "^0.2.0"))
+
+    installed.add_package(cachy2)
+    installed.add_package(pendulum)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"cachy": ">=0.2.0 <0.3.0"},
+                },
+                {
+                    "name": "msgpack-python",
+                    "version": "0.5.1",
+                    "description": "",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "pendulum": [], "msgpack-python": []},
+            },
+        }
+    )
+
+    tester.execute(f"cachy {output_format}")
+
+    expected: str | dict[str, str | dict[str, str]] = ""
+    if "json" in output_format:
+        expected = {
+            "name": "cachy",
+            "version": "0.2.0",
+            "description": "",
+            "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+            "required_by": {"pendulum": ">=0.2.0 <0.3.0"},
+        }
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """\
+ name         : cachy
+ version      : 0.2.0
+ description  :
+
+dependencies
+ - msgpack-python >=0.5 <0.6
+
+required by
+ - pendulum requires >=0.2.0 <0.3.0
+"""
+        actual = [line.rstrip() for line in tester.io.fetch_output().splitlines()]
+        assert actual == expected.splitlines()
+
+
+@pytest.mark.parametrize("truncate", [False, True])
+def test_show_entire_description_truncate(
+    tester: CommandTester, poetry: Poetry, installed: Repository, truncate: str
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.2.0"))
+
+    cachy2 = get_package("cachy", "0.2.0")
+    cachy2.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+
+    installed.add_package(cachy2)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "This is a veeeeeeeery long description that might be truncated.",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+                },
+                {
+                    "name": "msgpack-python",
+                    "version": "0.5.1",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "msgpack-python": []},
+            },
+        }
+    )
+
+    tester.execute("" if truncate else "--no-truncate")
+
+    if truncate:
+        expected = """\
+cachy              0.2.0 This is a veeeeeeeery long description that might ...
+msgpack-python (!) 0.5.1"""
+    else:
+        expected = """\
+cachy              0.2.0 This is a veeeeeeeery long description that might be truncated.
+msgpack-python (!) 0.5.1"""
+
+    assert tester.io.fetch_output().strip() == expected
+
+
+def test_show_errors_without_lock_file(tester: CommandTester, poetry: Poetry) -> None:
+    assert not poetry.locker.lock.exists()
+
+    tester.execute()
+
+    expected = "Error: poetry.lock not found. Run `poetry lock` to create it.\n"
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == 1
+
+
+@output_format_parametrize
+def test_show_dependency_installed_from_git_in_dev(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    # Add a regular dependency for a package in main, and a git dependency for the same
+    # package in dev.
+    poetry.package.add_dependency(Factory.create_dependency("demo", "^0.1.1"))
+    poetry.package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"git": "https://github.com/demo/demo.git"}, groups=["dev"]
+        )
+    )
+
+    demo_011 = get_package("demo", "0.1.1")
+    demo_011.description = "Demo package"
+    repo.add_package(demo_011)
+
+    pendulum_200 = get_package("pendulum", "2.0.0")
+    pendulum_200.description = "Pendulum package"
+    repo.add_package(pendulum_200)
+
+    # The git package is the one that gets into the lockfile.
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "demo",
+                    "version": "0.1.2",
+                    "description": "Demo package",
+                    "optional": False,
+                    "python-versions": "*",
+                    "develop": False,
+                    "source": {
+                        "type": "git",
+                        "reference": MOCK_DEFAULT_GIT_REVISION,
+                        "resolved_reference": MOCK_DEFAULT_GIT_REVISION,
+                        "url": "https://github.com/demo/demo.git",
+                    },
+                },
+                {
+                    "name": "pendulum",
+                    "version": "2.0.0",
+                    "description": "Pendulum package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"demo": [], "pendulum": []},
+            },
+        }
+    )
+
+    # Nothing needs updating, there is no confusion between the git and not-git
+    # packages.
+    tester.execute(f"--outdated {output_format}")
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = []
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = ""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_url_dependency_is_not_outdated_by_repository_package(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    demo_url = (
+        "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+    )
+    poetry.package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {"url": demo_url},
+        )
+    )
+
+    # A newer version of demo is available in the repository.
+    demo_100 = get_package("demo", "1.0.0")
+    repo.add_package(demo_100)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "demo",
+                    "version": "0.1.0",
+                    "description": "Demo package",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "source": {
+                        "type": "url",
+                        "url": demo_url,
+                    },
+                }
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "hashes": {"demo": []},
+            },
+        }
+    )
+
+    # The url dependency on demo is not made outdated by the existence of a newer
+    # version in the repository.
+    tester.execute(f"--outdated {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = []
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = ""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_top_level(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("cachy", "^0.2.0"))
+
+    cachy2 = get_package("cachy", "0.2.0")
+    cachy2.add_dependency(Factory.create_dependency("msgpack-python", ">=0.5 <0.6"))
+
+    installed.add_package(cachy2)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "cachy",
+                    "version": "0.2.0",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"msgpack-python": ">=0.5 <0.6"},
+                },
+                {
+                    "name": "msgpack-python",
+                    "version": "0.5.1",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"cachy": [], "msgpack-python": []},
+            },
+        }
+    )
+
+    tester.execute(f"--top-level {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "cachy",
+                "version": "0.2.0",
+                "description": "",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """cachy              0.2.0 \n"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_top_level_with_explicitly_defined_dependency(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    poetry.package.add_dependency(Factory.create_dependency("a", "^0.1.0"))
+    poetry.package.add_dependency(Factory.create_dependency("b", "^0.2.0"))
+
+    a = get_package("a", "0.1.0")
+    a.add_dependency(Factory.create_dependency("b", "0.2.0"))
+    b = get_package("b", "0.2.0")
+
+    installed.add_package(a)
+    installed.add_package(b)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "a",
+                    "version": "0.1.0",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {"b": "0.2.0"},
+                },
+                {
+                    "name": "b",
+                    "version": "0.2.0",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"a": [], "b": []},
+            },
+        }
+    )
+
+    tester.execute(f"--top-level {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "a",
+                "version": "0.1.0",
+                "description": "",
+                "installed_status": "installed",
+            },
+            {
+                "name": "b",
+                "version": "0.2.0",
+                "description": "",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """a 0.1.0 \nb 0.2.0 \n"""
+        assert tester.io.fetch_output() == expected
+
+
+@output_format_parametrize
+def test_show_top_level_with_extras(
+    output_format: str,
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+) -> None:
+    black_dep = Factory.create_dependency(
+        "black", {"version": "23.3.0", "extras": ["d"]}
+    )
+    poetry.package.add_dependency(black_dep)
+
+    black_package = get_package("black", "23.3.0")
+    black_package.add_dependency(
+        Factory.create_dependency(
+            "aiohttp",
+            {
+                "version": ">=3.7.4",
+                "optional": True,
+                "markers": 'extra == "d"',
+            },
+        )
+    )
+    installed.add_package(black_package)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(
+        {
+            "package": [
+                {
+                    "name": "black",
+                    "version": "23.3.0",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                    "dependencies": {
+                        "aiohttp": {
+                            "version": ">=3.7.4",
+                            "optional": True,
+                            "markers": 'extra == "d"',
+                        }
+                    },
+                },
+                {
+                    "name": "aiohttp",
+                    "version": "3.8.4",
+                    "description": "",
+                    "category": "main",
+                    "optional": False,
+                    "platform": "*",
+                    "python-versions": "*",
+                    "checksum": [],
+                },
+            ],
+            "metadata": {
+                "python-versions": "*",
+                "platform": "*",
+                "content-hash": "123456789",
+                "files": {"black": [], "aiohttp": []},
+            },
+        }
+    )
+
+    tester.execute(f"--top-level {output_format}")
+
+    expected: str | list[dict[str, str]] = ""
+    if "json" in output_format:
+        expected = [
+            {
+                "name": "black",
+                "version": "23.3.0",
+                "description": "",
+                "installed_status": "installed",
+            },
+        ]
+        assert json.loads(tester.io.fetch_output()) == expected
+    else:
+        expected = """black 23.3.0 \n"""
+        assert tester.io.fetch_output() == expected
+
+
+def test_show_error_top_level_with_tree(tester: CommandTester) -> None:
+    expected = "Error: Cannot use --tree and --top-level at the same time.\n"
+    tester.execute("--top-level --tree")
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == 1
+
+
+def test_show_error_top_level_with_single_package(tester: CommandTester) -> None:
+    expected = "Error: Cannot use --top-level when displaying a single package.\n"
+    tester.execute("--top-level some_package_name")
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == 1
+
+
+@pytest.mark.parametrize(
+    ("project_directory", "required_fixtures"),
+    [
+        (
+            "deleted_directory_dependency",
+            [],
+        ),
+    ],
+)
+def test_show_outdated_missing_directory_dependency(
+    tester: CommandTester,
+    poetry: Poetry,
+    installed: Repository,
+    repo: TestRepository,
+) -> None:
+    with (poetry.pyproject.file.path.parent / "poetry.lock").open(mode="rb") as f:
+        data = tomllib.load(f)
+
+    assert isinstance(poetry.locker, TestLocker)
+    poetry.locker.mock_lock_data(data)
+
+    poetry.package.add_dependency(
+        Factory.create_dependency(
+            "missing",
+            {"path": data["package"][0]["source"]["url"]},
+        )
+    )
+
+    with pytest.raises(ValueError, match="does not exist"):
+        tester.execute("")
+
+
+def test_show_error_invalid_output_format(
+    tester: CommandTester,
+) -> None:
+    expected = "Error: Invalid output format. Supported formats are: json, text.\n"
+    tester.execute("--format invalid")
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == 1
+
+
+def test_show_error_invalid_output_format_with_tree_option(
+    tester: CommandTester,
+) -> None:
+    expected = "Error: --tree option can only be used with the text output option.\n"
+    tester.execute("--format json --tree")
+    assert tester.io.fetch_error() == expected
+    assert tester.status_code == 1
diff --git b/tests/console/commands/test_sync.py a/tests/console/commands/test_sync.py
new file mode 100644
index 0000000..89d7e8c
--- /dev/null
+++ a/tests/console/commands/test_sync.py
@@ -0,0 +1,45 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.exceptions import CleoNoSuchOptionError
+
+from poetry.console.commands.sync import SyncCommand
+
+# import all tests from the install command
+# and run them for sync by overriding the command fixture
+from tests.console.commands.test_install import *  # noqa: F403
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+    from pytest_mock import MockerFixture
+
+
+@pytest.fixture  # type: ignore[no-redef]
+def command() -> str:
+    return "sync"
+
+
+@pytest.mark.skip("Only relevant for `poetry install`")  # type: ignore[no-redef]
+def test_sync_option_is_passed_to_the_installer() -> None:
+    """The only test from the install command that does not work for sync."""
+
+
+def test_sync_option_not_available(tester: CommandTester) -> None:
+    with pytest.raises(CleoNoSuchOptionError):
+        tester.execute("--sync")
+
+
+def test_synced_installer(tester: CommandTester, mocker: MockerFixture) -> None:
+    assert isinstance(tester.command, SyncCommand)
+    mock = mocker.patch(
+        "poetry.console.commands.install.InstallCommand.installer",
+        new_callable=mocker.PropertyMock,
+    )
+
+    tester.execute()
+
+    mock.return_value.requires_synchronization.assert_called_with(True)
diff --git b/tests/console/commands/test_update.py a/tests/console/commands/test_update.py
new file mode 100644
index 0000000..6b48071
--- /dev/null
+++ a/tests/console/commands/test_update.py
@@ -0,0 +1,102 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.console.commands.update import UpdateCommand
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from tests.helpers import TestRepository
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def poetry_with_outdated_lockfile(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    source = fixture_dir("outdated_lock")
+
+    return project_factory(
+        name="foobar",
+        pyproject_content=(source / "pyproject.toml").read_text(encoding="utf-8"),
+        poetry_lock_content=(source / "poetry.lock").read_text(encoding="utf-8"),
+    )
+
+
+@pytest.mark.parametrize(
+    "command",
+    [
+        "--dry-run",
+        "docker --dry-run",
+    ],
+)
+def test_update_with_dry_run_keep_files_intact(
+    command: str,
+    poetry_with_outdated_lockfile: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    tester = command_tester_factory("update", poetry=poetry_with_outdated_lockfile)
+
+    original_pyproject_content = poetry_with_outdated_lockfile.file.read()
+    original_lockfile_content = poetry_with_outdated_lockfile._locker.lock_data
+
+    repo.add_package(get_package("docker", "4.3.0"))
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    tester.execute(command)
+
+    assert poetry_with_outdated_lockfile.file.read() == original_pyproject_content
+    assert poetry_with_outdated_lockfile._locker.lock_data == original_lockfile_content
+
+
+@pytest.mark.parametrize(
+    ("command", "expected"),
+    [
+        ("", True),
+        ("--dry-run", True),
+        ("--lock", False),
+    ],
+)
+def test_update_prints_operations(
+    command: str,
+    expected: bool,
+    poetry_with_outdated_lockfile: Poetry,
+    repo: TestRepository,
+    command_tester_factory: CommandTesterFactory,
+) -> None:
+    tester = command_tester_factory("update", poetry=poetry_with_outdated_lockfile)
+
+    repo.add_package(get_package("docker", "4.3.0"))
+    repo.add_package(get_package("docker", "4.3.1"))
+
+    tester.execute(command)
+    output = tester.io.fetch_output()
+
+    assert ("Package operations:" in output) is expected
+    assert ("Installing docker (4.3.1)" in output) is expected
+
+
+def test_update_sync_option_is_passed_to_the_installer(
+    poetry_with_outdated_lockfile: Poetry,
+    command_tester_factory: CommandTesterFactory,
+    mocker: MockerFixture,
+) -> None:
+    """
+    The --sync option is passed properly to the installer from update.
+    """
+    tester = command_tester_factory("update", poetry=poetry_with_outdated_lockfile)
+    assert isinstance(tester.command, UpdateCommand)
+    mocker.patch.object(tester.command.installer, "run", return_value=1)
+
+    tester.execute("--sync")
+
+    assert tester.command.installer._requires_synchronization
diff --git b/tests/console/commands/test_version.py a/tests/console/commands/test_version.py
new file mode 100644
index 0000000..5741cf3
--- /dev/null
+++ a/tests/console/commands/test_version.py
@@ -0,0 +1,134 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.console.commands.version import VersionCommand
+
+
+if TYPE_CHECKING:
+    from cleo.testers.command_tester import CommandTester
+
+    from poetry.poetry import Poetry
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture()
+def command() -> VersionCommand:
+    return VersionCommand()
+
+
+@pytest.fixture
+def tester(command_tester_factory: CommandTesterFactory) -> CommandTester:
+    return command_tester_factory("version")
+
+
+@pytest.fixture
+def poetry_with_underscore(
+    project_factory: ProjectFactory, fixture_dir: FixtureDirGetter
+) -> Poetry:
+    source = fixture_dir("simple_project")
+    pyproject_content = (source / "pyproject.toml").read_text(encoding="utf-8")
+    pyproject_content = pyproject_content.replace("simple-project", "simple_project")
+    return project_factory(
+        "project_with_underscore", pyproject_content=pyproject_content
+    )
+
+
+@pytest.mark.parametrize(
+    "version, rule, expected",
+    [
+        ("0.0.0", "patch", "0.0.1"),
+        ("0.0.0", "minor", "0.1.0"),
+        ("0.0.0", "major", "1.0.0"),
+        ("0.0", "major", "1.0"),
+        ("0.0", "minor", "0.1"),
+        ("0.0", "patch", "0.0.1"),
+        ("1.2.3", "patch", "1.2.4"),
+        ("1.2.3", "minor", "1.3.0"),
+        ("1.2.3", "major", "2.0.0"),
+        ("1.2.3", "prepatch", "1.2.4a0"),
+        ("1.2.3", "preminor", "1.3.0a0"),
+        ("1.2.3", "premajor", "2.0.0a0"),
+        ("1.2.3-beta.1", "patch", "1.2.3"),
+        ("1.2.3-beta.1", "minor", "1.3.0"),
+        ("1.2.3-beta.1", "major", "2.0.0"),
+        ("1.2.3-beta.1", "prerelease", "1.2.3b2"),
+        ("1.2.3-beta1", "prerelease", "1.2.3b2"),
+        ("1.2.3beta1", "prerelease", "1.2.3b2"),
+        ("1.2.3b1", "prerelease", "1.2.3b2"),
+        ("1.2.3", "prerelease", "1.2.4a0"),
+        ("0.0.0", "1.2.3", "1.2.3"),
+    ],
+)
+def test_increment_version(
+    version: str, rule: str, expected: str, command: VersionCommand
+) -> None:
+    assert command.increment_version(version, rule).text == expected
+
+
+@pytest.mark.parametrize(
+    "version, rule, expected",
+    [
+        ("1.2.3", "prerelease", "1.2.4a0"),
+        ("1.2.3a0", "prerelease", "1.2.3b0"),
+        ("1.2.3a1", "prerelease", "1.2.3b0"),
+        ("1.2.3b1", "prerelease", "1.2.3rc0"),
+        ("1.2.3rc0", "prerelease", "1.2.3"),
+        ("1.2.3-beta.1", "prerelease", "1.2.3rc0"),
+        ("1.2.3-beta1", "prerelease", "1.2.3rc0"),
+        ("1.2.3beta1", "prerelease", "1.2.3rc0"),
+    ],
+)
+def test_next_phase_version(
+    version: str, rule: str, expected: str, command: VersionCommand
+) -> None:
+    assert command.increment_version(version, rule, True).text == expected
+
+
+def test_version_show(tester: CommandTester) -> None:
+    tester.execute()
+    assert tester.io.fetch_output() == "simple-project 1.2.3\n"
+
+
+def test_version_show_with_underscore(
+    command_tester_factory: CommandTesterFactory, poetry_with_underscore: Poetry
+) -> None:
+    tester = command_tester_factory("version", poetry=poetry_with_underscore)
+    tester.execute()
+    assert tester.io.fetch_output() == "simple_project 1.2.3\n"
+
+
+def test_short_version_show(tester: CommandTester) -> None:
+    tester.execute("--short")
+    assert tester.io.fetch_output() == "1.2.3\n"
+
+
+def test_version_update(tester: CommandTester) -> None:
+    tester.execute("2.0.0")
+    assert tester.io.fetch_output() == "Bumping version from 1.2.3 to 2.0.0\n"
+
+
+def test_short_version_update(tester: CommandTester) -> None:
+    tester.execute("--short 2.0.0")
+    assert tester.io.fetch_output() == "2.0.0\n"
+
+
+def test_phase_version_update(tester: CommandTester) -> None:
+    assert isinstance(tester.command, VersionCommand)
+    tester.command.poetry.package._set_version("1.2.4a0")
+    tester.execute("prerelease --next-phase")
+    assert tester.io.fetch_output() == "Bumping version from 1.2.4a0 to 1.2.4b0\n"
+
+
+def test_dry_run(tester: CommandTester) -> None:
+    assert isinstance(tester.command, VersionCommand)
+    old_pyproject = tester.command.poetry.file.path.read_text(encoding="utf-8")
+    tester.execute("--dry-run major")
+
+    new_pyproject = tester.command.poetry.file.path.read_text(encoding="utf-8")
+    assert tester.io.fetch_output() == "Bumping version from 1.2.3 to 2.0.0\n"
+    assert old_pyproject == new_pyproject
diff --git b/tests/console/conftest.py a/tests/console/conftest.py
new file mode 100644
index 0000000..11b7a3d
--- /dev/null
+++ a/tests/console/conftest.py
@@ -0,0 +1,165 @@
+from __future__ import annotations
+
+import os
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.io.null_io import NullIO
+from cleo.testers.application_tester import ApplicationTester
+from cleo.testers.command_tester import CommandTester
+
+from poetry.installation import Installer
+from poetry.utils.env import MockEnv
+from tests.helpers import MOCK_DEFAULT_GIT_REVISION
+from tests.helpers import PoetryTestApplication
+from tests.helpers import TestExecutor
+from tests.helpers import mock_clone
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+    from pathlib import Path
+
+    from pytest_mock import MockerFixture
+
+    from poetry.installation.executor import Executor
+    from poetry.poetry import Poetry
+    from poetry.repositories import Repository
+    from poetry.utils.env import Env
+    from tests.conftest import Config
+    from tests.types import CommandTesterFactory
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def env(tmp_path: Path) -> MockEnv:
+    path = tmp_path / ".venv"
+    path.mkdir(parents=True)
+    return MockEnv(path=path, is_venv=True)
+
+
+@pytest.fixture(autouse=True)
+def setup(
+    mocker: MockerFixture,
+    installed: Repository,
+    config: Config,
+    env: MockEnv,
+) -> Iterator[None]:
+    # Do not run pip commands of the executor
+    mocker.patch("poetry.installation.executor.Executor.run_pip")
+
+    p = mocker.patch("poetry.installation.installer.Installer._get_installed")
+    p.return_value = installed
+
+    p = mocker.patch(
+        "poetry.repositories.installed_repository.InstalledRepository.load"
+    )
+    p.return_value = installed
+
+    # Patch git module to not actually clone projects
+    mocker.patch("poetry.vcs.git.Git.clone", new=mock_clone)
+    p = mocker.patch("poetry.vcs.git.Git.get_revision")
+    p.return_value = MOCK_DEFAULT_GIT_REVISION
+
+    # Patch the virtual environment creation do actually do nothing
+    mocker.patch("poetry.utils.env.EnvManager.create_venv", return_value=env)
+
+    # Patch the virtual environment creation do actually do nothing
+    mocker.patch("poetry.utils.env.EnvManager.create_venv", return_value=env)
+
+    # Setting terminal width
+    environ = dict(os.environ)
+    os.environ["COLUMNS"] = "80"
+
+    yield
+
+    os.environ.clear()
+    os.environ.update(environ)
+
+
+@pytest.fixture
+def project_directory() -> str:
+    return "simple_project"
+
+
+@pytest.fixture
+def poetry(
+    project_directory: str,
+    project_factory: ProjectFactory,
+    fixture_dir: FixtureDirGetter,
+) -> Poetry:
+    return project_factory(name="simple", source=fixture_dir(project_directory))
+
+
+@pytest.fixture
+def app(poetry: Poetry) -> PoetryTestApplication:
+    app_ = PoetryTestApplication(poetry)
+    io = NullIO()
+    app_._load_plugins(io)
+    return app_
+
+
+@pytest.fixture
+def app_tester(app: PoetryTestApplication) -> ApplicationTester:
+    return ApplicationTester(app)
+
+
+@pytest.fixture()
+def executor(poetry: Poetry, config: Config, env: MockEnv) -> TestExecutor:
+    return TestExecutor(env, poetry.pool, config, NullIO())
+
+
+@pytest.fixture
+def command_tester_factory(
+    app: PoetryTestApplication, env: MockEnv
+) -> CommandTesterFactory:
+    def _tester(
+        command: str,
+        poetry: Poetry | None = None,
+        installer: Installer | None = None,
+        executor: Executor | None = None,
+        environment: Env | None = None,
+    ) -> CommandTester:
+        command_obj = app.find(command)
+        tester = CommandTester(command_obj)
+
+        # Setting the formatter from the application
+        # TODO: Find a better way to do this in Cleo
+        app_io = app.create_io()
+        formatter = app_io.output.formatter
+        tester.io.output.set_formatter(formatter)
+        tester.io.error_output.set_formatter(formatter)
+
+        if poetry:
+            app._poetry = poetry
+
+        poetry = app.poetry
+
+        if hasattr(command_obj, "set_env"):
+            command_obj.set_env(environment or env)
+
+        if hasattr(command_obj, "set_installer"):
+            installer = installer or Installer(
+                tester.io,
+                env,
+                poetry.package,
+                poetry.locker,
+                poetry.pool,
+                poetry.config,
+                executor=executor
+                or TestExecutor(env, poetry.pool, poetry.config, tester.io),
+            )
+            command_obj.set_installer(installer)
+
+        return tester
+
+    return _tester
+
+
+@pytest.fixture
+def do_lock(command_tester_factory: CommandTesterFactory, poetry: Poetry) -> None:
+    command_tester_factory("lock").execute()
+    assert poetry.locker.lock.exists()
diff --git b/tests/console/logging/formatters/test_builder_formatter.py a/tests/console/logging/formatters/test_builder_formatter.py
new file mode 100644
index 0000000..bf0b96c
--- /dev/null
+++ a/tests/console/logging/formatters/test_builder_formatter.py
@@ -0,0 +1,29 @@
+from __future__ import annotations
+
+import pytest
+
+from poetry.console.logging.formatters.builder_formatter import BuilderLogFormatter
+
+
+@pytest.mark.parametrize(
+    "input_msg, expected_output",
+    [
+        ("Building package", "  - Building <info>package</info>"),
+        ("Built package", "  - Built <success>package</success>"),
+        ("Adding: dependency", "  - Adding: <b>dependency</b>"),
+        (
+            "Executing build script: setup.py",
+            "  - Executing build script: <b>setup.py</b>",
+        ),
+        ("Some other message", "Some other message"),  # No formatting should be applied
+        ("", ""),  # Edge case: Empty string
+        (
+            "  Building package  ",
+            "  Building package  ",
+        ),  # Edge case: Whitespace handling
+        ("building package", "building package"),  # Edge case: Case sensitivity
+    ],
+)
+def test_builder_log_formatter(input_msg: str, expected_output: str) -> None:
+    formatter = BuilderLogFormatter()
+    assert formatter.format(input_msg) == expected_output
diff --git b/tests/console/logging/test_io_formatter.py a/tests/console/logging/test_io_formatter.py
new file mode 100644
index 0000000..78ffcc2
--- /dev/null
+++ a/tests/console/logging/test_io_formatter.py
@@ -0,0 +1,85 @@
+from __future__ import annotations
+
+from logging import LogRecord
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.console.logging.io_formatter import IOFormatter
+from poetry.console.logging.io_formatter import _log_prefix
+from poetry.console.logging.io_formatter import _path_to_package
+
+
+if TYPE_CHECKING:
+    from pytest_mock import MockerFixture
+
+
+@pytest.mark.parametrize(
+    ("record_name", "record_pathname", "record_msg", "expected"),
+    [
+        ("poetry", "foo/bar.py", "msg", "msg"),
+        ("poetry.core", "foo/bar.py", "msg", "msg"),
+        ("baz", "syspath/foo/bar.py", "msg", "[foo:baz] msg"),
+        ("root", "syspath/foo/bar.py", "1\n\n2", "[foo] 1\n[foo] \n[foo] 2"),
+    ],
+)
+def test_format(
+    mocker: MockerFixture,
+    record_name: str,
+    record_pathname: str,
+    record_msg: str,
+    expected: str,
+) -> None:
+    mocker.patch("sys.path", [str(Path("syspath"))])
+    record = LogRecord(record_name, 0, record_pathname, 0, record_msg, (), None)
+    formatter = IOFormatter()
+    assert formatter.format(record) == expected
+
+
+@pytest.mark.parametrize(
+    ("record_name", "record_pathname", "expected"),
+    [
+        ("root", "syspath/foo/bar.py", "foo"),
+        ("baz", "syspath/foo/bar.py", "foo:baz"),
+        ("baz", "unexpected/foo/bar.py", "bar:baz"),
+    ],
+)
+def test_log_prefix(
+    mocker: MockerFixture,
+    record_name: str,
+    record_pathname: str,
+    expected: str,
+) -> None:
+    mocker.patch("sys.path", [str(Path("syspath"))])
+    record = LogRecord(record_name, 0, record_pathname, 0, "msg", (), None)
+    assert _log_prefix(record) == expected
+
+
+@pytest.mark.parametrize(
+    ("path", "expected"),
+    [
+        ("python-l/lib/python3.9/site-packages/foo/bar/baz.py", "foo"),  # Linux
+        ("python-w/lib/site-packages/foo/bar/baz.py", "foo"),  # Windows
+        ("unexpected/foo/bar/baz.py", None),  # unexpected
+    ],
+)
+def test_path_to_package(
+    mocker: MockerFixture, path: str, expected: str | None
+) -> None:
+    mocker.patch(
+        "sys.path",
+        # We just put the Linux and the Windows variants in the path,
+        # so we do not have to create different mocks based on the subtest.
+        [
+            # On Linux, only the site-packages directory is in the path.
+            str(Path("python-l/lib/python3.9/site-packages")),
+            # On Windows, both the base directory and the site-packages directory
+            # are in the path.
+            str(Path("python-w")),
+            str(Path("python-w/other")),  # this one is just to test for robustness
+            str(Path("python-w/lib/site-packages")),
+            str(Path("python-w/lib")),  # this one is just to test for robustness
+        ],
+    )
+    assert _path_to_package(Path(path)) == expected
diff --git b/tests/console/test_application.py a/tests/console/test_application.py
new file mode 100644
index 0000000..ed52ba8
--- /dev/null
+++ a/tests/console/test_application.py
@@ -0,0 +1,247 @@
+from __future__ import annotations
+
+import re
+import shutil
+
+from typing import TYPE_CHECKING
+from typing import ClassVar
+from typing import cast
+
+import pytest
+
+from cleo.testers.application_tester import ApplicationTester
+
+from poetry.console.application import Application
+from poetry.console.commands.command import Command
+from poetry.plugins.application_plugin import ApplicationPlugin
+from poetry.plugins.plugin_manager import ProjectPluginCache
+from poetry.repositories.cached_repository import CachedRepository
+from poetry.utils.authenticator import Authenticator
+from poetry.utils.env import EnvManager
+from poetry.utils.env import MockEnv
+from tests.helpers import mock_metadata_entry_points
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from cleo.io.inputs.argv_input import ArgvInput
+    from pytest_mock import MockerFixture
+
+    from tests.helpers import PoetryTestApplication
+    from tests.types import FixtureDirGetter
+    from tests.types import SetProjectContext
+
+
+class FooCommand(Command):
+    name = "foo"
+
+    description = "Foo Command"
+
+    def handle(self) -> int:
+        self.line("foo called")
+
+        return 0
+
+
+class AddCommandPlugin(ApplicationPlugin):
+    commands: ClassVar[list[type[Command]]] = [FooCommand]
+
+
+@pytest.fixture
+def with_add_command_plugin(mocker: MockerFixture) -> None:
+    mock_metadata_entry_points(mocker, AddCommandPlugin)
+
+
+def test_application_with_plugins(with_add_command_plugin: None) -> None:
+    app = Application()
+
+    tester = ApplicationTester(app)
+    tester.execute("")
+
+    assert re.search(r"\s+foo\s+Foo Command", tester.io.fetch_output()) is not None
+    assert tester.status_code == 0
+
+
+def test_application_with_plugins_disabled(with_add_command_plugin: None) -> None:
+    app = Application()
+
+    tester = ApplicationTester(app)
+    tester.execute("--no-plugins")
+
+    assert re.search(r"\s+foo\s+Foo Command", tester.io.fetch_output()) is None
+    assert tester.status_code == 0
+
+
+def test_application_execute_plugin_command(with_add_command_plugin: None) -> None:
+    app = Application()
+
+    tester = ApplicationTester(app)
+    tester.execute("foo")
+
+    assert tester.io.fetch_output() == "foo called\n"
+    assert tester.status_code == 0
+
+
+def test_application_execute_plugin_command_with_plugins_disabled(
+    with_add_command_plugin: None,
+) -> None:
+    app = Application()
+
+    tester = ApplicationTester(app)
+    tester.execute("foo --no-plugins")
+
+    assert tester.io.fetch_output() == ""
+    assert "The requested command foo does not exist." in tester.io.fetch_error()
+    assert tester.status_code == 1
+
+
+@pytest.mark.parametrize("with_project_plugins", [False, True])
+@pytest.mark.parametrize("no_plugins", [False, True])
+def test_application_project_plugins(
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    no_plugins: bool,
+    with_project_plugins: bool,
+    mocker: MockerFixture,
+    set_project_context: SetProjectContext,
+) -> None:
+    env = MockEnv(
+        path=tmp_path / "env", version_info=(3, 8, 0), sys_path=[str(tmp_path / "env")]
+    )
+    mocker.patch.object(EnvManager, "get_system_env", return_value=env)
+
+    orig_dir = fixture_dir("project_plugins")
+    project_path = tmp_path / "project"
+    project_path.mkdir()
+    shutil.copy(orig_dir / "pyproject.toml", project_path / "pyproject.toml")
+    project_plugin_path = project_path / ProjectPluginCache.PATH
+    if with_project_plugins:
+        project_plugin_path.mkdir(parents=True)
+
+    with set_project_context(project_path, in_place=True):
+        app = Application()
+
+        tester = ApplicationTester(app)
+        tester.execute("--no-plugins" if no_plugins else "")
+
+    assert tester.status_code == 0
+    sys_path = EnvManager.get_system_env(naive=True).sys_path
+    if with_project_plugins and not no_plugins:
+        assert sys_path[0] == str(project_plugin_path)
+    else:
+        assert sys_path[0] != str(project_plugin_path)
+
+
+@pytest.mark.parametrize("disable_cache", [True, False])
+def test_application_verify_source_cache_flag(
+    disable_cache: bool, set_project_context: SetProjectContext
+) -> None:
+    with set_project_context("sample_project"):
+        app = Application()
+
+        tester = ApplicationTester(app)
+        command = "debug info"
+
+        if disable_cache:
+            command = f"{command} --no-cache"
+
+        assert not app._poetry
+
+        tester.execute(command)
+
+        assert app.poetry.pool.repositories
+
+        for repo in app.poetry.pool.repositories:
+            assert isinstance(repo, CachedRepository)
+            assert repo._disable_cache == disable_cache
+
+
+@pytest.mark.parametrize("disable_cache", [True, False])
+def test_application_verify_cache_flag_at_install(
+    mocker: MockerFixture,
+    disable_cache: bool,
+    set_project_context: SetProjectContext,
+) -> None:
+    import poetry.utils.authenticator
+
+    # Set default authenticator to None so that it is recreated for each test
+    # and we get a consistent call_count.
+    poetry.utils.authenticator._authenticator = None
+
+    with set_project_context("sample_project"):
+        app = Application()
+
+        tester = ApplicationTester(app)
+        command = "install --dry-run"
+
+        if disable_cache:
+            command = f"{command} --no-cache"
+
+        spy = mocker.spy(Authenticator, "__init__")
+
+        tester.execute(command)
+
+        # The third call is the default authenticator, which ignores the cache flag.
+        assert spy.call_count == 3
+        for call in spy.mock_calls[:2]:
+            (name, args, kwargs) = call
+            assert "disable_cache" in kwargs
+            assert disable_cache is kwargs["disable_cache"]
+
+
+@pytest.mark.parametrize(
+    ("tokens", "result"),
+    [
+        (
+            ["-C", "/path/working/dir", "env", "list"],
+            ["--directory", "/path/working/dir", "env", "list"],
+        ),
+        (
+            ["-P", "/path/project/dir", "env", "list"],
+            ["--project", "/path/project/dir", "env", "list"],
+        ),
+        (
+            ["-P/path/project/dir", "env", "list"],
+            ["--project", "/path/project/dir", "env", "list"],
+        ),
+        (
+            ["-P/path/project/dir", "env", "list"],
+            ["--project", "/path/project/dir", "env", "list"],
+        ),
+        (
+            ["-v", "run", "-P/path/project/dir", "echo", "--help"],
+            [
+                "--verbose",
+                "--project",
+                "/path/project/dir",
+                "run",
+                "--",
+                "echo",
+                "--help",
+            ],
+        ),
+        (
+            ["--no-ansi", "run", "-V", "python", "-V"],
+            ["--version", "--no-ansi", "run", "--", "python", "-V"],
+        ),
+        (
+            ["--no-ansi", "run", "-V", "--", "python", "-V"],
+            ["--version", "--no-ansi", "run", "--", "python", "-V"],
+        ),
+    ],
+)
+def test_application_input_configuration_and_sorting(
+    tokens: list[str], result: list[str], app: PoetryTestApplication
+) -> None:
+    app.create_io()
+    assert app._io is not None
+
+    io_input = cast("ArgvInput", app._io.input)
+    io_input._tokens = tokens
+
+    app._configure_io(app._io)
+    app._sort_global_options(app._io)
+
+    io_input = cast("ArgvInput", app._io.input)
+    assert io_input._tokens == result
diff --git b/tests/console/test_application_command_not_found.py a/tests/console/test_application_command_not_found.py
new file mode 100644
index 0000000..7b64eb1
--- /dev/null
+++ a/tests/console/test_application_command_not_found.py
@@ -0,0 +1,63 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.testers.application_tester import ApplicationTester
+
+from poetry.console.application import Application
+
+
+if TYPE_CHECKING:
+    from tests.types import CommandFactory
+
+
+@pytest.fixture
+def tester() -> ApplicationTester:
+    return ApplicationTester(Application())
+
+
+@pytest.mark.parametrize(
+    ("command", "suggested"),
+    [
+        ("x", None),
+        ("en", ["env activate", "env info", "env list", "env remove", "env use"]),
+        ("sou", ["source add", "source remove", "source show"]),
+    ],
+)
+def test_application_command_not_found_messages(
+    command: str,
+    suggested: list[str] | None,
+    tester: ApplicationTester,
+    command_factory: CommandFactory,
+) -> None:
+    tester.execute(f"{command}")
+    assert tester.status_code != 0
+
+    stderr = tester.io.fetch_error()
+    assert f"The requested command {command} does not exist." in stderr
+
+    if suggested is None:
+        assert "Did you mean one of these perhaps?" not in stderr
+    else:
+        for suggestion in suggested:
+            assert suggestion in stderr
+
+
+@pytest.mark.parametrize(
+    "namespace",
+    ["cache", "debug", "env", "self", "source"],
+)
+def test_application_namespaced_command_not_found_messages(
+    namespace: str,
+    tester: ApplicationTester,
+    command_factory: CommandFactory,
+) -> None:
+    tester.execute(f"{namespace} xxx")
+    assert tester.status_code != 0
+
+    stderr = tester.io.fetch_error()
+    assert (
+        f"The requested command does not exist in the {namespace} namespace." in stderr
+    )
diff --git b/tests/console/test_application_removed_commands.py a/tests/console/test_application_removed_commands.py
new file mode 100644
index 0000000..39ed699
--- /dev/null
+++ a/tests/console/test_application_removed_commands.py
@@ -0,0 +1,71 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from cleo.testers.application_tester import ApplicationTester
+
+from poetry.console.application import COMMAND_NOT_FOUND_PREFIX_MESSAGE
+from poetry.console.application import Application
+
+
+if TYPE_CHECKING:
+    from tests.types import CommandFactory
+
+
+@pytest.fixture
+def tester() -> ApplicationTester:
+    return ApplicationTester(Application())
+
+
+def test_application_removed_command_default_message(
+    tester: ApplicationTester,
+) -> None:
+    tester.execute("nonexistent")
+    assert tester.status_code != 0
+
+    stderr = tester.io.fetch_error()
+    assert COMMAND_NOT_FOUND_PREFIX_MESSAGE not in stderr
+    assert "The requested command nonexistent does not exist." in stderr
+
+
+@pytest.mark.parametrize(
+    ("command", "message"),
+    [
+        ("shell", "shell command is not installed by default"),
+    ],
+)
+def test_application_removed_command_messages(
+    command: str,
+    message: str,
+    tester: ApplicationTester,
+    command_factory: CommandFactory,
+) -> None:
+    # ensure precondition is met
+    assert not tester.application.has(command)
+
+    # verify that the custom message is returned and command fails
+    tester.execute(command)
+    assert tester.status_code != 0
+
+    stderr = tester.io.fetch_error()
+    assert COMMAND_NOT_FOUND_PREFIX_MESSAGE in stderr
+    assert message in stderr
+
+    # flush any output/error messages to ensure consistency
+    tester.io.clear()
+
+    # add a mock command and verify the command succeeds and no error message is provided
+    message = "The shell command was called"
+    tester.application.add(command_factory(command, command_handler=message))
+    assert tester.application.has(command)
+
+    tester.execute(command)
+    assert tester.status_code == 0
+
+    stdout = tester.io.fetch_output()
+    stderr = tester.io.fetch_error()
+    assert message in stdout
+    assert COMMAND_NOT_FOUND_PREFIX_MESSAGE not in stderr
+    assert stderr == ""
diff --git b/tests/console/test_exceptions_console_message.py a/tests/console/test_exceptions_console_message.py
new file mode 100644
index 0000000..6c30244
--- /dev/null
+++ a/tests/console/test_exceptions_console_message.py
@@ -0,0 +1,68 @@
+from __future__ import annotations
+
+import pytest
+
+from poetry.console.exceptions import ConsoleMessage
+
+
+@pytest.mark.parametrize(
+    ("text", "expected_stripped"),
+    [
+        ("<info>Hello, World!</info>", "Hello, World!"),
+        ("<b>Bold</b>", "Bold"),
+        ("<i>Italic</i>", "Italic"),
+    ],
+)
+def test_stripped_property(text: str, expected_stripped: str) -> None:
+    """Test the stripped property with various tagged inputs."""
+    message = ConsoleMessage(text)
+    assert message.stripped == expected_stripped
+
+
+@pytest.mark.parametrize(
+    ("text", "tag", "expected"),
+    [
+        ("Hello, World!", "info", "<info>Hello, World!</>"),
+        ("Error occurred", "error", "<error>Error occurred</>"),
+        ("", "info", ""),  # Test with empty input
+    ],
+)
+def test_wrap(text: str, tag: str, expected: str) -> None:
+    """Test the wrap method with various inputs."""
+    message = ConsoleMessage(text)
+    assert message.wrap(tag).text == expected
+
+
+@pytest.mark.parametrize(
+    ("text", "indent", "expected"),
+    [
+        ("Hello, World!", "    ", "    Hello, World!"),
+        ("Line 1\nLine 2", ">>", ">>Line 1\n>>Line 2"),
+        ("", "  ", ""),  # Test with empty input
+        (" ", "  ", "  "),  # Test with whitespace input
+    ],
+)
+def test_indent(text: str, indent: str, expected: str) -> None:
+    """Test the indent method with various inputs."""
+    message = ConsoleMessage(text)
+    assert message.indent(indent).text == expected
+
+
+@pytest.mark.parametrize(
+    ("text", "title", "indent", "expected"),
+    [
+        ("Hello, World!", "Greeting", "", "<b>Greeting:</>\nHello, World!"),
+        (
+            "This is a message.",
+            "Section Title",
+            "  ",
+            "<b>Section Title:</>\n  This is a message.",
+        ),
+        ("", "Title", "", ""),  # Test with empty text
+        ("Multi-line\nText", "Title", ">>>", "<b>Title:</>\n>>>Multi-line\n>>>Text"),
+    ],
+)
+def test_make_section(text: str, title: str, indent: str, expected: str) -> None:
+    """Test the make_section method with various inputs."""
+    message = ConsoleMessage(text)
+    assert message.make_section(title, indent).text == expected
diff --git b/tests/console/test_exections_poetry_runtime_error.py a/tests/console/test_exections_poetry_runtime_error.py
new file mode 100644
index 0000000..e2acb93
--- /dev/null
+++ a/tests/console/test_exections_poetry_runtime_error.py
@@ -0,0 +1,148 @@
+from __future__ import annotations
+
+from subprocess import CalledProcessError
+
+import pytest
+
+from poetry.console.exceptions import ConsoleMessage
+from poetry.console.exceptions import PoetryRuntimeError
+
+
+@pytest.mark.parametrize(
+    ("reason", "messages", "exit_code", "expected_reason"),
+    [
+        ("Error occurred!", None, 1, "Error occurred!"),  # Default scenario
+        (
+            "Specific error",
+            [ConsoleMessage("Additional details.")],
+            2,
+            "Specific error",
+        ),  # Custom exit code and messages
+        ("Minimal error", [], 0, "Minimal error"),  # No additional messages
+    ],
+)
+def test_poetry_runtime_error_init(
+    reason: str,
+    messages: list[ConsoleMessage] | None,
+    exit_code: int,
+    expected_reason: str,
+) -> None:
+    """Test the basic initialization of the PoetryRuntimeError class."""
+    error = PoetryRuntimeError(reason, messages, exit_code)
+    assert error.exit_code == exit_code
+    assert str(error) == expected_reason
+    assert isinstance(error._messages[0], ConsoleMessage)
+    assert error._messages[0].text == reason
+
+
+@pytest.mark.parametrize(
+    ("debug", "strip", "indent", "messages", "expected_text"),
+    [
+        (
+            False,
+            False,
+            "",
+            [
+                ConsoleMessage("Basic message"),
+                ConsoleMessage("Debug message", debug=True),
+            ],
+            "Error\n\nBasic message\n\nYou can also run your <c1>poetry</> command with <c1>-v</> to see more information.",
+        ),  # Debug message ignored
+        (
+            True,
+            False,
+            "",
+            [
+                ConsoleMessage("Info message"),
+                ConsoleMessage("Debug message", debug=True),
+            ],
+            "Error\n\nInfo message\n\nDebug message",
+        ),  # Debug message included in verbose mode
+        (
+            True,
+            True,
+            "",
+            [
+                ConsoleMessage("<b>Bolded message</b>"),
+                ConsoleMessage("<i>Debug Italics Message</i>", debug=True),
+            ],
+            "Error\n\nBolded message\n\nDebug Italics Message",
+        ),  # Stripped tags and debug message
+        (
+            False,
+            False,
+            "    ",
+            [ConsoleMessage("Error occurred!")],
+            "    Error\n    \n    Error occurred!",
+        ),  # Indented message
+    ],
+)
+def test_poetry_runtime_error_get_text(
+    debug: bool,
+    strip: bool,
+    indent: str,
+    messages: list[ConsoleMessage],
+    expected_text: str,
+) -> None:
+    """Test the get_text method of PoetryRuntimeError."""
+    error = PoetryRuntimeError("Error", messages)
+    text = error.get_text(debug=debug, strip=strip, indent=indent)
+    assert text == expected_text
+
+
+@pytest.mark.parametrize(
+    ("reason", "exception", "info", "expected_message_texts"),
+    [
+        (
+            "Command failed",
+            None,
+            None,
+            ["Command failed", ""],  # No exception or additional info
+        ),
+        (
+            "Command failure",
+            Exception("An exception occurred"),
+            None,
+            [
+                "Command failure",
+                "<b>Exception:</>\n    | An exception occurred",
+                "",
+            ],  # Exception message included
+        ),
+        (
+            "Subprocess error",
+            CalledProcessError(1, ["cmd"], b"stdout", b"stderr"),
+            ["Additional info"],
+            [
+                "Subprocess error",
+                "<warning><b>Exception:</>\n"
+                "    | Command '['cmd']' returned non-zero exit status 1.</>",
+                "<warning><b>Output:</>\n    | stdout</>",
+                "<warning><b>Errors:</>\n    | stderr</>",
+                "<info>Additional info</>",
+                "You can test the failed command by executing:\n\n    <c1>cmd</c1>",
+            ],
+        ),
+    ],
+)
+def test_poetry_runtime_error_create(
+    reason: str,
+    exception: Exception,
+    info: list[str],
+    expected_message_texts: list[str],
+) -> None:
+    """Test the create class method of PoetryRuntimeError."""
+    error = PoetryRuntimeError.create(reason, exception, info)
+
+    assert isinstance(error, PoetryRuntimeError)
+    assert all(isinstance(msg, ConsoleMessage) for msg in error._messages)
+
+    actual_texts = [msg.text for msg in error._messages]
+    assert actual_texts == expected_message_texts
+
+
+def test_poetry_runtime_error_append() -> None:
+    """Test the append method of PoetryRuntimeError."""
+    error = PoetryRuntimeError.create("Error", info=["Hello"]).append("World")
+    actual_texts = [msg.text for msg in error._messages]
+    assert actual_texts == ["Error", "<info>Hello</>", "World"]
diff --git b/tests/installation/test_chef.py a/tests/installation/test_chef.py
new file mode 100644
index 0000000..c132342
--- /dev/null
+++ a/tests/installation/test_chef.py
@@ -0,0 +1,149 @@
+from __future__ import annotations
+
+import os
+import shutil
+import tempfile
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from zipfile import ZipFile
+
+import pytest
+
+from build import ProjectBuilder
+from poetry.core.packages.utils.link import Link
+
+from poetry.factory import Factory
+from poetry.installation.chef import Chef
+from poetry.repositories import RepositoryPool
+from poetry.utils.env import EnvManager
+
+
+if TYPE_CHECKING:
+    from pytest_mock import MockerFixture
+
+    from poetry.repositories.pypi_repository import PyPiRepository
+    from poetry.utils.cache import ArtifactCache
+    from tests.conftest import Config
+    from tests.types import FixtureDirGetter
+
+
+@pytest.fixture()
+def pool(pypi_repository: PyPiRepository) -> RepositoryPool:
+    pool = RepositoryPool()
+
+    pool.add_repository(pypi_repository)
+
+    return pool
+
+
+@pytest.fixture(autouse=True)
+def setup(mocker: MockerFixture, pool: RepositoryPool) -> None:
+    mocker.patch.object(Factory, "create_pool", return_value=pool)
+
+
+def test_prepare_sdist(
+    config: Config,
+    config_cache_dir: Path,
+    artifact_cache: ArtifactCache,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    chef = Chef(
+        artifact_cache, EnvManager.get_system_env(), Factory.create_pool(config)
+    )
+    archive = (fixture_dir("distributions") / "demo-0.1.0.tar.gz").resolve()
+    destination = artifact_cache.get_cache_directory_for_link(Link(archive.as_uri()))
+
+    wheel = chef.prepare(archive)
+
+    assert wheel.parent == destination
+    assert wheel.name == "demo-0.1.0-py3-none-any.whl"
+
+
+def test_prepare_directory(
+    config: Config,
+    config_cache_dir: Path,
+    artifact_cache: ArtifactCache,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    chef = Chef(
+        artifact_cache, EnvManager.get_system_env(), Factory.create_pool(config)
+    )
+    archive = fixture_dir("simple_project_legacy").resolve()
+
+    wheel = chef.prepare(archive)
+
+    assert wheel.name == "simple_project-1.2.3-py2.py3-none-any.whl"
+
+    assert wheel.parent.parent == Path(tempfile.gettempdir())
+    # cleanup generated tmp dir artifact
+    os.unlink(wheel)
+
+
+def test_prepare_directory_editable(
+    config: Config,
+    config_cache_dir: Path,
+    artifact_cache: ArtifactCache,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    chef = Chef(
+        artifact_cache, EnvManager.get_system_env(), Factory.create_pool(config)
+    )
+    archive = fixture_dir("simple_project_legacy").resolve()
+
+    wheel = chef.prepare(archive, editable=True)
+
+    assert wheel.parent.parent == Path(tempfile.gettempdir())
+    assert wheel.name == "simple_project-1.2.3-py2.py3-none-any.whl"
+
+    with ZipFile(wheel) as z:
+        assert "simple_project.pth" in z.namelist()
+
+    # cleanup generated tmp dir artifact
+    os.unlink(wheel)
+
+
+def test_prepare_directory_script(
+    config: Config,
+    config_cache_dir: Path,
+    artifact_cache: ArtifactCache,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    mocker: MockerFixture,
+) -> None:
+    """
+    Building a project that requires calling a script from its build_requires.
+    """
+    # make sure the scripts project is on the same drive (for Windows tests in CI)
+    scripts_dir = tmp_path / "scripts"
+    shutil.copytree(fixture_dir("scripts"), scripts_dir)
+
+    orig_build_system_requires = ProjectBuilder.build_system_requires
+
+    class CustomPropertyMock:
+        def __get__(
+            self, obj: ProjectBuilder, obj_type: type[ProjectBuilder] | None = None
+        ) -> set[str]:
+            assert isinstance(obj, ProjectBuilder)
+            return {
+                req.replace("<scripts>", f"scripts @ {scripts_dir.as_uri()}")
+                for req in orig_build_system_requires.fget(obj)  # type: ignore[attr-defined]
+            }
+
+    mocker.patch(
+        "build.ProjectBuilder.build_system_requires",
+        new_callable=CustomPropertyMock,
+    )
+    chef = Chef(
+        artifact_cache, EnvManager.get_system_env(), Factory.create_pool(config)
+    )
+    archive = shutil.copytree(
+        fixture_dir("project_with_setup_calls_script").resolve(), tmp_path / "project"
+    )
+    wheel = chef.prepare(archive)
+
+    assert wheel.name == "project_with_setup_calls_script-0.1.2-py3-none-any.whl"
+
+    assert wheel.parent.parent == Path(tempfile.gettempdir())
+    # cleanup generated tmp dir artifact
+    os.unlink(wheel)
diff --git b/tests/installation/test_chooser.py a/tests/installation/test_chooser.py
new file mode 100644
index 0000000..80d2e47
--- /dev/null
+++ a/tests/installation/test_chooser.py
@@ -0,0 +1,382 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from packaging.tags import Tag
+from poetry.core.packages.package import Package
+
+from poetry.console.exceptions import PoetryRuntimeError
+from poetry.installation.chooser import Chooser
+from poetry.repositories.legacy_repository import LegacyRepository
+from poetry.utils.env import MockEnv
+
+
+if TYPE_CHECKING:
+    from poetry.repositories.repository_pool import RepositoryPool
+    from tests.conftest import Config
+    from tests.types import DistributionHashGetter
+    from tests.types import SpecializedLegacyRepositoryMocker
+
+JSON_FIXTURES = (
+    Path(__file__).parent.parent / "repositories" / "fixtures" / "pypi.org" / "json"
+)
+
+LEGACY_FIXTURES = Path(__file__).parent.parent / "repositories" / "fixtures" / "legacy"
+
+
+def check_chosen_link_filename(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    filename: str | None,
+    config: Config | None = None,
+    package_name: str = "pytest",
+    package_version: str = "3.5.0",
+) -> None:
+    chooser = Chooser(pool, env, config)
+    package = Package(package_name, package_version)
+
+    if source_type == "legacy":
+        package = Package(
+            package.name,
+            package.version.text,
+            source_type="legacy",
+            source_reference="foo",
+            source_url="https://legacy.foo.bar/simple/",
+        )
+
+    try:
+        link = chooser.choose_for(package)
+    except PoetryRuntimeError as e:
+        if filename is None:
+            assert (
+                str(e)
+                == f"Unable to find installation candidates for {package.name} ({package.version})"
+            )
+        else:
+            pytest.fail("Package was not found")
+    else:
+        assert link.filename == filename
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_universal_wheel_link_if_available(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+) -> None:
+    check_chosen_link_filename(
+        env, source_type, pool, "pytest-3.5.0-py2.py3-none-any.whl"
+    )
+
+
+@pytest.mark.parametrize(
+    ("policy", "filename"),
+    [
+        (":all:", "pytest-3.5.0.tar.gz"),
+        (":none:", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("black", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("pytest", "pytest-3.5.0.tar.gz"),
+        ("pytest,black", "pytest-3.5.0.tar.gz"),
+    ],
+)
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_no_binary_policy(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    policy: str,
+    filename: str,
+    config: Config,
+) -> None:
+    config.merge({"installer": {"no-binary": policy.split(",")}})
+    check_chosen_link_filename(env, source_type, pool, filename, config)
+
+
+@pytest.mark.parametrize(
+    ("policy", "filename"),
+    [
+        (":all:", "pytest-3.5.0-py2.py3-none-any.whl"),
+        (":none:", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("black", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("pytest", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("pytest,black", "pytest-3.5.0-py2.py3-none-any.whl"),
+    ],
+)
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_only_binary_policy(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    policy: str,
+    filename: str,
+    config: Config,
+) -> None:
+    config.merge({"installer": {"only-binary": policy.split(",")}})
+    check_chosen_link_filename(env, source_type, pool, filename, config)
+
+
+@pytest.mark.parametrize(
+    ("no_binary", "only_binary", "filename"),
+    [
+        # no `no_binary` nor `only_binary`
+        (":none:", ":none:", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("black", "black", "pytest-3.5.0-py2.py3-none-any.whl"),
+        # `no_binary` only
+        (":all:", ":none:", "pytest-3.5.0.tar.gz"),
+        ("pytest", "black", "pytest-3.5.0.tar.gz"),
+        # `only_binary` only
+        (":none:", ":all:", "pytest-3.5.0-py2.py3-none-any.whl"),
+        ("black", "pytest", "pytest-3.5.0-py2.py3-none-any.whl"),
+        # both `no_binary` and `only_binary`
+        ("pytest", "pytest", None),
+        (":all:", ":all:", None),
+        ("pytest", ":all:", "pytest-3.5.0.tar.gz"),
+        (":all:", "pytest", "pytest-3.5.0-py2.py3-none-any.whl"),
+        # complex cases
+        ("pytest,black", "pytest,black", None),
+    ],
+)
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_multiple_binary_policy(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    no_binary: str,
+    only_binary: str,
+    filename: str | None,
+    config: Config,
+) -> None:
+    config.merge(
+        {
+            "installer": {
+                "no-binary": no_binary.split(","),
+                "only-binary": only_binary.split(","),
+            }
+        }
+    )
+    check_chosen_link_filename(env, source_type, pool, filename, config)
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_specific_python_universal_wheel_link_if_available(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+) -> None:
+    check_chosen_link_filename(
+        env, source_type, pool, "isort-4.3.4-py3-none-any.whl", None, "isort", "4.3.4"
+    )
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_system_specific_wheel_link_if_available(
+    source_type: str, pool: RepositoryPool
+) -> None:
+    env = MockEnv(
+        supported_tags=[Tag("cp37", "cp37m", "win32"), Tag("py3", "none", "any")]
+    )
+    check_chosen_link_filename(
+        env,
+        source_type,
+        pool,
+        "PyYAML-3.13-cp37-cp37m-win32.whl",
+        None,
+        "pyyaml",
+        "3.13.0",
+    )
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_sdist_if_no_compatible_wheel_link_is_available(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+) -> None:
+    check_chosen_link_filename(
+        env, source_type, pool, "PyYAML-3.13.tar.gz", None, "pyyaml", "3.13.0"
+    )
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_distributions_that_match_the_package_hashes(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    dist_hash_getter: DistributionHashGetter,
+) -> None:
+    chooser = Chooser(pool, env)
+
+    package = Package("isort", "4.3.4")
+    files = [
+        {
+            "file": filename,
+            "hash": (f"sha256:{dist_hash_getter(filename).sha256}"),
+        }
+        for filename in [
+            f"{package.name}-{package.version}.tar.gz",
+        ]
+    ]
+    if source_type == "legacy":
+        package = Package(
+            package.name,
+            package.version.text,
+            source_type="legacy",
+            source_reference="foo",
+            source_url="https://legacy.foo.bar/simple/",
+        )
+
+    package.files = files
+
+    link = chooser.choose_for(package)
+
+    assert link.filename == "isort-4.3.4.tar.gz"
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_chooses_yanked_if_no_others(
+    env: MockEnv,
+    source_type: str,
+    pool: RepositoryPool,
+    dist_hash_getter: DistributionHashGetter,
+) -> None:
+    chooser = Chooser(pool, env)
+
+    package = Package("black", "21.11b0")
+    files = [
+        {
+            "filename": filename,
+            "hash": (f"sha256:{dist_hash_getter(filename).sha256}"),
+        }
+        for filename in [f"{package.name}-{package.version}-py3-none-any.whl"]
+    ]
+    if source_type == "legacy":
+        package = Package(
+            package.name,
+            package.version.text,
+            source_type="legacy",
+            source_reference="foo",
+            source_url="https://legacy.foo.bar/simple/",
+        )
+
+    package.files = files
+
+    link = chooser.choose_for(package)
+
+    assert link.filename == "black-21.11b0-py3-none-any.whl"
+    assert link.yanked
+
+
+def test_chooser_does_not_choose_yanked_if_others(
+    specialized_legacy_repository_mocker: SpecializedLegacyRepositoryMocker,
+    pool: RepositoryPool,
+    dist_hash_getter: DistributionHashGetter,
+) -> None:
+    chooser = Chooser(pool, MockEnv(supported_tags=[Tag("py2", "none", "any")]))
+
+    repo = pool.repository("foo2")
+    pool.remove_repository("foo2")
+
+    assert isinstance(repo, LegacyRepository)
+    pool.add_repository(
+        specialized_legacy_repository_mocker("-partial-yank", repo.name, repo.url)
+    )
+
+    package = Package("futures", "3.2.0")
+    files = [
+        {
+            "filename": filename,
+            "hash": (f"sha256:{dist_hash_getter(filename).sha256}"),
+        }
+        for filename in [
+            f"{package.name}-{package.version}-py2-none-any.whl",
+            f"{package.name}-{package.version}.tar.gz",
+        ]
+    ]
+    package = Package(
+        package.name,
+        package.version.text,
+        source_type="legacy",
+        source_reference="foo",
+        source_url="https://legacy.foo.bar/simple/",
+    )
+    package_partial_yank = Package(
+        package.name,
+        package.version.text,
+        source_type="legacy",
+        source_reference="foo2",
+        source_url="https://legacy.foo2.bar/simple/",
+    )
+
+    package.files = files
+    package_partial_yank.files = files
+
+    link = chooser.choose_for(package)
+    link_partial_yank = chooser.choose_for(package_partial_yank)
+
+    assert link.filename == "futures-3.2.0-py2-none-any.whl"
+    assert link_partial_yank.filename == "futures-3.2.0.tar.gz"
+
+
+@pytest.mark.parametrize("source_type", ["", "legacy"])
+def test_chooser_throws_an_error_if_package_hashes_do_not_match(
+    env: MockEnv,
+    source_type: None,
+    pool: RepositoryPool,
+) -> None:
+    chooser = Chooser(pool, env)
+
+    package = Package("isort", "4.3.4")
+    files = [
+        {
+            "hash": (
+                "sha256:0000000000000000000000000000000000000000000000000000000000000000"
+            ),
+            "filename": "isort-4.3.4.tar.gz",
+        }
+    ]
+    if source_type == "legacy":
+        package = Package(
+            package.name,
+            package.version.text,
+            source_type="legacy",
+            source_reference="foo",
+            source_url="https://legacy.foo.bar/simple/",
+        )
+
+    package.files = files
+
+    with pytest.raises(PoetryRuntimeError) as e:
+        chooser.choose_for(package)
+
+    reason = f"Downloaded distributions for {package.name} ({package.version}) did not match any known checksums in your lock file."
+    assert str(e.value) == reason
+
+    text = e.value.get_text(debug=True, strip=True)
+    assert reason in text
+    assert files[0]["hash"] in text
+
+
+def test_chooser_md5_remote_fallback_to_sha256_inline_calculation(
+    env: MockEnv, pool: RepositoryPool, dist_hash_getter: DistributionHashGetter
+) -> None:
+    chooser = Chooser(pool, env)
+    package = Package(
+        "demo",
+        "0.1.0",
+        source_type="legacy",
+        source_reference="foo",
+        source_url="https://legacy.foo.bar/simple/",
+    )
+    package.files = [
+        {
+            "filename": filename,
+            "hash": (f"sha256:{dist_hash_getter(filename).sha256}"),
+        }
+        for filename in [f"{package.name}-{package.version}.tar.gz"]
+    ]
+    res = chooser.choose_for(package)
+    assert res.filename == "demo-0.1.0.tar.gz"
diff --git b/tests/installation/test_chooser_errors.py a/tests/installation/test_chooser_errors.py
new file mode 100644
index 0000000..d4e898d
--- /dev/null
+++ a/tests/installation/test_chooser_errors.py
@@ -0,0 +1,90 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+from poetry.core.packages.package import Package
+
+from poetry.installation.chooser import Chooser
+
+
+if TYPE_CHECKING:
+    from poetry.repositories.repository_pool import RepositoryPool
+    from poetry.utils.env import MockEnv
+
+
+def test_chooser_no_links_found_error(env: MockEnv, pool: RepositoryPool) -> None:
+    chooser = Chooser(pool, env)
+    package = Package(
+        "demo",
+        "0.1.0",
+        source_type="legacy",
+        source_reference="foo",
+        source_url="https://legacy.foo.bar/simple/",
+    )
+
+    unsupported_wheels = {"demo-0.1.0-py3-none-any.whl"}
+    error = chooser._no_links_found_error(
+        package=package,
+        links_seen=4,
+        wheels_skipped=3,
+        sdists_skipped=1,
+        unsupported_wheels=unsupported_wheels,
+    )
+    assert (
+        error.get_text(debug=True, strip=True)
+        == f"""\
+Unable to find installation candidates for {package.name} ({package.version})
+
+This is likely not a Poetry issue.
+
+  - 4 candidate(s) were identified for the package
+  - 3 wheel(s) were skipped due to your installer.no-binary policy
+  - 1 source distribution(s) were skipped due to your installer.only-binary policy
+  - 1 wheel(s) were skipped as your project's environment does not support the identified abi tags
+
+The following wheel(s) were skipped as the current project environment does not support them due to abi compatibility \
+issues.
+
+  - {"  -".join(unsupported_wheels)}
+
+If you would like to see the supported tags in your project environment, you can execute the following command:
+
+    poetry debug tags
+
+Solutions:
+Make sure the lockfile is up-to-date. You can try one of the following;
+
+    1. Regenerate lockfile: poetry lock --no-cache --regenerate
+    2. Update package     : poetry update --no-cache {package.name}
+
+If neither works, please first check to verify that the {package.name} has published wheels available from your configured \
+source ({package.source_reference}) that are compatible with your environment- ie. operating system, architecture \
+(x86_64, arm64 etc.), python interpreter.\
+"""
+    )
+
+    assert (
+        error.get_text(debug=False, strip=True)
+        == f"""\
+Unable to find installation candidates for {package.name} ({package.version})
+
+This is likely not a Poetry issue.
+
+  - 4 candidate(s) were identified for the package
+  - 3 wheel(s) were skipped due to your installer.no-binary policy
+  - 1 source distribution(s) were skipped due to your installer.only-binary policy
+  - 1 wheel(s) were skipped as your project's environment does not support the identified abi tags
+
+Solutions:
+Make sure the lockfile is up-to-date. You can try one of the following;
+
+    1. Regenerate lockfile: poetry lock --no-cache --regenerate
+    2. Update package     : poetry update --no-cache {package.name}
+
+If neither works, please first check to verify that the {package.name} has published wheels available from your configured \
+source ({package.source_reference}) that are compatible with your environment- ie. operating system, architecture \
+(x86_64, arm64 etc.), python interpreter.
+
+You can also run your poetry command with -v to see more information.\
+"""
+    )
diff --git b/tests/installation/test_executor.py a/tests/installation/test_executor.py
new file mode 100644
index 0000000..da20750
--- /dev/null
+++ a/tests/installation/test_executor.py
@@ -0,0 +1,1782 @@
+from __future__ import annotations
+
+import csv
+import json
+import re
+import shutil
+import tempfile
+
+from pathlib import Path
+from subprocess import CalledProcessError
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Callable
+
+import pytest
+
+from build import BuildBackendException
+from build import ProjectBuilder
+from cleo.formatters.style import Style
+from cleo.io.buffered_io import BufferedIO
+from cleo.io.outputs.output import Verbosity
+from poetry.core.packages.package import Package
+from poetry.core.packages.utils.utils import path_to_url
+
+from poetry.factory import Factory
+from poetry.installation.chef import Chef as BaseChef
+from poetry.installation.executor import Executor
+from poetry.installation.operations import Install
+from poetry.installation.operations import Uninstall
+from poetry.installation.operations import Update
+from poetry.installation.wheel_installer import WheelInstaller
+from poetry.repositories.repository_pool import RepositoryPool
+from poetry.utils.cache import ArtifactCache
+from poetry.utils.env import MockEnv
+from poetry.vcs.git.backend import Git
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+    from collections.abc import Mapping
+    from collections.abc import Sequence
+
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from poetry.installation.operations.operation import Operation
+    from poetry.repositories.pypi_repository import PyPiRepository
+    from poetry.utils.env import VirtualEnv
+    from tests.types import FixtureDirGetter
+
+
+class Chef(BaseChef):
+    _directory_wheels: list[Path] | None = None
+    _sdist_wheels: list[Path] | None = None
+
+    def set_directory_wheel(self, wheels: Path | list[Path]) -> None:
+        if not isinstance(wheels, list):
+            wheels = [wheels]
+
+        self._directory_wheels = wheels
+
+    def set_sdist_wheel(self, wheels: Path | list[Path]) -> None:
+        if not isinstance(wheels, list):
+            wheels = [wheels]
+
+        self._sdist_wheels = wheels
+
+    def _prepare_sdist(
+        self,
+        archive: Path,
+        destination: Path | None = None,
+        config_settings: Mapping[str, str | Sequence[str]] | None = None,
+    ) -> Path:
+        if self._sdist_wheels is not None:
+            wheel = self._sdist_wheels.pop(0)
+            self._sdist_wheels.append(wheel)
+
+            return wheel
+
+        return super()._prepare_sdist(archive)
+
+    def _prepare(
+        self,
+        directory: Path,
+        destination: Path,
+        *,
+        editable: bool = False,
+        config_settings: Mapping[str, str | Sequence[str]] | None = None,
+    ) -> Path:
+        if self._directory_wheels is not None:
+            wheel = self._directory_wheels.pop(0)
+            self._directory_wheels.append(wheel)
+
+            destination.mkdir(parents=True, exist_ok=True)
+            dst_wheel = destination / wheel.name
+            shutil.copyfile(wheel, dst_wheel)
+            return dst_wheel
+
+        return super()._prepare(directory, destination, editable=editable)
+
+
+@pytest.fixture
+def env(tmp_path: Path) -> MockEnv:
+    path = tmp_path / ".venv"
+    path.mkdir(parents=True)
+
+    return MockEnv(path=path, is_venv=True)
+
+
+@pytest.fixture
+def io() -> BufferedIO:
+    io = BufferedIO()
+    io.output.formatter.set_style("c1_dark", Style("cyan", options=["dark"]))
+    io.output.formatter.set_style("c2_dark", Style("default", options=["bold", "dark"]))
+    io.output.formatter.set_style("success_dark", Style("green", options=["dark"]))
+    io.output.formatter.set_style("warning", Style("yellow"))
+
+    return io
+
+
+@pytest.fixture
+def io_decorated() -> BufferedIO:
+    io = BufferedIO(decorated=True)
+    io.output.formatter.set_style("c1", Style("cyan"))
+    io.output.formatter.set_style("success", Style("green"))
+
+    return io
+
+
+@pytest.fixture
+def io_not_decorated() -> BufferedIO:
+    io = BufferedIO(decorated=False)
+
+    return io
+
+
+@pytest.fixture
+def pool(pypi_repository: PyPiRepository) -> RepositoryPool:
+    pool = RepositoryPool()
+
+    pypi_repository._fallback = True
+    pool.add_repository(pypi_repository)
+
+    return pool
+
+
+@pytest.fixture
+def copy_wheel(tmp_path: Path, fixture_dir: FixtureDirGetter) -> Callable[[], Path]:
+    def _copy_wheel() -> Path:
+        tmp_name = tempfile.mktemp()
+        (tmp_path / tmp_name).mkdir()
+
+        shutil.copyfile(
+            fixture_dir("distributions") / "demo-0.1.2-py2.py3-none-any.whl",
+            tmp_path / tmp_name / "demo-0.1.2-py2.py3-none-any.whl",
+        )
+        return tmp_path / tmp_name / "demo-0.1.2-py2.py3-none-any.whl"
+
+    return _copy_wheel
+
+
+@pytest.fixture
+def wheel(copy_wheel: Callable[[], Path]) -> Iterator[Path]:
+    archive = copy_wheel()
+
+    yield archive
+
+    if archive.exists():
+        archive.unlink()
+
+
+def test_execute_executes_a_batch_of_operations(
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+    copy_wheel: Callable[[], Path],
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    wheel_install = mocker.patch.object(WheelInstaller, "install")
+
+    config.merge({"cache-dir": str(tmp_path)})
+    artifact_cache = ArtifactCache(cache_dir=config.artifacts_cache_directory)
+
+    prepare_spy = mocker.spy(Chef, "_prepare")
+    chef = Chef(artifact_cache, env, Factory.create_pool(config))
+    chef.set_directory_wheel([copy_wheel(), copy_wheel()])
+    chef.set_sdist_wheel(copy_wheel())
+
+    io.set_verbosity(Verbosity.VERY_VERBOSE)
+
+    executor = Executor(env, pool, config, io)
+    executor._chef = chef
+
+    file_package = Package(
+        "demo",
+        "0.1.0",
+        source_type="file",
+        source_url=(fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl")
+        .resolve()
+        .as_posix(),
+    )
+
+    directory_package = Package(
+        "simple-project",
+        "1.2.3",
+        source_type="directory",
+        source_url=fixture_dir("simple_project").resolve().as_posix(),
+    )
+
+    git_package = Package(
+        "demo",
+        "0.1.0",
+        source_type="git",
+        source_reference="master",
+        source_url="https://github.com/demo/demo.git",
+        develop=True,
+    )
+
+    return_code = executor.execute(
+        [
+            Install(Package("pytest", "3.5.1")),
+            Uninstall(Package("attrs", "17.4.0")),
+            Update(Package("requests", "2.18.3"), Package("requests", "2.18.4")),
+            Update(Package("pytest", "3.5.1"), Package("pytest", "3.5.0")),
+            Uninstall(Package("clikit", "0.2.3")).skip("Not currently installed"),
+            Install(file_package),
+            Install(directory_package),
+            Install(git_package),
+        ]
+    )
+
+    expected = f"""
+Package operations: 4 installs, 2 updates, 1 removal
+
+  - Installing pytest (3.5.1)
+  - Removing attrs (17.4.0)
+  - Updating requests (2.18.3 -> 2.18.4)
+  - Downgrading pytest (3.5.1 -> 3.5.0)
+  - Installing demo (0.1.0 {file_package.source_url})
+  - Installing simple-project (1.2.3 {directory_package.source_url})
+  - Installing demo (0.1.0 master)
+"""
+
+    expected_lines = set(expected.splitlines())
+    output_lines = set(io.fetch_output().splitlines())
+    assert output_lines == expected_lines
+    assert wheel_install.call_count == 6
+    # 3 pip uninstalls: one for the remove operation and two for the update operations
+    assert len(env.executed) == 3
+    assert return_code == 0
+
+    assert prepare_spy.call_count == 2
+    assert prepare_spy.call_args_list == [
+        mocker.call(
+            chef,
+            mocker.ANY,
+            destination=mocker.ANY,
+            editable=False,
+            config_settings=None,
+        ),
+        mocker.call(
+            chef,
+            mocker.ANY,
+            destination=mocker.ANY,
+            editable=True,
+            config_settings=None,
+        ),
+    ]
+
+
+def test_execute_build_config_settings_passed(
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+    copy_wheel: Callable[[], Path],
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    wheel_install = mocker.patch.object(WheelInstaller, "install")
+
+    config_settings_demo = {"CC": "gcc", "--build-option": ["--one", "--two"]}
+
+    config.merge(
+        {
+            "cache-dir": str(tmp_path),
+            "installer": {"build-config-settings": {"demo": config_settings_demo}},
+        }
+    )
+    artifact_cache = ArtifactCache(cache_dir=config.artifacts_cache_directory)
+
+    prepare_spy = mocker.spy(Chef, "_prepare")
+    chef = Chef(artifact_cache, env, Factory.create_pool(config))
+    chef.set_directory_wheel([copy_wheel(), copy_wheel()])
+    chef.set_sdist_wheel(copy_wheel())
+
+    executor = Executor(env, pool, config, io)
+    executor._chef = chef
+
+    directory_package = Package(
+        "simple-project",
+        "1.2.3",
+        source_type="directory",
+        source_url=fixture_dir("simple_project").resolve().as_posix(),
+    )
+
+    git_package = Package(
+        "demo",
+        "0.1.0",
+        source_type="git",
+        source_reference="master",
+        source_url="https://github.com/demo/demo.git",
+        develop=True,
+    )
+
+    return_code = executor.execute(
+        [
+            Install(directory_package),
+            Install(git_package),
+        ]
+    )
+
+    expected = f"""
+Package operations: 2 installs, 0 updates, 0 removals
+
+  - Installing simple-project (1.2.3 {directory_package.source_url})
+  - Installing demo (0.1.0 master)
+"""
+
+    expected_lines = set(expected.splitlines())
+    output_lines = set(io.fetch_output().splitlines())
+    assert output_lines == expected_lines
+    assert wheel_install.call_count == 2
+    assert return_code == 0
+
+    assert prepare_spy.call_count == 2
+    assert prepare_spy.call_args_list == [
+        mocker.call(
+            chef,
+            mocker.ANY,
+            destination=mocker.ANY,
+            editable=False,
+            config_settings=None,
+        ),
+        mocker.call(
+            chef,
+            mocker.ANY,
+            destination=mocker.ANY,
+            editable=True,
+            config_settings=config_settings_demo,
+        ),
+    ]
+
+
+@pytest.mark.parametrize(
+    "operations, has_warning",
+    [
+        (
+            [Install(Package("black", "21.11b0")), Install(Package("pytest", "3.5.1"))],
+            True,
+        ),
+        (
+            [
+                Uninstall(Package("black", "21.11b0")),
+                Uninstall(Package("pytest", "3.5.1")),
+            ],
+            False,
+        ),
+        (
+            [
+                Update(Package("black", "19.10b0"), Package("black", "21.11b0")),
+                Update(Package("pytest", "3.5.0"), Package("pytest", "3.5.1")),
+            ],
+            True,
+        ),
+    ],
+)
+def test_execute_prints_warning_for_yanked_package(
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+    operations: list[Operation],
+    has_warning: bool,
+) -> None:
+    config.merge({"cache-dir": str(tmp_path)})
+
+    executor = Executor(env, pool, config, io)
+
+    return_code = executor.execute(operations)
+
+    expected = (
+        "Warning: The file chosen for install of black 21.11b0 "
+        "(black-21.11b0-py3-none-any.whl) is yanked. Reason for being yanked: "
+        "Broken regex dependency. Use 21.11b1 instead."
+    )
+    output = io.fetch_output()
+    error = io.fetch_error()
+    assert return_code == 0, f"\noutput: {output}\nerror: {error}\n"
+    assert "pytest" not in error
+    if has_warning:
+        assert expected in error
+        assert error.count("is yanked") == 1
+    else:
+        assert expected not in error
+        assert error.count("yanked") == 0
+
+
+@pytest.mark.skip(reason="https://github.com/python-poetry/poetry/issues/7983")
+def test_execute_prints_warning_for_invalid_wheels(
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+) -> None:
+    config.merge({"cache-dir": str(tmp_path)})
+
+    executor = Executor(env, pool, config, io)
+
+    base_url = "https://files.pythonhosted.org/"
+    wheel1 = "demo_invalid_record-0.1.0-py2.py3-none-any.whl"
+    wheel2 = "demo_invalid_record2-0.1.0-py2.py3-none-any.whl"
+    return_code = executor.execute(
+        [
+            Install(
+                Package(
+                    "demo-invalid-record",
+                    "0.1.0",
+                    source_type="url",
+                    source_url=f"{base_url}/{wheel1}",
+                )
+            ),
+            Install(
+                Package(
+                    "demo-invalid-record2",
+                    "0.1.0",
+                    source_type="url",
+                    source_url=f"{base_url}/{wheel2}",
+                )
+            ),
+        ]
+    )
+
+    warning1 = f"""\
+<warning>Warning: Validation of the RECORD file of {wheel1} failed.\
+ Please report to the maintainers of that package so they can fix their build process.\
+ Details:
+In .*?{wheel1}, demo/__init__.py is not mentioned in RECORD
+In .*?{wheel1}, demo_invalid_record-0.1.0.dist-info/WHEEL is not mentioned in RECORD
+"""
+
+    warning2 = f"""\
+<warning>Warning: Validation of the RECORD file of {wheel2} failed.\
+ Please report to the maintainers of that package so they can fix their build process.\
+ Details:
+In .*?{wheel2}, hash / size of demo_invalid_record2-0.1.0.dist-info/METADATA didn't\
+ match RECORD
+"""
+
+    output = io.fetch_output()
+    error = io.fetch_error()
+    assert return_code == 0, f"\noutput: {output}\nerror: {error}\n"
+    assert re.match(f"{warning1}\n{warning2}", error) or re.match(
+        f"{warning2}\n{warning1}", error
+    ), error
+
+
+def test_execute_shows_skipped_operations_if_verbose(
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    config_cache_dir: Path,
+    env: MockEnv,
+) -> None:
+    config.merge({"cache-dir": config_cache_dir.as_posix()})
+
+    executor = Executor(env, pool, config, io)
+    executor.verbose()
+
+    assert (
+        executor.execute(
+            [Uninstall(Package("clikit", "0.2.3")).skip("Not currently installed")]
+        )
+        == 0
+    )
+
+    expected = """
+Package operations: 0 installs, 0 updates, 0 removals, 1 skipped
+
+  - Removing clikit (0.2.3): Skipped for the following reason: Not currently installed
+"""
+    assert io.fetch_output() == expected
+    assert len(env.executed) == 0
+
+
+def test_execute_should_show_errors(
+    config: Config,
+    pool: RepositoryPool,
+    mocker: MockerFixture,
+    io: BufferedIO,
+    env: MockEnv,
+) -> None:
+    executor = Executor(env, pool, config, io)
+    executor.verbose()
+
+    mocker.patch.object(executor, "_install", side_effect=Exception("It failed!"))
+
+    assert executor.execute([Install(Package("clikit", "0.2.3"))]) == 1
+
+    expected = """
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing clikit (0.2.3)
+
+  Exception
+
+  It failed!
+"""
+
+    assert expected in io.fetch_output()
+
+
+def test_execute_works_with_ansi_output(
+    config: Config,
+    pool: RepositoryPool,
+    io_decorated: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+) -> None:
+    config.merge({"cache-dir": str(tmp_path)})
+
+    executor = Executor(env, pool, config, io_decorated)
+
+    return_code = executor.execute(
+        [
+            Install(Package("cleo", "1.0.0a5")),
+        ]
+    )
+
+    # fmt: off
+    expected = [
+        "\x1b[39;1mPackage operations\x1b[39;22m: \x1b[34m1\x1b[39m install, \x1b[34m0\x1b[39m updates, \x1b[34m0\x1b[39m removals",
+        "\x1b[34;1m-\x1b[39;22m \x1b[39mInstalling \x1b[39m\x1b[36mcleo\x1b[39m\x1b[39m (\x1b[39m\x1b[39;1m1.0.0a5\x1b[39;22m\x1b[39m)\x1b[39m: \x1b[34mPending...\x1b[39m",
+        "\x1b[34;1m-\x1b[39;22m \x1b[39mInstalling \x1b[39m\x1b[36mcleo\x1b[39m\x1b[39m (\x1b[39m\x1b[39;1m1.0.0a5\x1b[39;22m\x1b[39m)\x1b[39m: \x1b[34mDownloading...\x1b[39m",
+        "\x1b[34;1m-\x1b[39;22m \x1b[39mInstalling \x1b[39m\x1b[36mcleo\x1b[39m\x1b[39m (\x1b[39m\x1b[39;1m1.0.0a5\x1b[39;22m\x1b[39m)\x1b[39m: \x1b[34mInstalling...\x1b[39m",
+        "\x1b[32;1m-\x1b[39;22m \x1b[39mInstalling \x1b[39m\x1b[36mcleo\x1b[39m\x1b[39m (\x1b[39m\x1b[32m1.0.0a5\x1b[39m\x1b[39m)\x1b[39m",  # finished
+    ]
+    # fmt: on
+
+    output = io_decorated.fetch_output()
+    # hint: use print(repr(output)) if you need to debug this
+
+    for line in expected:
+        assert line in output
+    assert return_code == 0
+
+
+def test_execute_works_with_no_ansi_output(
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io_not_decorated: BufferedIO,
+    tmp_path: Path,
+    env: MockEnv,
+) -> None:
+    config.merge({"cache-dir": str(tmp_path)})
+
+    executor = Executor(env, pool, config, io_not_decorated)
+
+    return_code = executor.execute(
+        [
+            Install(Package("cleo", "1.0.0a5")),
+        ]
+    )
+
+    expected = """
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing cleo (1.0.0a5)
+"""
+    expected_lines = set(expected.splitlines())
+    output_lines = set(io_not_decorated.fetch_output().splitlines())
+    assert output_lines == expected_lines
+    assert return_code == 0
+
+
+def test_execute_should_show_operation_as_cancelled_on_subprocess_keyboard_interrupt(
+    config: Config,
+    pool: RepositoryPool,
+    mocker: MockerFixture,
+    io: BufferedIO,
+    env: MockEnv,
+) -> None:
+    executor = Executor(env, pool, config, io)
+    executor.verbose()
+
+    # A return code of -2 means KeyboardInterrupt in the pip subprocess
+    mocker.patch.object(executor, "_install", return_value=-2)
+
+    assert executor.execute([Install(Package("clikit", "0.2.3"))]) == 1
+
+    expected = """
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing clikit (0.2.3)
+  - Installing clikit (0.2.3): Cancelled
+"""
+
+    assert io.fetch_output() == expected
+
+
+def test_execute_should_gracefully_handle_io_error(
+    config: Config,
+    pool: RepositoryPool,
+    mocker: MockerFixture,
+    io: BufferedIO,
+    env: MockEnv,
+) -> None:
+    executor = Executor(env, pool, config, io)
+    executor.verbose()
+
+    original_write_line = executor._io.write_line
+
+    def write_line(string: str, **kwargs: Any) -> None:
+        # Simulate UnicodeEncodeError
+        string = string.replace("-", "ΓÇó")
+        string.encode("ascii")
+        original_write_line(string, **kwargs)
+
+    mocker.patch.object(io, "write_line", side_effect=write_line)
+
+    assert executor.execute([Install(Package("clikit", "0.2.3"))]) == 1
+
+    expected = r"""
+Package operations: 1 install, 0 updates, 0 removals
+
+
+\s*Unicode\w+Error
+"""
+
+    assert re.match(expected, io.fetch_output())
+
+
+def test_executor_should_delete_incomplete_downloads(
+    config: Config,
+    io: BufferedIO,
+    tmp_path: Path,
+    mocker: MockerFixture,
+    pool: RepositoryPool,
+    env: MockEnv,
+) -> None:
+    cached_archive = tmp_path / "tomlkit-0.5.3-py2.py3-none-any.whl"
+
+    def download_fail(*_: Any) -> None:
+        cached_archive.touch()  # broken archive
+        raise Exception("Download error")
+
+    mocker.patch(
+        "poetry.installation.executor.Executor._download_archive",
+        side_effect=download_fail,
+    )
+    mocker.patch(
+        "poetry.utils.cache.ArtifactCache._get_cached_archive",
+        return_value=None,
+    )
+    mocker.patch(
+        "poetry.utils.cache.ArtifactCache.get_cache_directory_for_link",
+        return_value=tmp_path,
+    )
+
+    config.merge({"cache-dir": str(tmp_path)})
+
+    executor = Executor(env, pool, config, io)
+
+    with pytest.raises(Exception, match="Download error"):
+        executor._download(Install(Package("tomlkit", "0.5.3")))
+
+    assert not cached_archive.exists()
+
+
+def verify_installed_distribution(
+    venv: VirtualEnv, package: Package, url_reference: dict[str, Any] | None = None
+) -> None:
+    distributions = list(venv.site_packages.distributions(name=package.name))
+    assert len(distributions) == 1
+
+    distribution = distributions[0]
+    metadata = distribution.metadata
+    assert metadata
+    assert metadata["Name"] == package.name
+    assert metadata["Version"] == package.version.text
+
+    direct_url_file = distribution._path.joinpath(  # type: ignore[attr-defined]
+        "direct_url.json"
+    )
+
+    if url_reference is not None:
+        record_file = distribution._path.joinpath(  # type: ignore[attr-defined]
+            "RECORD"
+        )
+        with open(record_file, encoding="utf-8", newline="") as f:
+            reader = csv.reader(f)
+            rows = list(reader)
+        assert all(len(row) == 3 for row in rows)
+        record_entries = {row[0] for row in rows}
+        direct_url_entry = direct_url_file.relative_to(record_file.parent.parent)
+        assert direct_url_file.exists()
+        assert str(direct_url_entry) in record_entries
+        assert json.loads(direct_url_file.read_text(encoding="utf-8")) == url_reference
+    else:
+        assert not direct_url_file.exists()
+
+
+@pytest.mark.parametrize(
+    "package",
+    [
+        Package("demo", "0.1.0"),  # PyPI
+        Package(  # private source
+            "demo",
+            "0.1.0",
+            source_type="legacy",
+            source_url="http://localhost:3141/root/pypi/+simple",
+            source_reference="private",
+        ),
+    ],
+)
+def test_executor_should_not_write_pep610_url_references_for_cached_package(
+    package: Package,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+) -> None:
+    link_cached = fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl"
+    package.files = [
+        {
+            "file": "demo-0.1.0-py2.py3-none-any.whl",
+            "hash": (
+                "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a"
+            ),
+        }
+    ]
+
+    mocker.patch(
+        "poetry.installation.executor.Executor._download", return_value=link_cached
+    )
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor.execute([Install(package)])
+    verify_installed_distribution(tmp_venv, package)
+    assert link_cached.exists(), "cached file should not be deleted"
+
+
+def test_executor_should_write_pep610_url_references_for_wheel_files(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    url = (fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl").resolve()
+    package = Package("demo", "0.1.0", source_type="file", source_url=url.as_posix())
+    # Set package.files so the executor will attempt to hash the package
+    package.files = [
+        {
+            "file": "demo-0.1.0-py2.py3-none-any.whl",
+            "hash": (
+                "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a"
+            ),
+        }
+    ]
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor.execute([Install(package)])
+    expected_url_reference = {
+        "archive_info": {
+            "hashes": {
+                "sha256": (
+                    "70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a"
+                )
+            },
+        },
+        "url": url.as_uri(),
+    }
+    verify_installed_distribution(tmp_venv, package, expected_url_reference)
+    assert url.exists(), "source file should not be deleted"
+
+
+def test_executor_should_write_pep610_url_references_for_non_wheel_files(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    url = (fixture_dir("distributions") / "demo-0.1.0.tar.gz").resolve()
+    package = Package("demo", "0.1.0", source_type="file", source_url=url.as_posix())
+    # Set package.files so the executor will attempt to hash the package
+    package.files = [
+        {
+            "file": "demo-0.1.0.tar.gz",
+            "hash": (
+                "sha256:9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+            ),
+        }
+    ]
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor.execute([Install(package)])
+    expected_url_reference = {
+        "archive_info": {
+            "hashes": {
+                "sha256": (
+                    "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+                )
+            },
+        },
+        "url": url.as_uri(),
+    }
+    verify_installed_distribution(tmp_venv, package, expected_url_reference)
+    assert url.exists(), "source file should not be deleted"
+
+
+def test_executor_should_write_pep610_url_references_for_directories(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+    fixture_dir: FixtureDirGetter,
+    mocker: MockerFixture,
+) -> None:
+    url = (fixture_dir("git") / "github.com" / "demo" / "demo").resolve()
+    package = Package(
+        "demo", "0.1.2", source_type="directory", source_url=url.as_posix()
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    prepare_spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+    verify_installed_distribution(
+        tmp_venv, package, {"dir_info": {}, "url": url.as_uri()}
+    )
+    assert not prepare_spy.spy_return.exists(), "archive not cleaned up"
+
+
+def test_executor_should_write_pep610_url_references_for_editable_directories(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+    fixture_dir: FixtureDirGetter,
+    mocker: MockerFixture,
+) -> None:
+    url = (fixture_dir("git") / "github.com" / "demo" / "demo").resolve()
+    package = Package(
+        "demo",
+        "0.1.2",
+        source_type="directory",
+        source_url=url.as_posix(),
+        develop=True,
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    prepare_spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+    verify_installed_distribution(
+        tmp_venv, package, {"dir_info": {"editable": True}, "url": url.as_uri()}
+    )
+    assert not prepare_spy.spy_return.exists(), "archive not cleaned up"
+
+
+@pytest.mark.parametrize("is_artifact_cached", [False, True])
+def test_executor_should_write_pep610_url_references_for_wheel_urls(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    is_artifact_cached: bool,
+) -> None:
+    if is_artifact_cached:
+        link_cached = fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl"
+        mocker.patch(
+            "poetry.utils.cache.ArtifactCache.get_cached_archive_for_link",
+            return_value=link_cached,
+        )
+    download_spy = mocker.spy(Executor, "_download_archive")
+
+    package = Package(
+        "demo",
+        "0.1.0",
+        source_type="url",
+        source_url="https://files.pythonhosted.org/demo-0.1.0-py2.py3-none-any.whl",
+    )
+    # Set package.files so the executor will attempt to hash the package
+    package.files = [
+        {
+            "file": "demo-0.1.0-py2.py3-none-any.whl",
+            "hash": (
+                "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a"
+            ),
+        }
+    ]
+
+    executor = Executor(tmp_venv, pool, config, io)
+    operation = Install(package)
+    executor.execute([operation])
+    expected_url_reference = {
+        "archive_info": {
+            "hashes": {
+                "sha256": (
+                    "70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a"
+                )
+            },
+        },
+        "url": package.source_url,
+    }
+    verify_installed_distribution(tmp_venv, package, expected_url_reference)
+    if is_artifact_cached:
+        download_spy.assert_not_called()
+    else:
+        assert package.source_url is not None
+        download_spy.assert_called_once_with(
+            mocker.ANY,
+            operation,
+            package.source_url,
+            dest=mocker.ANY,
+        )
+        dest = download_spy.call_args.args[3]
+        assert dest.exists(), "cached file should not be deleted"
+
+
+@pytest.mark.parametrize(
+    (
+        "is_sdist_cached",
+        "is_wheel_cached",
+        "expect_artifact_building",
+        "expect_artifact_download",
+    ),
+    [
+        (True, False, True, False),
+        (True, True, False, False),
+        (False, False, True, True),
+        (False, True, False, True),
+    ],
+)
+def test_executor_should_write_pep610_url_references_for_non_wheel_urls(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    is_sdist_cached: bool,
+    is_wheel_cached: bool,
+    expect_artifact_building: bool,
+    expect_artifact_download: bool,
+) -> None:
+    built_wheel = fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl"
+    mock_prepare = mocker.patch(
+        "poetry.installation.chef.Chef._prepare",
+        return_value=built_wheel,
+    )
+    download_spy = mocker.spy(Executor, "_download_archive")
+
+    if is_sdist_cached or is_wheel_cached:
+        cached_sdist = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+        cached_wheel = fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl"
+
+        def mock_get_cached_archive_func(
+            _cache_dir: Path, *, strict: bool, **__: Any
+        ) -> Path | None:
+            if is_wheel_cached and not strict:
+                return cached_wheel
+            if is_sdist_cached:
+                return cached_sdist
+            return None
+
+        mocker.patch(
+            "poetry.utils.cache.ArtifactCache._get_cached_archive",
+            side_effect=mock_get_cached_archive_func,
+        )
+
+    package = Package(
+        "demo",
+        "0.1.0",
+        source_type="url",
+        source_url="https://files.pythonhosted.org/demo-0.1.0.tar.gz",
+    )
+    # Set package.files so the executor will attempt to hash the package
+    package.files = [
+        {
+            "file": "demo-0.1.0.tar.gz",
+            "hash": (
+                "sha256:9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+            ),
+        }
+    ]
+
+    executor = Executor(tmp_venv, pool, config, io)
+    operation = Install(package)
+    executor.execute([operation])
+    expected_url_reference = {
+        "archive_info": {
+            "hashes": {
+                "sha256": (
+                    "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+                )
+            },
+        },
+        "url": package.source_url,
+    }
+    verify_installed_distribution(tmp_venv, package, expected_url_reference)
+
+    if expect_artifact_building:
+        mock_prepare.assert_called_once()
+    else:
+        mock_prepare.assert_not_called()
+
+    if expect_artifact_download:
+        assert package.source_url is not None
+        download_spy.assert_called_once_with(
+            mocker.ANY, operation, package.source_url, dest=mocker.ANY
+        )
+        dest = download_spy.call_args.args[3]
+        assert dest.exists(), "cached file should not be deleted"
+    else:
+        download_spy.assert_not_called()
+
+
+@pytest.mark.parametrize(
+    "source_url,written_source_url",
+    [
+        ("https://github.com/demo/demo.git", "https://github.com/demo/demo.git"),
+        ("git@github.com:demo/demo.git", "ssh://git@github.com/demo/demo.git"),
+    ],
+)
+@pytest.mark.parametrize("is_artifact_cached", [False, True])
+def test_executor_should_write_pep610_url_references_for_git(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    source_url: str,
+    written_source_url: str,
+    is_artifact_cached: bool,
+) -> None:
+    if is_artifact_cached:
+        link_cached = fixture_dir("distributions") / "demo-0.1.2-py2.py3-none-any.whl"
+        mocker.patch(
+            "poetry.utils.cache.ArtifactCache.get_cached_archive_for_git",
+            return_value=link_cached,
+        )
+    clone_spy = mocker.spy(Git, "clone")
+
+    source_resolved_reference = "123456"
+    source_url = source_url
+
+    package = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference=source_resolved_reference,
+        source_url=source_url,
+    )
+
+    assert package.source_url == written_source_url
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    prepare_spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+    verify_installed_distribution(
+        tmp_venv,
+        package,
+        {
+            "vcs_info": {
+                "vcs": "git",
+                "requested_revision": "master",
+                "commit_id": "123456",
+            },
+            "url": package.source_url,
+        },
+    )
+
+    if is_artifact_cached:
+        clone_spy.assert_not_called()
+        prepare_spy.assert_not_called()
+    else:
+        clone_spy.assert_called_once_with(
+            url=package.source_url,
+            source_root=mocker.ANY,
+            revision=source_resolved_reference,
+        )
+        prepare_spy.assert_called_once()
+        assert prepare_spy.spy_return.exists(), "cached file should not be deleted"
+        assert (prepare_spy.spy_return.parent / ".created_from_git_dependency").exists()
+
+
+def test_executor_should_write_pep610_url_references_for_editable_git(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    source_resolved_reference = "123456"
+    source_url = "https://github.com/demo/demo.git"
+
+    package = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference=source_resolved_reference,
+        source_url=source_url,
+        develop=True,
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    prepare_spy = mocker.spy(chef, "prepare")
+    cache_spy = mocker.spy(artifact_cache, "get_cached_archive_for_git")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+    assert package.source_url is not None
+    verify_installed_distribution(
+        tmp_venv,
+        package,
+        {
+            "dir_info": {"editable": True},
+            "url": Path(package.source_url).as_uri(),
+        },
+    )
+
+    cache_spy.assert_not_called()
+    prepare_spy.assert_called_once()
+    assert not prepare_spy.spy_return.exists(), "editable git should not be cached"
+    assert not (prepare_spy.spy_return.parent / ".created_from_git_dependency").exists()
+
+
+def test_executor_should_append_subdirectory_for_git(
+    mocker: MockerFixture,
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+) -> None:
+    package = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/demo/subdirectories.git",
+        source_subdirectory="two",
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+
+    archive_arg = spy.call_args[0][0]
+    assert archive_arg == tmp_venv.path / "src/subdirectories/two"
+
+
+def test_executor_should_install_multiple_packages_from_same_git_repository(
+    mocker: MockerFixture,
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+) -> None:
+    package_a = Package(
+        "package_a",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/demo/subdirectories.git",
+        source_subdirectory="package_a",
+    )
+    package_b = Package(
+        "package_b",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/demo/subdirectories.git",
+        source_subdirectory="package_b",
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package_a), Install(package_b)])
+
+    archive_arg = spy.call_args_list[0][0][0]
+    assert archive_arg == tmp_venv.path / "src/subdirectories/package_a"
+
+    archive_arg = spy.call_args_list[1][0][0]
+    assert archive_arg == tmp_venv.path / "src/subdirectories/package_b"
+
+
+def test_executor_should_install_multiple_packages_from_forked_git_repository(
+    mocker: MockerFixture,
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+) -> None:
+    package_a = Package(
+        "one",
+        "1.0.0",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/demo/subdirectories.git",
+        source_subdirectory="one",
+    )
+    package_b = Package(
+        "two",
+        "2.0.0",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/forked_demo/subdirectories.git",
+        source_subdirectory="two",
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+    prepare_spy = mocker.spy(chef, "prepare")
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package_a), Install(package_b)])
+
+    # Verify that the repo for package_a is not re-used for package_b.
+    # both repos must be cloned serially into separate directories.
+    # If so, executor.prepare() will be called twice.
+    assert prepare_spy.call_count == 2
+
+
+def test_executor_should_write_pep610_url_references_for_git_with_subdirectories(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    artifact_cache: ArtifactCache,
+    io: BufferedIO,
+    wheel: Path,
+) -> None:
+    package = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_reference="master",
+        source_resolved_reference="123456",
+        source_url="https://github.com/demo/subdirectories.git",
+        source_subdirectory="two",
+    )
+
+    chef = Chef(artifact_cache, tmp_venv, Factory.create_pool(config))
+    chef.set_directory_wheel(wheel)
+
+    executor = Executor(tmp_venv, pool, config, io)
+    executor._chef = chef
+    executor.execute([Install(package)])
+    verify_installed_distribution(
+        tmp_venv,
+        package,
+        {
+            "vcs_info": {
+                "vcs": "git",
+                "requested_revision": "master",
+                "commit_id": "123456",
+            },
+            "url": package.source_url,
+            "subdirectory": package.source_subdirectory,
+        },
+    )
+
+
+@pytest.mark.parametrize(
+    ("max_workers", "cpu_count", "side_effect", "expected_workers"),
+    [
+        (None, 3, None, 7),
+        (3, 4, None, 3),
+        (8, 3, None, 7),
+        (None, 8, NotImplementedError(), 5),
+        (2, 8, NotImplementedError(), 2),
+        (8, 8, NotImplementedError(), 5),
+    ],
+)
+def test_executor_should_be_initialized_with_correct_workers(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    mocker: MockerFixture,
+    max_workers: int | None,
+    cpu_count: int | None,
+    side_effect: Exception | None,
+    expected_workers: int,
+) -> None:
+    config.merge({"installer": {"max-workers": max_workers}})
+
+    mocker.patch("os.cpu_count", return_value=cpu_count, side_effect=side_effect)
+
+    executor = Executor(tmp_venv, pool, config, io)
+
+    assert executor._max_workers == expected_workers
+
+
+@pytest.mark.parametrize("failing_method", ["build", "get_requires_for_build"])
+@pytest.mark.parametrize(
+    "exception",
+    [
+        CalledProcessError(1, ["pip"], output=b"original error"),
+        Exception("original error"),
+    ],
+)
+@pytest.mark.parametrize("editable", [False, True])
+@pytest.mark.parametrize("source_type", ["directory", "git", "git subdirectory"])
+def test_build_backend_errors_are_reported_correctly_if_caused_by_subprocess(
+    failing_method: str,
+    exception: Exception,
+    editable: bool,
+    source_type: str,
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    env: MockEnv,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    error = BuildBackendException(exception, description="hide the original error")
+    mocker.patch.object(ProjectBuilder, failing_method, side_effect=error)
+    io.set_verbosity(Verbosity.NORMAL)
+
+    executor = Executor(env, pool, config, io)
+
+    package_name = "simple-project"
+    package_version = "1.2.3"
+    source_reference: str | None = None
+    source_sub_directory: str | None = None
+    if source_type == "directory":
+        source_url = fixture_dir("simple_project").resolve().as_posix()
+        source_resolved_reference = None
+        pip_url = path_to_url(source_url)
+        pip_editable_requirement = source_url
+    elif source_type == "git":
+        source_url = "https://github.com/demo/demo.git"
+        source_reference = "v2.0"
+        source_resolved_reference = "12345678"
+        pip_url = f"git+{source_url}@{source_reference}"
+        pip_editable_requirement = f"{pip_url}#egg={package_name}"
+    elif source_type == "git subdirectory":
+        source_type = "git"
+        source_sub_directory = "one"
+        source_url = "https://github.com/demo/subdirectories.git"
+        source_reference = "v2.0"
+        source_resolved_reference = "12345678"
+        pip_base_url = f"git+{source_url}@{source_reference}"
+        pip_url = f"{pip_base_url}#subdirectory={source_sub_directory}"
+        pip_editable_requirement = (
+            f"{pip_base_url}#egg={package_name}&subdirectory={source_sub_directory}"
+        )
+    else:
+        raise ValueError(f"Unknown source type: {source_type}")
+    package = Package(
+        package_name,
+        package_version,
+        source_type=source_type,
+        source_url=source_url,
+        source_reference=source_reference,
+        source_resolved_reference=source_resolved_reference,
+        source_subdirectory=source_sub_directory,
+        develop=editable,
+    )
+    # must not be included in the error message
+    package.python_versions = ">=3.7"
+
+    return_code = executor.execute([Install(package)])
+
+    assert return_code == 1
+
+    assert package.source_url is not None
+    if editable:
+        pip_command = "pip wheel --no-cache-dir --use-pep517 --editable"
+        requirement = pip_editable_requirement
+        if source_type == "directory":
+            assert Path(requirement).exists()
+    else:
+        pip_command = "pip wheel --no-cache-dir --use-pep517"
+        requirement = f"{package_name} @ {pip_url}"
+
+    version_details = package.source_resolved_reference or package.source_url
+    expected_source_string = f"{package_name} ({package_version} {version_details})"
+    expected_pip_command = f'{pip_command} "{requirement}"'
+
+    expected_output = f"""
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing {expected_source_string}
+
+PEP517 build of a dependency failed
+
+hide the original error
+"""
+
+    if isinstance(exception, CalledProcessError):
+        expected_output += (
+            "\n    | Command '['pip']' returned non-zero exit status 1."
+            "\n    | "
+            "\n    | original error"
+            "\n"
+        )
+
+    expected_output += f"""
+Note: This error originates from the build backend, and is likely not a problem \
+with poetry but one of the following issues with {expected_source_string}
+
+  - not supporting PEP 517 builds
+  - not specifying PEP 517 build requirements correctly
+  - the build requirements are incompatible with your operating system or Python version
+  - the build requirements are missing system dependencies (eg: compilers, libraries, headers).
+
+You can verify this by running {expected_pip_command}.
+
+"""
+
+    assert io.fetch_output() == expected_output
+
+
+@pytest.mark.parametrize("encoding", ["utf-8", "latin-1"])
+@pytest.mark.parametrize("stderr", [None, "Errör on stderr"])
+def test_build_backend_errors_are_reported_correctly_if_caused_by_subprocess_encoding(
+    encoding: str,
+    stderr: str | None,
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    env: MockEnv,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    """Test that the output of the subprocess is decoded correctly."""
+    stdout = "Errör on stdout"
+    error = BuildBackendException(
+        CalledProcessError(
+            1,
+            ["pip"],
+            output=stdout.encode(encoding),
+            stderr=stderr.encode(encoding) if stderr else None,
+        )
+    )
+    mocker.patch.object(ProjectBuilder, "get_requires_for_build", side_effect=error)
+    io.set_verbosity(Verbosity.NORMAL)
+
+    executor = Executor(env, pool, config, io)
+
+    directory_package = Package(
+        "simple-project",
+        "1.2.3",
+        source_type="directory",
+        source_url=fixture_dir("simple_project").resolve().as_posix(),
+    )
+
+    return_code = executor.execute([Install(directory_package)])
+
+    assert return_code == 1
+    assert (stderr or stdout) in io.fetch_output()
+
+
+def test_build_system_requires_not_available(
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    env: MockEnv,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    io.set_verbosity(Verbosity.NORMAL)
+
+    executor = Executor(env, pool, config, io)
+
+    package_name = "simple-project"
+    package_version = "1.2.3"
+    directory_package = Package(
+        package_name,
+        package_version,
+        source_type="directory",
+        source_url=fixture_dir("build_system_requires_not_available")
+        .resolve()
+        .as_posix(),
+    )
+
+    return_code = executor.execute([Install(directory_package)])
+
+    assert return_code == 1
+
+    package_url = directory_package.source_url
+    expected_start = f"""\
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing {package_name} ({package_version} {package_url})
+
+  SolveFailureError
+
+  Because -root- depends on poetry-core (0.999) which doesn't match any versions,\
+ version solving failed.
+"""
+    expected_end = "Cannot resolve build-system.requires for simple-project."
+
+    output = io.fetch_output().strip()
+    assert output.startswith(expected_start)
+    assert output.endswith(expected_end)
+
+
+def test_build_system_requires_install_failure(
+    mocker: MockerFixture,
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    env: MockEnv,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    mocker.patch("poetry.installation.installer.Installer.run", return_value=1)
+    mocker.patch("cleo.io.buffered_io.BufferedIO.fetch_output", return_value="output")
+    mocker.patch("cleo.io.buffered_io.BufferedIO.fetch_error", return_value="error")
+    io.set_verbosity(Verbosity.NORMAL)
+
+    executor = Executor(env, pool, config, io)
+
+    package_name = "simple-project"
+    package_version = "1.2.3"
+    directory_package = Package(
+        package_name,
+        package_version,
+        source_type="directory",
+        source_url=fixture_dir("simple_project").resolve().as_posix(),
+    )
+
+    return_code = executor.execute([Install(directory_package)])
+
+    assert return_code == 1
+
+    package_url = directory_package.source_url
+    expected_start = f"""\
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing {package_name} ({package_version} {package_url})
+
+  IsolatedBuildInstallError
+
+  Failed to install poetry-core>=1.1.0a7.
+  \
+
+  Output:
+  output
+  \
+
+  Error:
+  error
+
+"""
+    expected_end = "Cannot install build-system.requires for simple-project."
+
+    mocker.stopall()  # to get real output
+    output = io.fetch_output().strip()
+
+    assert output.startswith(expected_start)
+    assert output.endswith(expected_end)
+
+
+def test_other_error(
+    config: Config,
+    pool: RepositoryPool,
+    io: BufferedIO,
+    env: MockEnv,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    io.set_verbosity(Verbosity.NORMAL)
+
+    executor = Executor(env, pool, config, io)
+
+    package_name = "simple-project"
+    package_version = "1.2.3"
+    directory_package = Package(
+        package_name,
+        package_version,
+        source_type="directory",
+        source_url=fixture_dir("non-existing").resolve().as_posix(),
+    )
+
+    return_code = executor.execute([Install(directory_package)])
+
+    assert return_code == 1
+
+    package_url = directory_package.source_url
+    expected_start = f"""\
+Package operations: 1 install, 0 updates, 0 removals
+
+  - Installing {package_name} ({package_version} {package_url})
+
+  FileNotFoundError
+"""
+    expected_end = "Cannot install simple-project."
+
+    output = io.fetch_output().strip()
+    assert output.startswith(expected_start)
+    assert output.endswith(expected_end)
+
+
+@pytest.mark.parametrize(
+    "package_files,expected_url_reference",
+    [
+        (
+            [
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "sha512:766ecf369b6bdf801f6f7bbfe23923cc9793d633a55619472cd3d5763f9154711fbf57c8b6ca74e4a82fa9bd8380af831e7b8668e68e362669fc60b1d81d79ad",
+                },
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "md5:d1912c917363a64e127318655f7d1fe7",
+                },
+                {
+                    "file": "demo-0.1.0.whl",
+                    "hash": "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a",
+                },
+            ],
+            {
+                "archive_info": {
+                    "hashes": {
+                        "sha512": "766ecf369b6bdf801f6f7bbfe23923cc9793d633a55619472cd3d5763f9154711fbf57c8b6ca74e4a82fa9bd8380af831e7b8668e68e362669fc60b1d81d79ad"
+                    },
+                },
+            },
+        ),
+        (
+            [
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "md5:d1912c917363a64e127318655f7d1fe7",
+                }
+            ],
+            {
+                "archive_info": {
+                    "hashes": {"md5": "d1912c917363a64e127318655f7d1fe7"},
+                },
+            },
+        ),
+        (
+            [
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "sha3_512:196f4af9099185054ed72ca1d4c57707da5d724df0af7c3dfcc0fd018b0e0533908e790a291600c7d196fe4411b4f5f6db45213fe6e5cd5512bf18b2e9eff728",
+                },
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "sha512:766ecf369b6bdf801f6f7bbfe23923cc9793d633a55619472cd3d5763f9154711fbf57c8b6ca74e4a82fa9bd8380af831e7b8668e68e362669fc60b1d81d79ad",
+                },
+                {
+                    "file": "demo-0.1.0.tar.gz",
+                    "hash": "md5:d1912c917363a64e127318655f7d1fe7",
+                },
+                {
+                    "file": "demo-0.1.0.whl",
+                    "hash": "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a",
+                },
+            ],
+            {
+                "archive_info": {
+                    "hashes": {
+                        "sha3_512": "196f4af9099185054ed72ca1d4c57707da5d724df0af7c3dfcc0fd018b0e0533908e790a291600c7d196fe4411b4f5f6db45213fe6e5cd5512bf18b2e9eff728"
+                    },
+                },
+            },
+        ),
+    ],
+)
+def test_executor_known_hashes(
+    package_files: list[dict[str, str]],
+    expected_url_reference: dict[str, Any],
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    package_source_url: Path = (
+        fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    ).resolve()
+    package = Package(
+        "demo", "0.1.0", source_type="file", source_url=package_source_url.as_posix()
+    )
+    package.files = package_files
+    executor = Executor(tmp_venv, pool, config, io)
+    executor.execute([Install(package)])
+    expected_url_reference["url"] = package_source_url.as_uri()
+    verify_installed_distribution(tmp_venv, package, expected_url_reference)
+
+
+def test_executor_no_supported_hash_types(
+    tmp_venv: VirtualEnv,
+    pool: RepositoryPool,
+    config: Config,
+    io: BufferedIO,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    url = (fixture_dir("distributions") / "demo-0.1.0.tar.gz").resolve()
+    package = Package("demo", "0.1.0", source_type="file", source_url=url.as_posix())
+    # Set package.files so the executor will attempt to hash the package
+    package.files = [
+        {
+            "file": "demo-0.1.0.tar.gz",
+            "hash": "hash_blah:1234567890abcdefghijklmnopqrstyzwxyz",
+        },
+        {
+            "file": "demo-0.1.0.whl",
+            "hash": "sha256:70e704135718fffbcbf61ed1fc45933cfd86951a744b681000eaaa75da31f17a",
+        },
+    ]
+
+    executor = Executor(tmp_venv, pool, config, io)
+    return_code = executor.execute([Install(package)])
+    distributions = list(tmp_venv.site_packages.distributions(name=package.name))
+    assert len(distributions) == 0
+
+    output = io.fetch_output()
+    error = io.fetch_error()
+    assert return_code == 1, f"\noutput: {output}\nerror: {error}\n"
+    assert "No usable hash type(s) for demo" in output
+    assert "hash_blah:1234567890abcdefghijklmnopqrstyzwxyz" in output
diff --git b/tests/installation/test_installer.py a/tests/installation/test_installer.py
new file mode 100644
index 0000000..851c959
--- /dev/null
+++ a/tests/installation/test_installer.py
@@ -0,0 +1,3325 @@
+from __future__ import annotations
+
+import json
+import re
+import shutil
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import cast
+
+import pytest
+
+from cleo.io.buffered_io import BufferedIO
+from cleo.io.inputs.input import Input
+from cleo.io.null_io import NullIO
+from cleo.io.outputs.output import Verbosity
+from packaging.utils import canonicalize_name
+from poetry.core.constraints.version import Version
+from poetry.core.packages.dependency_group import MAIN_GROUP
+from poetry.core.packages.dependency_group import DependencyGroup
+from poetry.core.packages.package import Package
+from poetry.core.packages.project_package import ProjectPackage
+
+from poetry.factory import Factory
+from poetry.installation import Installer
+from poetry.packages import Locker as BaseLocker
+from poetry.repositories import Repository
+from poetry.repositories import RepositoryPool
+from poetry.repositories.installed_repository import InstalledRepository
+from poetry.toml.file import TOMLFile
+from poetry.utils.env import MockEnv
+from poetry.utils.env import NullEnv
+from tests.helpers import MOCK_DEFAULT_GIT_REVISION
+from tests.helpers import TestExecutor
+from tests.helpers import get_dependency
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+
+    from _pytest.fixtures import FixtureRequest
+    from pytest_mock import MockerFixture
+    from tomlkit import TOMLDocument
+
+    from poetry.repositories.legacy_repository import LegacyRepository
+    from poetry.repositories.pypi_repository import PyPiRepository
+    from poetry.utils.env import Env
+    from tests.conftest import Config
+    from tests.types import FixtureDirGetter
+    from tests.types import PackageFactory
+
+
+class CustomInstalledRepository(InstalledRepository):
+    @classmethod
+    def load(
+        cls, env: Env, with_dependencies: bool = False
+    ) -> CustomInstalledRepository:
+        return cls()
+
+
+class Locker(BaseLocker):
+    def __init__(self, lock_path: Path) -> None:
+        self._lock = lock_path / "poetry.lock"
+        self._written_data = None
+        self._locked = False
+        self._fresh = True
+        self._lock_data = None
+        self._content_hash = self._get_content_hash()
+
+    @property
+    def written_data(self) -> dict[str, Any]:
+        assert self._written_data is not None
+        return self._written_data
+
+    def set_lock_path(self, lock: Path) -> Locker:
+        self._lock = lock / "poetry.lock"
+
+        return self
+
+    def locked(self, is_locked: bool = True) -> Locker:
+        self._locked = is_locked
+
+        return self
+
+    def mock_lock_data(self, data: dict[str, Any]) -> None:
+        self._lock_data = data
+
+    def is_locked(self) -> bool:
+        return self._locked
+
+    def fresh(self, is_fresh: bool = True) -> Locker:
+        self._fresh = is_fresh
+
+        return self
+
+    def is_fresh(self) -> bool:
+        return self._fresh
+
+    def _get_content_hash(self) -> str:
+        return "123456789"
+
+    def _write_lock_data(self, data: dict[str, Any]) -> None:
+        for package in data["package"]:
+            python_versions = str(package["python-versions"])
+            package["python-versions"] = python_versions
+
+        self._written_data = json.loads(json.dumps(data))
+        self._lock_data = data
+
+
+@pytest.fixture(autouse=True, params=[False, True])
+def config_installer_reresolve(
+    config: Config, request: FixtureRequest
+) -> Iterator[bool]:
+    config.config["installer"]["re-resolve"] = request.param
+    yield request.param
+
+
+@pytest.fixture()
+def package() -> ProjectPackage:
+    p = ProjectPackage("root", "1.0")
+    p.root_dir = Path.cwd()
+
+    return p
+
+
+@pytest.fixture()
+def repo() -> Repository:
+    return Repository("repo")
+
+
+@pytest.fixture()
+def pool(repo: Repository) -> RepositoryPool:
+    pool = RepositoryPool()
+    pool.add_repository(repo)
+
+    return pool
+
+
+@pytest.fixture()
+def installed() -> CustomInstalledRepository:
+    return CustomInstalledRepository()
+
+
+@pytest.fixture()
+def locker(project_root: Path) -> Locker:
+    return Locker(lock_path=project_root)
+
+
+@pytest.fixture()
+def env(tmp_path: Path) -> NullEnv:
+    return NullEnv(path=tmp_path)
+
+
+@pytest.fixture()
+def installer(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    locker: Locker,
+    env: NullEnv,
+    installed: CustomInstalledRepository,
+    config: Config,
+) -> Installer:
+    return Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+
+
+def fixture(name: str, data: dict[str, Any] | None = None) -> dict[str, Any]:
+    """
+    Create or load a fixture file in TOML format.
+
+    This function retrieves the contents of a test fixture file, optionally writing
+    data to it before reading, and returns the data as a dictionary. It is used to
+    manage testing fixtures for TOML-based configurations.
+
+    :param name: Name of the fixture file (without extension, default of .test is appended).
+    :param data: Dictionary to write to the file as a TOML document. If None,
+                 no data is written (use this only when generating fixtures).
+    :return: Dictionary representing the contents of the TOML fixture file.
+    """
+    file = TOMLFile(Path(__file__).parent / "fixtures" / f"{name}.test")
+
+    if data:
+        # if data is provided write it, this is helpful for generating fixtures
+        # we expect lock data to be compatible with TOMLDocument for our purposes
+        file.write(cast("TOMLDocument", data))
+
+    content: dict[str, Any] = file.read()
+
+    return content
+
+
+def fix_lock_data(lock_data: dict[str, Any]) -> None:
+    if Version.parse(lock_data["metadata"]["lock-version"]) >= Version.parse("2.1"):
+        for locked_package in lock_data["package"]:
+            locked_package["groups"] = ["main"]
+            locked_package["files"] = []
+        del lock_data["metadata"]["files"]
+
+
+def test_run_no_dependencies(installer: Installer, locker: Locker) -> None:
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("no-dependencies")
+    assert locker.written_data == expected
+
+
+def test_not_fresh_lock(installer: Installer, locker: Locker) -> None:
+    locker.locked().fresh(False)
+    with pytest.raises(
+        ValueError,
+        match=re.escape(
+            "pyproject.toml changed significantly since poetry.lock was last generated. "
+            "Run `poetry lock` to fix the lock file."
+        ),
+    ):
+        installer.run()
+
+
+def test_run_with_dependencies(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies")
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_update_after_removing_dependencies(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "B",
+                "version": "1.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "C",
+                "version": "1.2",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": [], "C": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c = get_package("C", "1.2")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    installed.add_package(package_a)
+    installed.add_package(package_b)
+    installed.add_package(package_c)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "~1.1"))
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies")
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 1
+
+
+def _configure_run_install_dev(
+    lock_version: str,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    with_optional_group: bool = False,
+    with_packages_installed: bool = False,
+) -> None:
+    """
+    Perform common test setup for `test_run_install_*dev*()` methods.
+    """
+    lock_data: dict[str, Any] = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "B",
+                "version": "1.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "C",
+                "version": "1.2",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": [], "C": []},
+        },
+    }
+    if lock_version == "2.1":
+        for locked_package in lock_data["package"]:
+            locked_package["groups"] = [
+                "dev" if locked_package["name"] == "C" else "main"
+            ]
+            locked_package["files"] = []
+        del lock_data["metadata"]["files"]
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c = get_package("C", "1.2")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    if with_packages_installed:
+        installed.add_package(package_a)
+        installed.add_package(package_b)
+        installed.add_package(package_c)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "~1.1"))
+
+    group = DependencyGroup("dev", optional=with_optional_group)
+    group.add_dependency(Factory.create_dependency("C", "~1.2", groups=["dev"]))
+    package.add_dependency_group(group)
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+@pytest.mark.parametrize("update", [False, True])
+@pytest.mark.parametrize("requires_synchronization", [False, True])
+@pytest.mark.parametrize(
+    ("groups", "installs", "updates", "removals", "with_packages_installed"),
+    [
+        (None, 2, 0, 0, False),
+        (None, 0, 0, 1, True),
+        ([], 0, 0, 0, False),
+        ([], 0, 0, 3, True),
+        (["dev"], 1, 0, 0, False),
+        (["dev"], 0, 0, 2, True),
+        ([MAIN_GROUP], 2, 0, 0, False),
+        ([MAIN_GROUP], 0, 0, 1, True),
+        ([MAIN_GROUP, "dev"], 3, 0, 0, False),
+        ([MAIN_GROUP, "dev"], 0, 0, 0, True),
+    ],
+)
+def test_run_install_with_dependency_groups(
+    groups: list[str] | None,
+    installs: int,
+    updates: int,
+    removals: int,
+    with_packages_installed: bool,
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    update: bool,
+    requires_synchronization: bool,
+    lock_version: str,
+) -> None:
+    _configure_run_install_dev(
+        lock_version,
+        locker,
+        repo,
+        package,
+        installed,
+        with_optional_group=True,
+        with_packages_installed=with_packages_installed,
+    )
+
+    if groups is not None:
+        installer.only_groups({canonicalize_name(g) for g in groups})
+
+    installer.update(update)
+    installer.requires_synchronization(requires_synchronization)
+    result = installer.run()
+    assert result == 0
+
+    if not requires_synchronization:
+        removals = 0
+    assert installer.executor.installations_count == installs
+    assert installer.executor.updates_count == updates
+    assert installer.executor.removals_count == removals
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_install_does_not_remove_locked_packages_if_installed_but_not_required(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    package_a = get_package("a", "1.0")
+    package_b = get_package("b", "1.1")
+    package_c = get_package("c", "1.2")
+
+    repo.add_package(package_a)
+    installed.add_package(package_a)
+    repo.add_package(package_b)
+    installed.add_package(package_b)
+    repo.add_package(package_c)
+    installed.add_package(package_c)
+
+    installed.add_package(package)  # Root package never removed.
+
+    package.add_dependency(
+        Factory.create_dependency(package_a.name, str(package_a.version))
+    )
+
+    lock_data = {
+        "package": [
+            {
+                "name": package_a.name,
+                "version": package_a.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_b.name,
+                "version": package_b.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_c.name,
+                "version": package_c.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {package_a.name: [], package_b.name: [], package_c.name: []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_install_removes_locked_packages_if_installed_and_synchronization_is_required(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+    config_installer_reresolve: bool,
+) -> None:
+    package_a = get_package("a", "1.0")
+    package_b = get_package("b", "1.1")
+    package_c = get_package("c", "1.2")
+
+    repo.add_package(package_a)
+    installed.add_package(package_a)
+    repo.add_package(package_b)
+    installed.add_package(package_b)
+    repo.add_package(package_c)
+    installed.add_package(package_c)
+
+    installed.add_package(package)  # Root package never removed.
+
+    package.add_dependency(
+        Factory.create_dependency(package_a.name, str(package_a.version))
+    )
+
+    lock_data = {
+        "package": [
+            {
+                "name": package_a.name,
+                "version": package_a.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_b.name,
+                "version": package_b.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_c.name,
+                "version": package_c.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {package_a.name: [], package_b.name: [], package_c.name: []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    installer.update(True)
+    installer.requires_synchronization(True)
+    installer.run()
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 2
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_install_removes_no_longer_locked_packages_if_installed(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    package_a = get_package("a", "1.0")
+    package_b = get_package("b", "1.1")
+    package_c = get_package("c", "1.2")
+
+    repo.add_package(package_a)
+    installed.add_package(package_a)
+    repo.add_package(package_b)
+    installed.add_package(package_b)
+    repo.add_package(package_c)
+    installed.add_package(package_c)
+
+    installed.add_package(package)  # Root package never removed.
+
+    package.add_dependency(
+        Factory.create_dependency(package_a.name, str(package_a.version))
+    )
+
+    lock_data = {
+        "package": [
+            {
+                "name": package_a.name,
+                "version": package_a.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_b.name,
+                "version": package_b.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": package_c.name,
+                "version": package_c.version.text,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {package_a.name: [], package_b.name: [], package_c.name: []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 2
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+@pytest.mark.parametrize(
+    "managed_reserved_package_names",
+    [(), ("pip",)],
+)
+def test_run_install_with_synchronization(
+    managed_reserved_package_names: tuple[str, ...],
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    package_a = get_package("a", "1.0")
+    package_b = get_package("b", "1.1")
+    package_c = get_package("c", "1.2")
+    package_pip = get_package("pip", "20.0.0")
+
+    all_packages = [
+        package_a,
+        package_b,
+        package_c,
+        package_pip,
+    ]
+
+    managed_reserved_packages = [
+        pkg for pkg in all_packages if pkg.name in managed_reserved_package_names
+    ]
+    locked_packages = [package_a, *managed_reserved_packages]
+
+    for pkg in all_packages:
+        repo.add_package(pkg)
+        installed.add_package(pkg)
+
+    installed.add_package(package)  # Root package never removed.
+
+    package.add_dependency(
+        Factory.create_dependency(package_a.name, str(package_a.version))
+    )
+
+    lock_data = {
+        "package": [
+            {
+                "name": pkg.name,
+                "version": pkg.version,
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            }
+            for pkg in locked_packages
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {pkg.name: [] for pkg in locked_packages},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    installer.update(True)
+    installer.requires_synchronization(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 2 + len(managed_reserved_packages)
+
+    expected_removals = {
+        package_b.name,
+        package_c.name,
+        *managed_reserved_package_names,
+    }
+
+    assert isinstance(installer.executor, TestExecutor)
+    assert {r.name for r in installer.executor.removals} == expected_removals
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_whitelist_add(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            }
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0")
+    package_a_new = get_package("A", "1.1")
+    package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(package_a_new)
+    repo.add_package(package_b)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    installer.update(True)
+    installer.whitelist(["B"])
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies")
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_whitelist_remove(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "B",
+                "version": "1.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    installed.add_package(package_b)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+
+    installer.update(True)
+    installer.whitelist(["B"])
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("remove")
+    assert locker.written_data == expected
+    assert installer.executor.installations_count == 1
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 1
+
+
+def test_add_with_sub_dependencies(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c = get_package("C", "1.2")
+    package_d = get_package("D", "1.3")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    package_a.add_dependency(Factory.create_dependency("D", "^1.0"))
+    package_b.add_dependency(Factory.create_dependency("C", "~1.2"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-sub-dependencies")
+    assert locker.written_data == expected
+
+
+def test_run_with_python_versions(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package.python_versions = "~2.7 || ^3.4"
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c12 = get_package("C", "1.2")
+    package_c12.python_versions = "~2.7 || ^3.3"
+    package_c13 = get_package("C", "1.3")
+    package_c13.python_versions = "~3.3"
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c12)
+    repo.add_package(package_c13)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+    package.add_dependency(Factory.create_dependency("C", "^1.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-python-versions")
+    assert locker.written_data == expected
+
+
+def test_run_with_optional_and_python_restricted_dependencies(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package.python_versions = "~2.7 || ^3.4"
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c12 = get_package("C", "1.2")
+    package_c13 = get_package("C", "1.3")
+    package_d = get_package("D", "1.4")
+    package_c13.add_dependency(Factory.create_dependency("D", "^1.2"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c12)
+    repo.add_package(package_c13)
+    repo.add_package(package_d)
+
+    package.extras = {canonicalize_name("foo"): [get_dependency("A", "~1.0")]}
+    dep_a = Factory.create_dependency("A", {"version": "~1.0", "optional": True})
+    dep_a._in_extras = [canonicalize_name("foo")]
+    package.add_dependency(dep_a)
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "~2.4"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "python": "~2.7 || ^3.4"})
+    )
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-optional-dependencies")
+    assert locker.written_data == expected
+
+    # We should only have 2 installs:
+    # C,D since python version is not compatible
+    # with B's python constraint and A is optional
+    assert isinstance(installer.executor, TestExecutor)
+    assert installer.executor.installations_count == 2
+    assert installer.executor.installations[0].name == "d"
+    assert installer.executor.installations[1].name == "c"
+
+
+def test_run_with_optional_and_platform_restricted_dependencies(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    mocker: MockerFixture,
+) -> None:
+    mocker.patch("sys.platform", "darwin")
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    package_c12 = get_package("C", "1.2")
+    package_c13 = get_package("C", "1.3")
+    package_d = get_package("D", "1.4")
+    package_c13.add_dependency(Factory.create_dependency("D", "^1.2"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c12)
+    repo.add_package(package_c13)
+    repo.add_package(package_d)
+
+    package.extras = {canonicalize_name("foo"): [get_dependency("A", "~1.0")]}
+    dep_a = Factory.create_dependency("A", {"version": "~1.0", "optional": True})
+    dep_a._in_extras = [canonicalize_name("foo")]
+    package.add_dependency(dep_a)
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "platform": "custom"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "platform": "darwin"})
+    )
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-platform-dependencies")
+    assert locker.written_data == expected
+
+    # We should only have 2 installs:
+    # C,D since the mocked python version is not compatible
+    # with B's python constraint and A is optional
+    assert isinstance(installer.executor, TestExecutor)
+    assert installer.executor.installations_count == 2
+    assert installer.executor.installations[0].name == "d"
+    assert installer.executor.installations[1].name == "c"
+
+
+def test_run_with_dependencies_extras(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    package_b.extras = {canonicalize_name("foo"): [get_dependency("C", "^1.0")]}
+    package_b.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    )
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "extras": ["foo"]})
+    )
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies-extras")
+    assert locker.written_data == expected
+
+
+def test_run_with_dependencies_nested_extras(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    dependency_c = Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    dependency_b = Factory.create_dependency(
+        "B", {"version": "^1.0", "optional": True, "extras": ["C"]}
+    )
+    dependency_a = Factory.create_dependency("A", {"version": "^1.0", "extras": ["B"]})
+
+    package_b.extras = {canonicalize_name("c"): [dependency_c]}
+    package_b.add_dependency(dependency_c)
+
+    package_a.add_dependency(dependency_b)
+    package_a.extras = {canonicalize_name("b"): [dependency_b]}
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    package.add_dependency(dependency_a)
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies-nested-extras")
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize(
+    "enabled_extras",
+    [
+        ([]),
+        (["all"]),
+        (["nested"]),
+        (["install", "download"]),
+        (["install"]),
+        (["download"]),
+    ],
+)
+@pytest.mark.parametrize("top_level_dependency", [True, False])
+def test_solver_resolves_self_referential_extras(
+    enabled_extras: list[str],
+    top_level_dependency: bool,
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    create_package: PackageFactory,
+) -> None:
+    dependency = (
+        create_package(
+            "A",
+            str(package.version),
+            extras={
+                "download": ["download-package"],
+                "install": ["install-package"],
+                "py38": ["py38-package ; python_version == '3.8'"],
+                "py310": ["py310-package ; python_version > '3.8'"],
+                "all": ["a[download,install]"],
+                "py": ["a[py38,py310]"],
+                "nested": ["a[all]"],
+            },
+        )
+        .to_dependency()
+        .with_features(enabled_extras)
+    )
+
+    if not top_level_dependency:
+        dependency = create_package(
+            "B", "1.0", dependencies=[dependency]
+        ).to_dependency()
+
+    package.add_dependency(dependency)
+
+    result = installer.run()
+    assert result == 0
+
+    name = "-".join(
+        [
+            "with-self-referencing-extras",
+            *enabled_extras,
+            "top" if top_level_dependency else "deep",
+        ]
+    )
+
+    expected = fixture(name)
+    assert locker.written_data == expected
+
+
+def test_solver_resolves_self_referential_extras_with_markers(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    create_package: PackageFactory,
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "extras": ["all"]})
+    )
+
+    create_package(
+        "A",
+        str(package.version),
+        extras={
+            "download": ["download-package"],
+            "install": ["install-package"],
+            "all": ["a[download,install] ; python_version < '3.9'"],
+        },
+    )
+
+    result = installer.run()
+    assert result == 0
+
+    name = "-".join(["with-self-referencing-extras", "b", "markers"])
+
+    # FIXME: At the time of writing this test case, the markers from self-ref extras are not
+    #  correctly propagated into the dependency specs. For example, given this case,
+    #  the package "install-package" should have a final marker of
+    #  "extra == 'install' or extra == 'all' and python_version < '3.9'".
+    expected = fixture(name)
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize("root", [True, False])
+@pytest.mark.parametrize("locked", [False, True])
+@pytest.mark.parametrize("extra", [None, "extra-one", "extra-two"])
+def test_run_with_conflicting_dependency_extras(
+    installer: Installer,
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    repo: Repository,
+    config: Config,
+    package: ProjectPackage,
+    extra: str | None,
+    locked: bool,
+    root: bool,
+) -> None:
+    """
+    - https://github.com/python-poetry/poetry/issues/6419
+
+    Tests resolution of extras with conflicting dependencies. Tests in both as direct dependencies of
+    root package and as transitive dependencies.
+    """
+    # A package with two optional dependencies, one for each extra
+    # If root, this is the root package, otherwise an intermediate package
+    main_package = package if root else get_package("intermediate-dep", "1.0.0")
+
+    # Two conflicting versions of a dependency, one in each extra
+    conflicting_dep_one_pkg = get_package("conflicting-dep", "1.1.0")
+    conflicting_dep_two_pkg = get_package("conflicting-dep", "1.2.0")
+
+    conflicting_dep_one = Factory.create_dependency(
+        "conflicting-dep",
+        {
+            "version": "1.1.0",
+            "markers": "extra == 'extra-one' and extra != 'extra-two'",
+            "optional": True,
+        },
+    )
+    conflicting_dep_two = Factory.create_dependency(
+        "conflicting-dep",
+        {
+            "version": "1.2.0",
+            "markers": "extra != 'extra-one' and extra == 'extra-two'",
+            "optional": True,
+        },
+    )
+
+    # Include both just for extra validation that our marker validation works as expected
+    main_package.extras = {
+        canonicalize_name("extra-one"): [conflicting_dep_one, conflicting_dep_two],
+        canonicalize_name("extra-two"): [conflicting_dep_one, conflicting_dep_two],
+    }
+    main_package.add_dependency(conflicting_dep_one)
+    main_package.add_dependency(conflicting_dep_two)
+
+    repo.add_package(conflicting_dep_one_pkg)
+    repo.add_package(conflicting_dep_two_pkg)
+    if not root:
+        repo.add_package(main_package)
+
+    # If we have an intermediate package, add extras to our root package
+    if not root:
+        extra_one_dep = Factory.create_dependency(
+            "intermediate-dep",
+            {
+                "version": "1.0.0",
+                "markers": "extra == 'root-extra-one' and extra != 'root-extra-two'",
+                "extras": ["extra-one"],
+                "optional": True,
+            },
+        )
+        extra_two_dep = Factory.create_dependency(
+            "intermediate-dep",
+            {
+                "version": "1.0.0",
+                "markers": "extra != 'root-extra-one' and extra == 'root-extra-two'",
+                "extras": ["extra-two"],
+                "optional": True,
+            },
+        )
+        package.add_dependency(extra_one_dep)
+        package.add_dependency(extra_two_dep)
+        # Include both just for extra validation that our marker validation works as expected
+        package.extras = {
+            canonicalize_name("root-extra-one"): [extra_one_dep, extra_two_dep],
+            canonicalize_name("root-extra-two"): [extra_one_dep, extra_two_dep],
+        }
+
+    fixture_name = "with-conflicting-dependency-extras-" + (
+        "root" if root else "transitive"
+    )
+    locker.locked(locked)
+    if locked:
+        locker.mock_lock_data(dict(fixture(fixture_name)))
+
+    if extra is not None:
+        extras = [f"root-{extra}"] if not root else [extra]
+        installer.extras(extras)
+    result = installer.run()
+    assert result == 0
+
+    if not locked:
+        expected = fixture(fixture_name)
+        assert locker.written_data == expected
+
+    # Results of installation are consistent with the 'extra' input
+    assert isinstance(installer.executor, TestExecutor)
+
+    expected_installations = []
+    if extra == "extra-one":
+        expected_installations.append(conflicting_dep_one_pkg)
+    elif extra == "extra-two":
+        expected_installations.append(conflicting_dep_two_pkg)
+    if not root and extra is not None:
+        expected_installations.append(get_package("intermediate-dep", "1.0.0"))
+
+    assert len(installer.executor.installations) == len(expected_installations)
+    assert set(installer.executor.installations) == set(expected_installations)
+
+
+@pytest.mark.parametrize("locked", [True, False])
+@pytest.mark.parametrize("extra", [None, "cpu", "cuda"])
+def test_run_with_exclusive_extras_different_sources(
+    installer: Installer,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    package: ProjectPackage,
+    extra: str | None,
+    locked: bool,
+) -> None:
+    """
+    - https://github.com/python-poetry/poetry/issues/6409
+    - https://github.com/python-poetry/poetry/issues/6419
+    - https://github.com/python-poetry/poetry/issues/7748
+    - https://github.com/python-poetry/poetry/issues/9537
+    """
+    # Setup repo for each of our sources
+    cpu_repo = Repository("pytorch-cpu")
+    cuda_repo = Repository("pytorch-cuda")
+    pool = RepositoryPool()
+    pool.add_repository(cpu_repo)
+    pool.add_repository(cuda_repo)
+    config.config["repositories"] = {
+        "pytorch-cpu": {"url": "https://download.pytorch.org/whl/cpu"},
+        "pytorch-cuda": {"url": "https://download.pytorch.org/whl/cuda"},
+    }
+
+    # Configure packages that read from each of the different sources
+    torch_cpu_pkg = get_package("torch", "1.11.0+cpu")
+    torch_cpu_pkg._source_reference = "pytorch-cpu"
+    torch_cpu_pkg._source_type = "legacy"
+    torch_cpu_pkg._source_url = "https://download.pytorch.org/whl/cpu"
+    torch_cuda_pkg = get_package("torch", "1.11.0+cuda")
+    torch_cuda_pkg._source_reference = "pytorch-cuda"
+    torch_cuda_pkg._source_type = "legacy"
+    torch_cuda_pkg._source_url = "https://download.pytorch.org/whl/cuda"
+    cpu_repo.add_package(torch_cpu_pkg)
+    cuda_repo.add_package(torch_cuda_pkg)
+
+    # Depend on each package based on exclusive extras
+    torch_cpu_dep = Factory.create_dependency(
+        "torch",
+        {
+            "version": "1.11.0+cpu",
+            "markers": "extra == 'cpu' and extra != 'cuda'",
+            "source": "pytorch-cpu",
+        },
+    )
+    torch_cuda_dep = Factory.create_dependency(
+        "torch",
+        {
+            "version": "1.11.0+cuda",
+            "markers": "extra != 'cpu' and extra == 'cuda'",
+            "source": "pytorch-cuda",
+        },
+    )
+    package.add_dependency(torch_cpu_dep)
+    package.add_dependency(torch_cuda_dep)
+    # We don't want to cheat by only including the correct dependency in the 'extra' mapping
+    package.extras = {
+        canonicalize_name("cpu"): [torch_cpu_dep, torch_cuda_dep],
+        canonicalize_name("cuda"): [torch_cpu_dep, torch_cuda_dep],
+    }
+
+    # Set locker state
+    locker.locked(locked)
+    if locked:
+        locker.mock_lock_data(dict(fixture("with-exclusive-extras")))
+
+    # Perform install
+    installer = Installer(
+        NullIO(),
+        MockEnv(),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+    if extra is not None:
+        installer.extras([extra])
+    result = installer.run()
+    assert result == 0
+
+    # Results of locking are expected and installation are consistent with the 'extra' input
+    if not locked:
+        expected = fixture("with-exclusive-extras")
+        assert locker.written_data == expected
+    assert isinstance(installer.executor, TestExecutor)
+    if extra is None:
+        assert len(installer.executor.installations) == 0
+    else:
+        assert len(installer.executor.installations) == 1
+        version = f"1.11.0+{extra}"
+        source_url = f"https://download.pytorch.org/whl/{extra}"
+        source_reference = f"pytorch-{extra}"
+        assert installer.executor.installations[0] == Package(
+            "torch",
+            version,
+            source_type="legacy",
+            source_url=source_url,
+            source_reference=source_reference,
+        )
+
+
+@pytest.mark.parametrize("locked", [True, False])
+@pytest.mark.parametrize("extra", [None, "extra-one", "extra-two"])
+def test_run_with_different_dependency_extras(
+    installer: Installer,
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    repo: Repository,
+    config: Config,
+    package: ProjectPackage,
+    extra: str | None,
+    locked: bool,
+) -> None:
+    """
+    - https://github.com/python-poetry/poetry/issues/834
+    - https://github.com/python-poetry/poetry/issues/7748
+
+    This tests different sets of extras in a dependency of the root project. These different dependency extras are
+    themselves conditioned on extras in the root project.
+    """
+    # Three packages in addition to root: demo (direct dependency) and two transitive dep packages
+    demo_pkg = get_package("demo", "1.0.0")
+    transitive_one_pkg = get_package("transitive-dep-one", "1.1.0")
+    transitive_two_pkg = get_package("transitive-dep-two", "1.2.0")
+
+    # Switch each transitive dependency based on extra markers in the 'demo' package
+    transitive_dep_one = Factory.create_dependency(
+        "transitive-dep-one",
+        {
+            "version": "1.1.0",
+            "markers": "extra == 'demo-extra-one' and extra != 'demo-extra-two'",
+            "optional": True,
+        },
+    )
+    transitive_dep_two = Factory.create_dependency(
+        "transitive-dep-two",
+        {
+            "version": "1.2.0",
+            "markers": "extra != 'demo-extra-one' and extra == 'demo-extra-two'",
+            "optional": True,
+        },
+    )
+    # Include both packages in both demo extras, to validate that they're filtered out based on extra markers alone
+    demo_pkg.extras = {
+        canonicalize_name("demo-extra-one"): [
+            get_dependency("transitive-dep-one"),
+            get_dependency("transitive-dep-two"),
+        ],
+        canonicalize_name("demo-extra-two"): [
+            get_dependency("transitive-dep-one"),
+            get_dependency("transitive-dep-two"),
+        ],
+    }
+    demo_pkg.add_dependency(transitive_dep_one)
+    demo_pkg.add_dependency(transitive_dep_two)
+
+    # Now define the demo dependency, similarly switched on extra markers in the root package
+    extra_one_dep = Factory.create_dependency(
+        "demo",
+        {
+            "version": "1.0.0",
+            "markers": "extra == 'extra-one' and extra != 'extra-two'",
+            "extras": ["demo-extra-one"],
+        },
+    )
+    extra_two_dep = Factory.create_dependency(
+        "demo",
+        {
+            "version": "1.0.0",
+            "markers": "extra != 'extra-one' and extra == 'extra-two'",
+            "extras": ["demo-extra-two"],
+        },
+    )
+    package.add_dependency(extra_one_dep)
+    package.add_dependency(extra_two_dep)
+    # Again we don't want to cheat by only including the correct dependency in the 'extra' mapping
+    package.extras = {
+        canonicalize_name("extra-one"): [extra_one_dep, extra_two_dep],
+        canonicalize_name("extra-two"): [extra_one_dep, extra_two_dep],
+    }
+
+    repo.add_package(demo_pkg)
+    repo.add_package(transitive_one_pkg)
+    repo.add_package(transitive_two_pkg)
+
+    locker.locked(locked)
+    if locked:
+        locker.mock_lock_data(dict(fixture("with-dependencies-differing-extras")))
+
+    installer = Installer(
+        NullIO(),
+        MockEnv(),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+    if extra is not None:
+        installer.extras([extra])
+    result = installer.run()
+    assert result == 0
+
+    if not locked:
+        expected = fixture("with-dependencies-differing-extras")
+        assert locker.written_data == expected
+
+    # Results of installation are consistent with the 'extra' input
+    assert isinstance(installer.executor, TestExecutor)
+    if extra is None:
+        assert len(installer.executor.installations) == 0
+    else:
+        assert len(installer.executor.installations) == 2
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+@pytest.mark.parametrize("is_installed", [False, True])
+@pytest.mark.parametrize("with_extras", [False, True])
+@pytest.mark.parametrize("do_update", [False, True])
+@pytest.mark.parametrize("do_sync", [False, True])
+def test_run_installs_extras_with_deps_if_requested(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    installed: CustomInstalledRepository,
+    package: ProjectPackage,
+    is_locked: bool,
+    is_installed: bool,
+    with_extras: bool,
+    do_update: bool,
+    do_sync: bool,
+) -> None:
+    package.extras = {canonicalize_name("foo"): [get_dependency("C")]}
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_d = get_package("D", "1.1")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+    dep_c = Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    dep_c._in_extras = [canonicalize_name("foo")]
+    package.add_dependency(dep_c)
+
+    package_c.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    if is_locked:
+        locker.locked(True)
+        locker.mock_lock_data(fixture("extras-with-dependencies"))
+
+    if is_installed:
+        installed.add_package(package_a)
+        installed.add_package(package_b)
+        installed.add_package(package_c)
+        installed.add_package(package_d)
+
+    if with_extras:
+        installer.extras(["foo"])
+    installer.update(do_update)
+    installer.requires_synchronization(do_sync)
+    result = installer.run()
+    assert result == 0
+
+    if not is_locked:
+        assert locker.written_data == fixture("extras-with-dependencies")
+
+    if with_extras:
+        # A, B, C, D
+        expected_installations_count = 0 if is_installed else 4
+        expected_removals_count = 0
+    else:
+        # A, B
+        expected_installations_count = 0 if is_installed else 2
+        # We only want to uninstall extras if we do a "poetry install" without extras,
+        # not if we do a "poetry update" or "poetry add".
+        expected_removals_count = 2 if is_installed and do_sync else 0
+
+    assert installer.executor.installations_count == expected_installations_count
+    assert installer.executor.removals_count == expected_removals_count
+
+
+def test_installer_with_pypi_repository(
+    package: ProjectPackage,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    env: NullEnv,
+    pypi_repository: PyPiRepository,
+) -> None:
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository)
+
+    installer = Installer(
+        NullIO(), env, package, locker, pool, config, installed=installed
+    )
+
+    package.python_versions = ">=3.7"
+    package.add_dependency(Factory.create_dependency("pytest", "^3.5", groups=["dev"]))
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-pypi-repository")
+    assert locker.written_data == expected
+
+
+def test_run_installs_with_local_file(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    root_dir = Path(__file__).parent.parent.parent
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    file_path = fixture_dir("distributions/demo-0.1.0-py2.py3-none-any.whl")
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"file": str(file_path.relative_to(root_dir))}, root_dir=root_dir
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-file-dependency")
+
+    assert locker.written_data == expected
+    assert installer.executor.installations_count == 2
+
+
+def test_run_installs_wheel_with_no_requires_dist(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    root_dir = Path(__file__).parent.parent.parent
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    file_path = fixture_dir(
+        "wheel_with_no_requires_dist/demo-0.1.0-py2.py3-none-any.whl"
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"file": str(file_path.relative_to(root_dir))}, root_dir=root_dir
+        )
+    )
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-wheel-dependency-no-requires-dist")
+
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 1
+
+
+def test_run_installs_with_local_poetry_directory_and_extras(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    tmpdir: Path,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    root_dir = Path(__file__).parent.parent.parent
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    file_path = fixture_dir("project_with_extras")
+    package.add_dependency(
+        Factory.create_dependency(
+            "project-with-extras",
+            {"path": str(file_path.relative_to(root_dir)), "extras": ["extras_a"]},
+            root_dir=root_dir,
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-directory-dependency-poetry")
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 2
+
+
+@pytest.mark.parametrize("skip_directory", [True, False])
+def test_run_installs_with_local_poetry_directory_and_skip_directory_flag(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    skip_directory: bool,
+) -> None:
+    """When we set Installer.skip_directory(True) no path dependencies should
+    be installed (including transitive dependencies).
+    """
+    root_dir = fixture_dir("directory")
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    directory = root_dir.joinpath("project_with_transitive_directory_dependencies")
+    package.add_dependency(
+        Factory.create_dependency(
+            "project-with-transitive-directory-dependencies",
+            {"path": str(directory.relative_to(root_dir))},
+            root_dir=root_dir,
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("cachy", "0.2.0"))
+
+    installer.skip_directory(skip_directory)
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-directory-dependency-poetry-transitive")
+
+    assert locker.written_data == expected
+
+    assert isinstance(installer.executor, TestExecutor)
+    directory_installs = [
+        p.name for p in installer.executor.installations if p.source_type == "directory"
+    ]
+
+    if skip_directory:
+        assert not directory_installs, directory_installs
+        assert installer.executor.installations_count == 2
+    else:
+        assert directory_installs, directory_installs
+        assert installer.executor.installations_count == 6
+
+
+def test_run_installs_with_local_poetry_file_transitive(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    tmpdir: str,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    root_dir = fixture_dir("directory")
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    directory = fixture_dir("directory").joinpath(
+        "project_with_transitive_file_dependencies"
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "project-with-transitive-file-dependencies",
+            {"path": str(directory.relative_to(root_dir))},
+            root_dir=root_dir,
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("cachy", "0.2.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-file-dependency-transitive")
+
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 4
+
+
+def test_run_installs_with_local_setuptools_directory(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    tmp_path: Path,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    root_dir = tmp_path / "root"
+    package.root_dir = root_dir
+    locker.set_lock_path(root_dir)
+    file_path = shutil.copytree(fixture_dir("project_with_setup"), root_dir / "project")
+    package.add_dependency(
+        Factory.create_dependency(
+            "project-with-setup",
+            {"path": str(file_path.relative_to(root_dir))},
+            root_dir=root_dir,
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("cachy", "0.2.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-directory-dependency-setuptools")
+
+    assert locker.written_data == expected
+    assert installer.executor.installations_count == 3
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_with_prereleases(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0a2",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            }
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0a2")
+    package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "allow-prereleases": True})
+    )
+    package.add_dependency(Factory.create_dependency("B", "^1.1"))
+
+    installer.update(True)
+    installer.whitelist({"B": "^1.1"})
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-prereleases")
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_update_all_with_lock(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": True,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            }
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.1")
+    repo.add_package(get_package("A", "1.0"))
+    repo.add_package(package_a)
+
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    installer.update(True)
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("update-with-lock")
+    assert locker.written_data == expected
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_update_with_locked_extras(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"B": "^1.0", "C": "^1.0"},
+            },
+            {
+                "name": "B",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "C",
+                "version": "1.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "requirements": {"python": "~2.7"},
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": [], "C": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package_a = get_package("A", "1.0")
+    package_a.extras = {canonicalize_name("foo"): [get_dependency("B")]}
+    b_dependency = get_dependency("B", "^1.0", optional=True)
+    b_dependency._in_extras = [canonicalize_name("foo")]
+    c_dependency = get_dependency("C", "^1.0")
+    c_dependency.python_versions = "~2.7"
+    package_a.add_dependency(b_dependency)
+    package_a.add_dependency(c_dependency)
+
+    repo.add_package(package_a)
+    repo.add_package(get_package("B", "1.0"))
+    repo.add_package(get_package("C", "1.1"))
+    repo.add_package(get_package("D", "1.1"))
+
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "extras": ["foo"]})
+    )
+    package.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    installer.update(True)
+    installer.whitelist("D")
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("update-with-locked-extras")
+    assert locker.written_data == expected
+
+
+def test_run_install_duplicate_dependencies_different_constraints(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": ">=4.0"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+    package_b10.add_dependency(Factory.create_dependency("C", "1.2"))
+    package_b20.add_dependency(Factory.create_dependency("C", "1.5"))
+
+    package_c12 = get_package("C", "1.2")
+    package_c15 = get_package("C", "1.5")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+    repo.add_package(package_c12)
+    repo.add_package(package_c15)
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-duplicate-dependencies")
+
+    assert locker.written_data == expected
+
+    assert isinstance(installer.executor, TestExecutor)
+    installs = installer.executor.installations
+    assert installer.executor.installations_count == 3
+    assert installs[0] == package_c12
+    assert installs[1] == package_b10
+    assert installs[2] == package_a
+
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_install_duplicate_dependencies_different_constraints_with_lock(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {
+                    "B": [
+                        {"version": "^1.0", "python": "<4.0"},
+                        {"version": "^2.0", "python": ">=4.0"},
+                    ]
+                },
+            },
+            {
+                "name": "B",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"C": "1.2"},
+                "requirements": {"python": "<4.0"},
+            },
+            {
+                "name": "B",
+                "version": "2.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"C": "1.5"},
+                "requirements": {"python": ">=4.0"},
+            },
+            {
+                "name": "C",
+                "version": "1.2",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "C",
+                "version": "1.5",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": [], "C": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": ">=4.0"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+    package_b10.add_dependency(Factory.create_dependency("C", "1.2"))
+    package_b20.add_dependency(Factory.create_dependency("C", "1.5"))
+
+    package_c12 = get_package("C", "1.2")
+    package_c15 = get_package("C", "1.5")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+    repo.add_package(package_c12)
+    repo.add_package(package_c15)
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-duplicate-dependencies")
+
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 3
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_update_uninstalls_after_removal_transitive_dependency(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"B": {"version": "^1.0", "python": "<2.0"}},
+            },
+            {
+                "name": "B",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<2.0"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+
+    installed.add_package(get_package("A", "1.0"))
+    installed.add_package(get_package("B", "1.0"))
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 1
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_run_install_duplicate_dependencies_different_constraints_with_lock_update(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {
+                    "B": [
+                        {"version": "^1.0", "python": "<2.7"},
+                        {"version": "^2.0", "python": ">=2.7"},
+                    ]
+                },
+            },
+            {
+                "name": "B",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"C": "1.2"},
+                "requirements": {"python": "<2.7"},
+            },
+            {
+                "name": "B",
+                "version": "2.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"C": "1.5"},
+                "requirements": {"python": ">=2.7"},
+            },
+            {
+                "name": "C",
+                "version": "1.2",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+            {
+                "name": "C",
+                "version": "1.5",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": [], "C": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.1")
+    package_a.add_dependency(Factory.create_dependency("B", "^2.0"))
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+    package_b10.add_dependency(Factory.create_dependency("C", "1.2"))
+    package_b20.add_dependency(Factory.create_dependency("C", "1.5"))
+
+    package_c12 = get_package("C", "1.2")
+    package_c15 = get_package("C", "1.5")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+    repo.add_package(package_c12)
+    repo.add_package(package_c15)
+
+    installed.add_package(get_package("A", "1.0"))
+
+    installer.update(True)
+    installer.whitelist(["A"])
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-duplicate-dependencies-update")
+
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 2
+    assert installer.executor.updates_count == 1
+    assert installer.executor.removals_count == 0
+
+
+def test_installer_test_solver_finds_compatible_package_for_dependency_python_not_fully_compatible_with_package_python(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+) -> None:
+    package.python_versions = "~2.7 || ^3.4"
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "^3.5"})
+    )
+
+    package_a101 = get_package("A", "1.0.1")
+    package_a101.python_versions = ">=3.6"
+
+    package_a100 = get_package("A", "1.0.0")
+    package_a100.python_versions = ">=3.5"
+
+    repo.add_package(package_a100)
+    repo.add_package(package_a101)
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-conditional-dependency")
+    assert locker.written_data == expected
+    assert installer.executor.installations_count == 1
+
+
+def test_installer_required_extras_should_not_be_removed_when_updating_single_dependency(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    env: NullEnv,
+    pool: RepositoryPool,
+    config: Config,
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", {"version": "^1.0"}))
+
+    package_a = get_package("A", "1.0.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "extras": ["foo"]})
+    )
+
+    package_b = get_package("B", "1.0.0")
+    package_b.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    )
+    package_b.extras = {canonicalize_name("foo"): [get_dependency("C")]}
+
+    package_c = get_package("C", "1.0.0")
+    package_d = get_package("D", "1.0.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 3
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+    package.add_dependency(Factory.create_dependency("D", "^1.0"))
+    locker.locked(True)
+    locker.mock_lock_data(locker.written_data)
+
+    installed.add_package(package_a)
+    installed.add_package(package_b)
+    installed.add_package(package_c)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+    installer.update(True)
+    installer.whitelist(["D"])
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 1
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+def test_installer_required_extras_should_not_be_removed_when_updating_single_dependency_pypi_repository(
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    env: NullEnv,
+    mocker: MockerFixture,
+    config: Config,
+    pypi_repository: PyPiRepository,
+) -> None:
+    mocker.patch("sys.platform", "darwin")
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "with-transitive-extra-dependency", {"version": "^0.12"}
+        )
+    )
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 3
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+    package.add_dependency(Factory.create_dependency("pytest", "^3.5"))
+
+    locker.locked(True)
+    locker.mock_lock_data(locker.written_data)
+
+    assert isinstance(installer.executor, TestExecutor)
+    for pkg in installer.executor.installations:
+        installed.add_package(pkg)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+    installer.update(True)
+    installer.whitelist(["pytest"])
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 7
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+def test_installer_required_extras_should_be_installed(
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    env: NullEnv,
+    config: Config,
+    pypi_repository: PyPiRepository,
+) -> None:
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "with-extra-dependency", {"version": "^0.12", "extras": ["filecache"]}
+        )
+    )
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 2
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+    locker.locked(True)
+    locker.mock_lock_data(locker.written_data)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 2
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_update_multiple_times_with_split_dependencies_is_idempotent(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "A",
+                "version": "1.0",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"B": ">=1.0"},
+            },
+            {
+                "name": "B",
+                "version": "1.0.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*",
+                "checksum": [],
+                "dependencies": {},
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+            "files": {"A": [], "B": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    package.python_versions = "~2.7 || ^3.4"
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+
+    a10 = get_package("A", "1.0")
+    a11 = get_package("A", "1.1")
+    a11.add_dependency(Factory.create_dependency("B", ">=1.0.1"))
+    a11.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "python": "~2.7"})
+    )
+    a11.add_dependency(
+        Factory.create_dependency("C", {"version": "^2.0", "python": "^3.4"})
+    )
+    b101 = get_package("B", "1.0.1")
+    b110 = get_package("B", "1.1.0")
+    repo.add_package(a10)
+    repo.add_package(a11)
+    repo.add_package(b101)
+    repo.add_package(b110)
+    repo.add_package(get_package("C", "1.0"))
+    repo.add_package(get_package("C", "2.0"))
+    expected = fixture("with-multiple-updates")
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert locker.written_data == expected
+
+    locker.mock_lock_data(locker.written_data)
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert locker.written_data == expected
+
+    locker.mock_lock_data(locker.written_data)
+
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert locker.written_data == expected
+
+
+def test_installer_can_install_dependencies_from_forced_source(
+    locker: Locker,
+    package: ProjectPackage,
+    installed: CustomInstalledRepository,
+    env: NullEnv,
+    config: Config,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(
+        Factory.create_dependency("tomlkit", {"version": "^0.5", "source": "legacy"})
+    )
+
+    pool = RepositoryPool()
+    pool.add_repository(legacy_repository)
+    pool.add_repository(pypi_repository)
+
+    installer = Installer(
+        NullIO(),
+        env,
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(env, pool, config, NullIO()),
+    )
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 1
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+def test_run_installs_with_url_file(
+    installer: Installer, locker: Locker, repo: Repository, package: ProjectPackage
+) -> None:
+    url = "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+    package.add_dependency(Factory.create_dependency("demo", {"url": url}))
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-url-dependency")
+
+    assert locker.written_data == expected
+
+    assert installer.executor.installations_count == 2
+
+
+@pytest.mark.parametrize("env_platform", ["linux", "win32"])
+def test_run_installs_with_same_version_url_files(
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    repo: Repository,
+    package: ProjectPackage,
+    env_platform: str,
+) -> None:
+    urls = {
+        "linux": "https://files.pythonhosted.org/distributions/demo-0.1.0.tar.gz",
+        "win32": (
+            "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+        ),
+    }
+    for platform, url in urls.items():
+        package.add_dependency(
+            Factory.create_dependency(
+                "demo",
+                {"url": url, "markers": f"sys_platform == '{platform}'"},
+            )
+        )
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    installer = Installer(
+        NullIO(),
+        MockEnv(platform=env_platform),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(platform=env_platform),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-same-version-url-dependencies")
+    assert locker.written_data == expected
+    assert isinstance(installer.executor, TestExecutor)
+    assert installer.executor.installations_count == 2
+    demo_package = next(p for p in installer.executor.installations if p.name == "demo")
+    assert demo_package.source_url == urls[env_platform]
+
+
+def test_installer_uses_prereleases_if_they_are_compatible(
+    installer: Installer, locker: Locker, package: ProjectPackage, repo: Repository
+) -> None:
+    package.python_versions = "~2.7 || ^3.4"
+    package.add_dependency(
+        Factory.create_dependency(
+            "prerelease", {"git": "https://github.com/demo/prerelease.git"}
+        )
+    )
+
+    package_b = get_package("b", "2.0.0")
+    package_b.add_dependency(Factory.create_dependency("prerelease", ">=0.19"))
+
+    repo.add_package(package_b)
+
+    result = installer.run()
+    assert result == 0
+
+    locker.locked(True)
+    locker.mock_lock_data(locker.written_data)
+
+    package.add_dependency(Factory.create_dependency("b", "^2.0.0"))
+
+    installer.whitelist(["b"])
+    installer.update(True)
+    result = installer.run()
+    assert result == 0
+
+    assert installer.executor.installations_count == 2
+
+
+def test_installer_does_not_write_lock_file_when_installation_fails(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    mocker: MockerFixture,
+) -> None:
+    repo.add_package(get_package("A", "1.0"))
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+
+    locker.locked(False)
+
+    mocker.patch("poetry.installation.installer.Installer._execute", return_value=1)
+    result = installer.run()
+    assert result == 1  # error
+
+    assert locker._lock_data is None
+
+    assert installer.executor.installations_count == 0
+    assert installer.executor.updates_count == 0
+    assert installer.executor.removals_count == 0
+
+
+@pytest.mark.parametrize("quiet", [True, False])
+def test_run_with_dependencies_quiet(
+    installer: Installer,
+    locker: Locker,
+    repo: Repository,
+    package: ProjectPackage,
+    quiet: bool,
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    installer._io = BufferedIO(Input())
+    installer._io.set_verbosity(Verbosity.QUIET if quiet else Verbosity.NORMAL)
+
+    package.add_dependency(Factory.create_dependency("A", "~1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    expected = fixture("with-dependencies")
+    assert locker.written_data == expected
+
+    output = installer._io.fetch_output()
+    if quiet:
+        assert output == ""
+    else:
+        assert output != ""
+
+
+@pytest.mark.parametrize("lock_version", ("1.1", "2.1"))
+def test_installer_should_use_the_locked_version_of_git_dependencies(
+    installer: Installer,
+    locker: Locker,
+    package: ProjectPackage,
+    repo: Repository,
+    lock_version: str,
+) -> None:
+    lock_data = {
+        "package": [
+            {
+                "name": "demo",
+                "version": "0.1.1",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {"pendulum": ">=1.4.4"},
+                "source": {
+                    "type": "git",
+                    "url": "https://github.com/demo/demo.git",
+                    "reference": "master",
+                    "resolved_reference": "123456",
+                },
+            },
+            {
+                "name": "pendulum",
+                "version": "1.4.4",
+                "optional": False,
+                "platform": "*",
+                "python-versions": "*",
+                "checksum": [],
+                "dependencies": {},
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "platform": "*",
+            "content-hash": "123456789",
+            "files": {"demo": [], "pendulum": []},
+        },
+    }
+    fix_lock_data(lock_data)
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"git": "https://github.com/demo/demo.git", "branch": "master"}
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    result = installer.run()
+    assert result == 0
+
+    assert isinstance(installer.executor, TestExecutor)
+    demo_installation = next(
+        package
+        for package in installer.executor.installations
+        if package.name == "demo"
+    )
+    assert demo_installation == Package(
+        "demo",
+        "0.1.1",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference="master",
+        source_resolved_reference="123456",
+    )
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+def test_installer_should_use_the_locked_version_of_git_dependencies_with_extras(
+    installer: Installer,
+    locker: Locker,
+    package: ProjectPackage,
+    repo: Repository,
+    is_locked: bool,
+) -> None:
+    if is_locked:
+        locker.locked(True)
+        locker.mock_lock_data(fixture("with-vcs-dependency-with-extras"))
+        expected_reference = "123456"
+    else:
+        expected_reference = MOCK_DEFAULT_GIT_REVISION
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "git": "https://github.com/demo/demo.git",
+                "branch": "master",
+                "extras": ["foo"],
+            },
+        )
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("cleo", "1.0.0"))
+
+    result = installer.run()
+    assert result == 0
+
+    assert isinstance(installer.executor, TestExecutor)
+    assert len(installer.executor.installations) == 3
+    demo_installation = next(
+        package
+        for package in installer.executor.installations
+        if package.name == "demo"
+    )
+    assert demo_installation == Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference="master",
+        source_resolved_reference=expected_reference,
+    )
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+def test_installer_should_use_the_locked_version_of_git_dependencies_without_reference(
+    installer: Installer,
+    locker: Locker,
+    package: ProjectPackage,
+    repo: Repository,
+    is_locked: bool,
+) -> None:
+    """
+    If there is no explicit reference (branch or tag or rev) in pyproject.toml,
+    HEAD is used.
+    """
+    if is_locked:
+        locker.locked(True)
+        locker.mock_lock_data(fixture("with-vcs-dependency-without-ref"))
+        expected_reference = "123456"
+    else:
+        expected_reference = MOCK_DEFAULT_GIT_REVISION
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    repo.add_package(get_package("pendulum", "1.4.4"))
+
+    result = installer.run()
+    assert result == 0
+
+    assert isinstance(installer.executor, TestExecutor)
+    assert len(installer.executor.installations) == 2
+    demo_installation = next(
+        package
+        for package in installer.executor.installations
+        if package.name == "demo"
+    )
+    assert demo_installation == Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference="HEAD",
+        source_resolved_reference=expected_reference,
+    )
+
+
+@pytest.mark.parametrize("lock_version", ("2.0", "2.1"))
+@pytest.mark.parametrize("env_platform", ["darwin", "linux"])
+def test_installer_distinguishes_locked_packages_with_local_version_by_source(
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    repo: Repository,
+    package: ProjectPackage,
+    env_platform: str,
+    lock_version: str,
+) -> None:
+    """https://github.com/python-poetry/poetry/issues/6710"""
+    # Require 1.11.0+cpu from pytorch for most platforms, but specify 1.11.0 and pypi on
+    # darwin.
+    package.add_dependency(
+        Factory.create_dependency(
+            "torch",
+            {
+                "version": "1.11.0+cpu",
+                "markers": "sys_platform != 'darwin'",
+                "source": "pytorch",
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "torch",
+            {
+                "version": "1.11.0",
+                "markers": "sys_platform == 'darwin'",
+                "source": "pypi",
+            },
+        )
+    )
+
+    # Locking finds both the pypi and the pytorch packages.
+    lock_data: dict[str, Any] = {
+        "package": [
+            {
+                "name": "torch",
+                "version": "1.11.0",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+            },
+            {
+                "name": "torch",
+                "version": "1.11.0+cpu",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+                "source": {
+                    "type": "legacy",
+                    "url": "https://download.pytorch.org/whl",
+                    "reference": "pytorch",
+                },
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+        },
+    }
+    if lock_version == "2.1":
+        lock_data["package"][0]["groups"] = ["main"]
+        lock_data["package"][0]["markers"] = "sys_platform == 'darwin'"
+        lock_data["package"][1]["groups"] = ["main"]
+        lock_data["package"][1]["markers"] = "sys_platform != 'darwin'"
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    installer = Installer(
+        NullIO(),
+        MockEnv(platform=env_platform),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(platform=env_platform),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+    result = installer.run()
+    assert result == 0
+
+    # Results of installation are consistent with the platform requirements.
+    version = "1.11.0" if env_platform == "darwin" else "1.11.0+cpu"
+    source_type = None if env_platform == "darwin" else "legacy"
+    source_url = (
+        None if env_platform == "darwin" else "https://download.pytorch.org/whl"
+    )
+    source_reference = None if env_platform == "darwin" else "pytorch"
+
+    assert isinstance(installer.executor, TestExecutor)
+    assert len(installer.executor.installations) == 1
+    assert installer.executor.installations[0] == Package(
+        "torch",
+        version,
+        source_type=source_type,
+        source_url=source_url,
+        source_reference=source_reference,
+    )
+
+
+@pytest.mark.parametrize("lock_version", ("2.0", "2.1"))
+@pytest.mark.parametrize("env_platform_machine", ["aarch64", "amd64"])
+def test_installer_distinguishes_locked_packages_with_same_version_by_source(
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    repo: Repository,
+    package: ProjectPackage,
+    env_platform_machine: str,
+    lock_version: str,
+) -> None:
+    """https://github.com/python-poetry/poetry/issues/8303"""
+    package.add_dependency(
+        Factory.create_dependency(
+            "kivy",
+            {
+                "version": "2.2.1",
+                "markers": "platform_machine == 'aarch64'",
+                "source": "pywheels",
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "kivy",
+            {
+                "version": "2.2.1",
+                "markers": "platform_machine != 'aarch64'",
+                "source": "PyPI",
+            },
+        )
+    )
+
+    # Locking finds both the pypi and the pyhweels packages.
+    lock_data: dict[str, Any] = {
+        "package": [
+            {
+                "name": "kivy",
+                "version": "2.2.1",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+            },
+            {
+                "name": "kivy",
+                "version": "2.2.1",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+                "source": {
+                    "type": "legacy",
+                    "url": "https://www.piwheels.org/simple",
+                    "reference": "pywheels",
+                },
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+        },
+    }
+    if lock_version == "2.1":
+        lock_data["package"][0]["groups"] = ["main"]
+        lock_data["package"][0]["markers"] = "platform_machine != 'aarch64'"
+        lock_data["package"][1]["groups"] = ["main"]
+        lock_data["package"][1]["markers"] = "platform_machine == 'aarch64'"
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    installer = Installer(
+        NullIO(),
+        MockEnv(platform_machine=env_platform_machine),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(platform_machine=env_platform_machine),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+    result = installer.run()
+    assert result == 0
+
+    # Results of installation are consistent with the platform requirements.
+    version = "2.2.1"
+    if env_platform_machine == "aarch64":
+        source_type = "legacy"
+        source_url = "https://www.piwheels.org/simple"
+        source_reference = "pywheels"
+    else:
+        source_type = None
+        source_url = None
+        source_reference = None
+
+    assert isinstance(installer.executor, TestExecutor)
+    assert len(installer.executor.installations) == 1
+    assert installer.executor.installations[0] == Package(
+        "kivy",
+        version,
+        source_type=source_type,
+        source_url=source_url,
+        source_reference=source_reference,
+    )
+
+
+@pytest.mark.parametrize("lock_version", ("2.0", "2.1"))
+@pytest.mark.parametrize("env_platform", ["darwin", "linux"])
+def test_explicit_source_dependency_with_direct_origin_dependency(
+    pool: RepositoryPool,
+    locker: Locker,
+    installed: CustomInstalledRepository,
+    config: Config,
+    repo: Repository,
+    package: ProjectPackage,
+    env_platform: str,
+    lock_version: str,
+) -> None:
+    """
+    A dependency with explicit source should not be satisfied by
+    a direct origin dependency even if there is a version match.
+    """
+    demo_url = (
+        "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "markers": "sys_platform != 'darwin'",
+                "url": demo_url,
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "version": "0.1.0",
+                "markers": "sys_platform == 'darwin'",
+                "source": "repo",
+            },
+        )
+    )
+    # The url demo dependency depends on pendulum.
+    repo.add_package(get_package("pendulum", "1.4.4"))
+    repo.add_package(get_package("demo", "0.1.0"))
+
+    # Locking finds both the direct origin and the explicit source packages.
+    lock_data: dict[str, Any] = {
+        "package": [
+            {
+                "name": "demo",
+                "version": "0.1.0",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+                "dependencies": {"pendulum": ">=1.4.4"},
+                "source": {
+                    "type": "url",
+                    "url": demo_url,
+                },
+            },
+            {
+                "name": "demo",
+                "version": "0.1.0",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+                "source": {
+                    "type": "legacy",
+                    "url": "https://www.demo.org/simple",
+                    "reference": "repo",
+                },
+            },
+            {
+                "name": "pendulum",
+                "version": "1.4.4",
+                "optional": False,
+                "files": [],
+                "python-versions": "*",
+            },
+        ],
+        "metadata": {
+            "lock-version": lock_version,
+            "python-versions": "*",
+            "content-hash": "123456789",
+        },
+    }
+    if lock_version == "2.1":
+        for locked_package in lock_data["package"]:
+            locked_package["groups"] = ["main"]
+        lock_data["package"][0]["markers"] = "sys_platform != 'darwin'"
+        lock_data["package"][1]["markers"] = "sys_platform == 'darwin'"
+        lock_data["package"][2]["markers"] = "sys_platform != 'darwin'"
+    locker.locked(True)
+    locker.mock_lock_data(lock_data)
+    installer = Installer(
+        NullIO(),
+        MockEnv(platform=env_platform),
+        package,
+        locker,
+        pool,
+        config,
+        installed=installed,
+        executor=TestExecutor(
+            MockEnv(platform=env_platform),
+            pool,
+            config,
+            NullIO(),
+        ),
+    )
+
+    result = installer.run()
+
+    assert result == 0
+    assert isinstance(installer.executor, TestExecutor)
+    if env_platform == "linux":
+        assert set(installer.executor.installations) == {
+            Package("pendulum", "1.4.4"),
+            Package(
+                "demo",
+                "0.1.0",
+                source_type="url",
+                source_url=demo_url,
+            ),
+        }
+    else:
+        assert installer.executor.installations == [
+            Package(
+                "demo",
+                "0.1.0",
+                source_type="legacy",
+                source_url="https://www.demo.org/simple",
+                source_reference="repo",
+            )
+        ]
diff --git b/tests/installation/test_wheel_installer.py a/tests/installation/test_wheel_installer.py
new file mode 100644
index 0000000..98e3f4c
--- /dev/null
+++ a/tests/installation/test_wheel_installer.py
@@ -0,0 +1,83 @@
+from __future__ import annotations
+
+import re
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.constraints.version import parse_constraint
+
+from poetry.installation.wheel_installer import WheelInstaller
+from poetry.utils.env import MockEnv
+
+
+if TYPE_CHECKING:
+    from pytest import TempPathFactory
+
+    from tests.types import FixtureDirGetter
+
+
+@pytest.fixture
+def env(tmp_path: Path) -> MockEnv:
+    return MockEnv(path=tmp_path)
+
+
+@pytest.fixture(scope="module")
+def demo_wheel(fixture_dir: FixtureDirGetter) -> Path:
+    return fixture_dir("distributions/demo-0.1.0-py2.py3-none-any.whl")
+
+
+@pytest.fixture(scope="module")
+def default_installation(tmp_path_factory: TempPathFactory, demo_wheel: Path) -> Path:
+    env = MockEnv(path=tmp_path_factory.mktemp("default_install"))
+    installer = WheelInstaller(env)
+    installer.install(demo_wheel)
+    return Path(env.paths["purelib"])
+
+
+def test_default_installation_source_dir_content(default_installation: Path) -> None:
+    source_dir = default_installation / "demo"
+    assert source_dir.exists()
+    assert (source_dir / "__init__.py").exists()
+
+
+def test_default_installation_dist_info_dir_content(default_installation: Path) -> None:
+    dist_info_dir = default_installation / "demo-0.1.0.dist-info"
+    assert dist_info_dir.exists()
+    assert (dist_info_dir / "INSTALLER").exists()
+    assert (dist_info_dir / "METADATA").exists()
+    assert (dist_info_dir / "RECORD").exists()
+    assert (dist_info_dir / "WHEEL").exists()
+
+
+def test_installer_file_contains_valid_version(default_installation: Path) -> None:
+    installer_file = default_installation / "demo-0.1.0.dist-info" / "INSTALLER"
+    with open(installer_file, encoding="utf-8") as f:
+        installer_content = f.read()
+    match = re.match(r"Poetry (?P<version>.*)", installer_content)
+    assert match
+    parse_constraint(match.group("version"))  # must not raise an error
+
+
+def test_default_installation_no_bytecode(default_installation: Path) -> None:
+    cache_dir = default_installation / "demo" / "__pycache__"
+    assert not cache_dir.exists()
+
+
+@pytest.mark.parametrize("compile", [True, False])
+def test_enable_bytecode_compilation(
+    env: MockEnv, demo_wheel: Path, compile: bool
+) -> None:
+    installer = WheelInstaller(env)
+    installer.enable_bytecode_compilation(compile)
+    installer.install(demo_wheel)
+    cache_dir = Path(env.paths["purelib"]) / "demo" / "__pycache__"
+    if compile:
+        assert cache_dir.exists()
+        assert list(cache_dir.glob("*.pyc"))
+        assert not list(cache_dir.glob("*.opt-1.pyc"))
+        assert not list(cache_dir.glob("*.opt-2.pyc"))
+    else:
+        assert not cache_dir.exists()
diff --git b/tests/puzzle/test_provider.py a/tests/puzzle/test_provider.py
new file mode 100644
index 0000000..e4fa5c8
--- /dev/null
+++ a/tests/puzzle/test_provider.py
@@ -0,0 +1,891 @@
+from __future__ import annotations
+
+import shutil
+
+from pathlib import Path
+from subprocess import CalledProcessError
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+
+from cleo.io.null_io import NullIO
+from packaging.utils import canonicalize_name
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.directory_dependency import DirectoryDependency
+from poetry.core.packages.file_dependency import FileDependency
+from poetry.core.packages.package import Package
+from poetry.core.packages.project_package import ProjectPackage
+from poetry.core.packages.url_dependency import URLDependency
+from poetry.core.packages.vcs_dependency import VCSDependency
+
+from poetry.factory import Factory
+from poetry.inspection.info import PackageInfo
+from poetry.packages import DependencyPackage
+from poetry.puzzle.provider import IncompatibleConstraintsError
+from poetry.puzzle.provider import Provider
+from poetry.repositories.exceptions import PackageNotFoundError
+from poetry.repositories.repository import Repository
+from poetry.repositories.repository_pool import Priority
+from poetry.repositories.repository_pool import RepositoryPool
+from poetry.utils.env import EnvCommandError
+from poetry.utils.env import MockEnv as BaseMockEnv
+from tests.helpers import get_dependency
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from pytest_mock import MockerFixture
+
+    from tests.types import FixtureDirGetter
+
+
+SOME_URL = "https://example.com/path.tar.gz"
+
+
+class MockEnv(BaseMockEnv):
+    def run(self, bin: str, *args: str, **kwargs: Any) -> str:
+        raise EnvCommandError(CalledProcessError(1, "python", output=""))
+
+
+@pytest.fixture
+def root() -> ProjectPackage:
+    return ProjectPackage("root", "1.2.3")
+
+
+@pytest.fixture
+def repository() -> Repository:
+    return Repository("repo")
+
+
+@pytest.fixture
+def pool(repository: Repository) -> RepositoryPool:
+    pool = RepositoryPool()
+    pool.add_repository(repository)
+
+    return pool
+
+
+@pytest.fixture
+def provider(root: ProjectPackage, pool: RepositoryPool) -> Provider:
+    return Provider(root, pool, NullIO())
+
+
+@pytest.mark.parametrize(
+    "dependency, expected",
+    [
+        (Dependency("foo", "<2"), [Package("foo", "1")]),
+        (Dependency("foo", "<2", extras=["bar"]), [Package("foo", "1")]),
+        (Dependency("foo", ">=1"), [Package("foo", "2"), Package("foo", "1")]),
+        (Dependency("foo", ">=1a"), [Package("foo", "2"), Package("foo", "1")]),
+        (
+            Dependency("foo", ">=1", allows_prereleases=True),
+            [
+                Package("foo", "3a"),
+                Package("foo", "2"),
+                Package("foo", "2a"),
+                Package("foo", "1"),
+            ],
+        ),
+    ],
+)
+def test_search_for(
+    provider: Provider,
+    repository: Repository,
+    dependency: Dependency,
+    expected: list[Package],
+) -> None:
+    foo1 = Package("foo", "1")
+    foo2a = Package("foo", "2a")
+    foo2 = Package("foo", "2")
+    foo3a = Package("foo", "3a")
+    repository.add_package(foo1)
+    repository.add_package(foo2a)
+    repository.add_package(foo2)
+    repository.add_package(foo3a)
+
+    assert provider.search_for(dependency) == expected
+
+
+@pytest.mark.parametrize(
+    "dependency, direct_origin_dependency, expected_before, expected_after",
+    [
+        (
+            Dependency("foo", ">=1"),
+            URLDependency("foo", SOME_URL),
+            [Package("foo", "3")],
+            [Package("foo", "2a", source_type="url", source_url=SOME_URL)],
+        ),
+        (
+            Dependency("foo", ">=2"),
+            URLDependency("foo", SOME_URL),
+            [Package("foo", "3")],
+            [Package("foo", "3")],
+        ),
+        (
+            Dependency("foo", ">=1", extras=["bar"]),
+            URLDependency("foo", SOME_URL),
+            [Package("foo", "3")],
+            [Package("foo", "2a", source_type="url", source_url=SOME_URL)],
+        ),
+        (
+            Dependency("foo", ">=1"),
+            URLDependency("foo", SOME_URL, extras=["baz"]),
+            [Package("foo", "3")],
+            [Package("foo", "2a", source_type="url", source_url=SOME_URL)],
+        ),
+        (
+            Dependency("foo", ">=1", extras=["bar"]),
+            URLDependency("foo", SOME_URL, extras=["baz"]),
+            [Package("foo", "3")],
+            [Package("foo", "2a", source_type="url", source_url=SOME_URL)],
+        ),
+    ],
+)
+def test_search_for_direct_origin_and_extras(
+    provider: Provider,
+    repository: Repository,
+    mocker: MockerFixture,
+    dependency: Dependency,
+    direct_origin_dependency: Dependency,
+    expected_before: list[Package],
+    expected_after: list[Package],
+) -> None:
+    foo2a_direct_origin = Package("foo", "2a", source_type="url", source_url=SOME_URL)
+    mocker.patch(
+        "poetry.puzzle.provider.Provider.search_for_direct_origin_dependency",
+        return_value=foo2a_direct_origin,
+    )
+    foo2a = Package("foo", "2a")
+    foo3 = Package("foo", "3")
+    repository.add_package(foo2a)
+    repository.add_package(foo3)
+
+    assert provider.search_for(dependency) == expected_before
+    assert provider.search_for(direct_origin_dependency) == [foo2a_direct_origin]
+    assert provider.search_for(dependency) == expected_after
+
+
+@pytest.mark.parametrize("value", [True, False])
+def test_search_for_vcs_retains_develop_flag(provider: Provider, value: bool) -> None:
+    dependency = VCSDependency(
+        "demo", "git", "https://github.com/demo/demo.git", develop=value
+    )
+    package = provider.search_for_direct_origin_dependency(dependency)
+    assert package.develop == value
+
+
+def test_search_for_vcs_setup_egg_info(provider: Provider) -> None:
+    dependency = VCSDependency("demo", "git", "https://github.com/demo/demo.git")
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_vcs_setup_egg_info_with_extras(provider: Provider) -> None:
+    dependency = VCSDependency(
+        "demo", "git", "https://github.com/demo/demo.git", extras=["foo"]
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_vcs_read_setup(provider: Provider, mocker: MockerFixture) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=MockEnv())
+
+    dependency = VCSDependency("demo", "git", "https://github.com/demo/demo.git")
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_vcs_read_setup_with_extras(
+    provider: Provider, mocker: MockerFixture
+) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=MockEnv())
+
+    dependency = VCSDependency(
+        "demo", "git", "https://github.com/demo/demo.git", extras=["foo"]
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+
+
+def test_search_for_vcs_read_setup_raises_error_if_no_version(
+    provider: Provider, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "poetry.inspection.info.get_pep517_metadata",
+        return_value=PackageInfo(name="demo", version=None),
+    )
+
+    dependency = VCSDependency("demo", "git", "https://github.com/demo/no-version.git")
+
+    with pytest.raises(RuntimeError):
+        provider.search_for_direct_origin_dependency(dependency)
+
+
+@pytest.mark.parametrize("directory", ["demo", "non-canonical-name"])
+def test_search_for_directory_setup_egg_info(
+    provider: Provider, directory: str, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / directory, tmp_path / "project"
+    )
+    dependency = DirectoryDependency("demo", path)
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_directory_setup_egg_info_with_extras(
+    provider: Provider, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo", tmp_path / "project"
+    )
+
+    dependency = DirectoryDependency("demo", path, extras=["foo"])
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+@pytest.mark.parametrize("directory", ["demo", "non-canonical-name"])
+def test_search_for_directory_setup_with_base(
+    provider: Provider, directory: str, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / directory, tmp_path / "project"
+    )
+
+    dependency = DirectoryDependency("demo", path, base=path)
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+    assert package.root_dir == path
+
+
+def test_search_for_directory_setup_read_setup(
+    provider: Provider,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=MockEnv())
+
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo", tmp_path / "project"
+    )
+    dependency = DirectoryDependency("demo", path)
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_directory_setup_read_setup_with_extras(
+    provider: Provider,
+    mocker: MockerFixture,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    mocker.patch("poetry.utils.env.EnvManager.get", return_value=MockEnv())
+
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo", tmp_path / "project"
+    )
+
+    dependency = DirectoryDependency("demo", path, extras=["foo"])
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+
+    required = {r for r in package.requires if not r.is_optional()}
+    optional = {r for r in package.requires if r.is_optional()}
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {get_dependency("tomlkit"), get_dependency("cleo")}
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_directory_setup_read_setup_with_no_dependencies(
+    provider: Provider, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "no-dependencies",
+        tmp_path / "project",
+    )
+
+    dependency = DirectoryDependency("demo", path)
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.2"
+    assert package.requires == []
+    assert package.extras == {}
+
+
+def test_search_for_directory_poetry(
+    provider: Provider, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(fixture_dir("project_with_extras"), tmp_path / "project")
+
+    dependency = DirectoryDependency("project-with-extras", path)
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "project-with-extras"
+    assert package.version.text == "1.2.3"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert not required
+    assert optional == {
+        get_dependency("cachy", ">=0.2.0"),
+        get_dependency("pendulum", ">=1.4.4"),
+    }
+    extras_a = canonicalize_name("extras-a")
+    extras_b = canonicalize_name("extras-b")
+    assert set(package.extras) == {extras_a, extras_b}
+    assert set(package.extras[extras_a]) == {get_dependency("pendulum", ">=1.4.4")}
+    assert set(package.extras[extras_b]) == {get_dependency("cachy", ">=0.2.0")}
+
+
+def test_search_for_directory_poetry_with_extras(
+    provider: Provider, fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    path = shutil.copytree(fixture_dir("project_with_extras"), tmp_path / "project")
+
+    dependency = DirectoryDependency("project-with-extras", path, extras=["extras_a"])
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "project-with-extras"
+    assert package.version.text == "1.2.3"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert not required
+    assert optional == {
+        get_dependency("cachy", ">=0.2.0"),
+        get_dependency("pendulum", ">=1.4.4"),
+    }
+    extras_a = canonicalize_name("extras-a")
+    extras_b = canonicalize_name("extras-b")
+    assert set(package.extras) == {extras_a, extras_b}
+    assert set(package.extras[extras_a]) == {get_dependency("pendulum", ">=1.4.4")}
+    assert set(package.extras[extras_b]) == {get_dependency("cachy", ">=0.2.0")}
+
+
+def test_search_for_file_sdist(
+    provider: Provider, fixture_dir: FixtureDirGetter
+) -> None:
+    dependency = FileDependency(
+        "demo",
+        fixture_dir("distributions") / "demo-0.1.0.tar.gz",
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.0"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {
+        get_dependency("cleo"),
+        get_dependency("tomlkit"),
+    }
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_file_sdist_with_extras(
+    provider: Provider, fixture_dir: FixtureDirGetter
+) -> None:
+    dependency = FileDependency(
+        "demo",
+        fixture_dir("distributions") / "demo-0.1.0.tar.gz",
+        extras=["foo"],
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.0"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {
+        get_dependency("cleo"),
+        get_dependency("tomlkit"),
+    }
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_file_wheel(
+    provider: Provider, fixture_dir: FixtureDirGetter
+) -> None:
+    dependency = FileDependency(
+        "demo",
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl",
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.0"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {
+        get_dependency("cleo"),
+        get_dependency("tomlkit"),
+    }
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_search_for_file_wheel_with_extras(
+    provider: Provider, fixture_dir: FixtureDirGetter
+) -> None:
+    dependency = FileDependency(
+        "demo",
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl",
+        extras=["foo"],
+    )
+
+    package = provider.search_for_direct_origin_dependency(dependency)
+
+    assert package.name == "demo"
+    assert package.version.text == "0.1.0"
+
+    required = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if not r.is_optional()
+    }
+    optional = {
+        r for r in sorted(package.requires, key=lambda r: r.name) if r.is_optional()
+    }
+    assert required == {get_dependency("pendulum", ">=1.4.4")}
+    assert optional == {
+        get_dependency("cleo"),
+        get_dependency("tomlkit"),
+    }
+    assert package.extras == {
+        "foo": [get_dependency("cleo")],
+        "bar": [get_dependency("tomlkit")],
+    }
+
+
+def test_complete_package_merges_same_source_and_no_source(
+    provider: Provider, root: ProjectPackage
+) -> None:
+    foo_no_source_1 = get_dependency("foo", ">=1")
+    foo_source_1 = get_dependency("foo", "!=1.1.*")
+    foo_source_1.source_name = "source"
+    foo_source_2 = get_dependency("foo", "!=1.2.*")
+    foo_source_2.source_name = "source"
+    foo_no_source_2 = get_dependency("foo", "<2")
+
+    root.add_dependency(foo_no_source_1)
+    root.add_dependency(foo_source_1)
+    root.add_dependency(foo_source_2)
+    root.add_dependency(foo_no_source_2)
+
+    complete_package = provider.complete_package(
+        DependencyPackage(root.to_dependency(), root)
+    )
+
+    requires = complete_package.package.all_requires
+    assert len(requires) == 1
+    assert requires[0].source_name == "source"
+    assert str(requires[0].constraint) in {
+        ">=1,<1.1 || >=1.3,<2",
+        ">=1,<1.1.dev0 || >=1.3.dev0,<2",
+        ">=1,<1.1.0 || >=1.3.0,<2",
+        ">=1,<1.1.0.dev0 || >=1.3.0.dev0,<2",
+    }
+
+
+def test_complete_package_does_not_merge_different_source_names(
+    provider: Provider, root: ProjectPackage
+) -> None:
+    foo_source_1 = get_dependency("foo")
+    foo_source_1.source_name = "source_1"
+    foo_source_2 = get_dependency("foo")
+    foo_source_2.source_name = "source_2"
+
+    root.add_dependency(foo_source_1)
+    root.add_dependency(foo_source_2)
+
+    with pytest.raises(IncompatibleConstraintsError) as e:
+        provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    expected = """\
+Incompatible constraints in requirements of root (1.2.3):
+foo ; source=source_2
+foo ; source=source_1"""
+
+    assert str(e.value) == expected
+
+
+def test_complete_package_merges_same_source_type_and_no_source(
+    provider: Provider, root: ProjectPackage, fixture_dir: FixtureDirGetter
+) -> None:
+    project_dir = fixture_dir("with_conditional_path_deps")
+    path = (project_dir / "demo_one").as_posix()
+
+    root.add_dependency(Factory.create_dependency("demo", ">=1.0"))
+    root.add_dependency(Factory.create_dependency("demo", {"path": path}))
+    root.add_dependency(Factory.create_dependency("demo", {"path": path}))  # duplicate
+    root.add_dependency(Factory.create_dependency("demo", "<2.0"))
+
+    complete_package = provider.complete_package(
+        DependencyPackage(root.to_dependency(), root)
+    )
+
+    requires = complete_package.package.all_requires
+    assert len(requires) == 1
+    assert requires[0].source_url == path
+    assert str(requires[0].constraint) == "1.2.3"
+
+
+def test_complete_package_does_not_merge_different_source_types(
+    provider: Provider, root: ProjectPackage, fixture_dir: FixtureDirGetter
+) -> None:
+    project_dir = fixture_dir("with_conditional_path_deps")
+    for folder in ["demo_one", "demo_two"]:
+        path = (project_dir / folder).as_posix()
+        root.add_dependency(Factory.create_dependency("demo", {"path": path}))
+
+    with pytest.raises(IncompatibleConstraintsError) as e:
+        provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    expected = f"""\
+Incompatible constraints in requirements of root (1.2.3):
+demo @ {project_dir.as_uri()}/demo_two (1.2.3)
+demo @ {project_dir.as_uri()}/demo_one (1.2.3)"""
+
+    assert str(e.value) == expected
+
+
+def test_complete_package_does_not_merge_different_source_type_and_name(
+    provider: Provider, root: ProjectPackage, fixture_dir: FixtureDirGetter
+) -> None:
+    project_dir = fixture_dir("with_conditional_path_deps")
+    path = (project_dir / "demo_one").as_posix()
+
+    dep_with_source_name = Factory.create_dependency("demo", ">=1.0")
+    dep_with_source_name.source_name = "source"
+    root.add_dependency(dep_with_source_name)
+    root.add_dependency(Factory.create_dependency("demo", {"path": path}))
+
+    with pytest.raises(IncompatibleConstraintsError) as e:
+        provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    expected = f"""\
+Incompatible constraints in requirements of root (1.2.3):
+demo @ {project_dir.as_uri()}/demo_one (1.2.3)
+demo (>=1.0) ; source=source"""
+
+    assert str(e.value) == expected
+
+
+def test_complete_package_does_not_merge_different_subdirectories(
+    provider: Provider, root: ProjectPackage
+) -> None:
+    dependency_one = Factory.create_dependency(
+        "one",
+        {
+            "git": "https://github.com/demo/subdirectories.git",
+            "subdirectory": "one",
+        },
+    )
+    dependency_one_copy = Factory.create_dependency(
+        "one",
+        {
+            "git": "https://github.com/demo/subdirectories.git",
+            "subdirectory": "one-copy",
+        },
+    )
+
+    root.add_dependency(dependency_one)
+    root.add_dependency(dependency_one_copy)
+
+    with pytest.raises(IncompatibleConstraintsError) as e:
+        provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    expected = """\
+Incompatible constraints in requirements of root (1.2.3):
+one @ git+https://github.com/demo/subdirectories.git#subdirectory=one-copy (1.0.0)
+one @ git+https://github.com/demo/subdirectories.git#subdirectory=one (1.0.0)"""
+
+    assert str(e.value) == expected
+
+
+@pytest.mark.parametrize("source_name", [None, "repo"])
+def test_complete_package_with_extras_preserves_source_name(
+    provider: Provider, repository: Repository, source_name: str | None
+) -> None:
+    package_a = Package("A", "1.0")
+    package_b = Package("B", "1.0")
+    dep = get_dependency("B", "^1.0", optional=True)
+    package_a.add_dependency(dep)
+    package_a.extras = {canonicalize_name("foo"): [dep]}
+    repository.add_package(package_a)
+    repository.add_package(package_b)
+
+    dependency = Dependency("A", "1.0", extras=["foo"])
+    if source_name:
+        dependency.source_name = source_name
+
+    complete_package = provider.complete_package(
+        DependencyPackage(dependency, package_a)
+    )
+
+    requires = complete_package.package.all_requires
+    assert len(requires) == 2
+    assert requires[0].name == "a"
+    assert requires[0].source_name == source_name
+    assert requires[1].name == "b"
+    assert requires[1].source_name is None
+
+
+@pytest.mark.parametrize("with_extra", [False, True])
+def test_complete_package_fetches_optional_vcs_dependency_only_if_requested(
+    provider: Provider, repository: Repository, mocker: MockerFixture, with_extra: bool
+) -> None:
+    optional_vcs_dependency = Factory.create_dependency(
+        "demo", {"git": "https://github.com/demo/demo.git", "optional": True}
+    )
+    package = Package("A", "1.0", features=["foo"] if with_extra else [])
+    package.add_dependency(optional_vcs_dependency)
+    package.extras = {canonicalize_name("foo"): [optional_vcs_dependency]}
+    repository.add_package(package)
+
+    spy = mocker.spy(provider, "_search_for_vcs")
+
+    provider.complete_package(DependencyPackage(package.to_dependency(), package))
+
+    if with_extra:
+        spy.assert_called()
+    else:
+        spy.assert_not_called()
+
+
+def test_complete_package_finds_locked_package_in_explicit_source(
+    root: ProjectPackage, pool: RepositoryPool
+) -> None:
+    package = Package("a", "1.0", source_reference="explicit")
+    explicit_repo = Repository("explicit")
+    explicit_repo.add_package(package)
+    pool.add_repository(explicit_repo, priority=Priority.EXPLICIT)
+
+    root_dependency = get_dependency("a", ">0")
+    root_dependency.source_name = "explicit"
+    root.add_dependency(root_dependency)
+    locked_package = Package("a", "1.0", source_reference="explicit")
+    provider = Provider(root, pool, NullIO(), locked=[locked_package])
+    provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    # transitive dependency without explicit source
+    dependency = get_dependency("a", ">=1")
+
+    locked = provider.get_locked(dependency)
+    assert locked is not None
+    provider.complete_package(locked)  # must not fail
+
+
+def test_complete_package_finds_locked_package_in_other_source(
+    root: ProjectPackage, repository: Repository, pool: RepositoryPool
+) -> None:
+    package = Package("a", "1.0")
+    repository.add_package(package)
+    explicit_repo = Repository("explicit")
+    pool.add_repository(explicit_repo)
+
+    root_dependency = get_dependency("a", ">0")  # no explicit source
+    root.add_dependency(root_dependency)
+    locked_package = Package("a", "1.0", source_reference="explicit")  # explicit source
+    provider = Provider(root, pool, NullIO(), locked=[locked_package])
+    provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    # transitive dependency without explicit source
+    dependency = get_dependency("a", ">=1")
+
+    locked = provider.get_locked(dependency)
+    assert locked is not None
+    provider.complete_package(locked)  # must not fail
+
+
+def test_complete_package_raises_packagenotfound_if_locked_source_not_available(
+    root: ProjectPackage, pool: RepositoryPool, provider: Provider
+) -> None:
+    locked_package = Package("a", "1.0", source_reference="outdated")
+    provider = Provider(root, pool, NullIO(), locked=[locked_package])
+    provider.complete_package(DependencyPackage(root.to_dependency(), root))
+
+    # transitive dependency without explicit source
+    dependency = get_dependency("a", ">=1")
+
+    locked = provider.get_locked(dependency)
+    assert locked is not None
+    with pytest.raises(PackageNotFoundError):
+        provider.complete_package(locked)
+
+
+def test_source_dependency_is_satisfied_by_direct_origin(
+    provider: Provider, repository: Repository
+) -> None:
+    direct_origin_package = Package("foo", "1.1", source_type="url")
+    repository.add_package(Package("foo", "1.0"))
+    provider._direct_origin_packages = {"foo": direct_origin_package}
+    dep = Dependency("foo", ">=1")
+
+    assert provider.search_for(dep) == [direct_origin_package]
+
+
+def test_explicit_source_dependency_is_not_satisfied_by_direct_origin(
+    provider: Provider, repository: Repository
+) -> None:
+    repo_package = Package("foo", "1.0")
+    repository.add_package(repo_package)
+    provider._direct_origin_packages = {"foo": Package("foo", "1.1", source_type="url")}
+    dep = Dependency("foo", ">=1")
+    dep.source_name = repository.name
+
+    assert provider.search_for(dep) == [repo_package]
+
+
+def test_source_dependency_is_not_satisfied_by_incompatible_direct_origin(
+    provider: Provider, repository: Repository
+) -> None:
+    repo_package = Package("foo", "2.0")
+    repository.add_package(repo_package)
+    provider._direct_origin_packages = {"foo": Package("foo", "1.0", source_type="url")}
+    dep = Dependency("foo", ">=2")
+    dep.source_name = repository.name
+
+    assert provider.search_for(dep) == [repo_package]
diff --git b/tests/puzzle/test_solver.py a/tests/puzzle/test_solver.py
new file mode 100644
index 0000000..24f1a5f
--- /dev/null
+++ a/tests/puzzle/test_solver.py
@@ -0,0 +1,5239 @@
+from __future__ import annotations
+
+import re
+import shutil
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+from typing import Literal
+
+import pytest
+
+from cleo.io.buffered_io import BufferedIO
+from packaging.utils import canonicalize_name
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.dependency_group import MAIN_GROUP
+from poetry.core.packages.dependency_group import DependencyGroup
+from poetry.core.packages.package import Package
+from poetry.core.packages.vcs_dependency import VCSDependency
+from poetry.core.version.markers import parse_marker
+
+from poetry.factory import Factory
+from poetry.installation.operations import Update
+from poetry.packages import DependencyPackage
+from poetry.puzzle import Solver
+from poetry.puzzle.exceptions import SolverProblemError
+from poetry.puzzle.provider import IncompatibleConstraintsError
+from poetry.repositories.repository import Repository
+from poetry.repositories.repository_pool import Priority
+from poetry.repositories.repository_pool import RepositoryPool
+from poetry.utils.env import MockEnv
+from tests.helpers import MOCK_DEFAULT_GIT_REVISION
+from tests.helpers import get_dependency
+from tests.helpers import get_package
+
+
+if TYPE_CHECKING:
+    import httpretty
+
+    from cleo.io.null_io import NullIO
+    from poetry.core.packages.project_package import ProjectPackage
+    from pytest_mock import MockerFixture
+
+    from poetry.installation.operations.operation import Operation
+    from poetry.puzzle.provider import Provider
+    from poetry.puzzle.transaction import Transaction
+    from poetry.repositories.legacy_repository import LegacyRepository
+    from poetry.repositories.pypi_repository import PyPiRepository
+    from tests.types import FixtureDirGetter
+    from tests.types import PackageFactory
+
+DEFAULT_SOURCE_REF = (
+    VCSDependency("poetry", "git", "git@github.com:python-poetry/poetry.git").branch
+    or "HEAD"
+)
+
+
+def set_package_python_versions(provider: Provider, python_versions: str) -> None:
+    provider._package.python_versions = python_versions
+    provider._package_python_constraint = provider._package.python_constraint
+
+
+def check_solver_result(
+    transaction: Transaction,
+    expected: list[dict[str, Any]],
+    synchronize: bool = False,
+) -> list[Operation]:
+    for e in expected:
+        if "skipped" not in e:
+            e["skipped"] = False
+
+    result = []
+    ops = transaction.calculate_operations(synchronize=synchronize)
+    for op in ops:
+        if op.job_type == "update":
+            assert isinstance(op, Update)
+            result.append(
+                {
+                    "job": "update",
+                    "from": op.initial_package,
+                    "to": op.target_package,
+                    "skipped": op.skipped,
+                }
+            )
+        else:
+            job = "install"
+            if op.job_type == "uninstall":
+                job = "remove"
+
+            result.append({"job": job, "package": op.package, "skipped": op.skipped})
+
+    assert result == expected
+
+    return ops
+
+
+def test_solver_install_single(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    repo.add_package(package_a)
+
+    transaction = solver.solve([get_dependency("A").name])
+
+    check_solver_result(transaction, [{"job": "install", "package": package_a}])
+
+
+def test_solver_remove_if_no_longer_locked(
+    package: ProjectPackage, pool: RepositoryPool, io: NullIO
+) -> None:
+    package_a = get_package("A", "1.0")
+
+    solver = Solver(package, pool, [package_a], [package_a], io)
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "remove", "package": package_a}])
+
+
+def test_remove_non_installed(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package_a = get_package("A", "1.0")
+    repo.add_package(package_a)
+
+    solver = Solver(package, pool, [], [package_a], io)
+    transaction = solver.solve([])
+
+    check_solver_result(transaction, [])
+
+
+def test_install_non_existing_package_fail(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("B", "1"))
+
+    package_a = get_package("A", "1.0")
+    repo.add_package(package_a)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_install_unpublished_package_fails(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(Factory.create_dependency("B", "1"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1")
+    package_b.add_dependency(Factory.create_dependency("A", "1.0"))
+
+    repo.add_package(package_a)
+
+    # Even though B is installed, it is unpublished and cannot be used during solving.
+    solver = Solver(package, pool, [package_b], [], io)
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_with_deps(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    new_package_b = get_package("B", "1.1")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(new_package_b)
+
+    package_a.add_dependency(get_dependency("B", "<1.1"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_install_honours_not_equal(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    new_package_b11 = get_package("B", "1.1")
+    new_package_b12 = get_package("B", "1.2")
+    new_package_b13 = get_package("B", "1.3")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(new_package_b11)
+    repo.add_package(new_package_b12)
+    repo.add_package(new_package_b13)
+
+    package_a.add_dependency(get_dependency("B", "<=1.3,!=1.3,!=1.2"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": new_package_b11},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_install_with_deps_in_order(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(Factory.create_dependency("C", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    package_b.add_dependency(get_dependency("A", ">=1.0"))
+    package_b.add_dependency(get_dependency("C", ">=1.0"))
+
+    package_c.add_dependency(get_dependency("A", ">=1.0"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_install_installed(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    repo.add_package(package_a)
+
+    solver = Solver(package, pool, [package_a], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction, [{"job": "install", "package": package_a, "skipped": True}]
+    )
+
+
+def test_update_installed(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    new_package_a = get_package("A", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(new_package_a)
+
+    solver = Solver(package, pool, [get_package("A", "1.0")], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction, [{"job": "update", "from": package_a, "to": new_package_a}]
+    )
+
+
+def test_update_with_use_latest(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a = get_package("A", "1.0")
+    new_package_a = get_package("A", "1.1")
+    package_b = get_package("B", "1.0")
+    new_package_b = get_package("B", "1.1")
+    repo.add_package(package_a)
+    repo.add_package(new_package_a)
+    repo.add_package(package_b)
+    repo.add_package(new_package_b)
+
+    installed = [get_package("A", "1.0")]
+    locked = [package_a, package_b]
+
+    solver = Solver(package, pool, installed, locked, io)
+    transaction = solver.solve(use_latest=[package_b.name])
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a, "skipped": True},
+            {"job": "install", "package": new_package_b},
+        ],
+    )
+
+
+def test_solver_sets_groups(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*", groups=["dev"]))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_b.add_dependency(Factory.create_dependency("C", "~1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    _ = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_respects_root_package_python_versions(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~3.4")
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_b.python_versions = "^3.3"
+    package_c = get_package("C", "1.0")
+    package_c.python_versions = "^3.4"
+    package_c11 = get_package("C", "1.1")
+    package_c11.python_versions = "^3.6"
+    package_b.add_dependency(Factory.create_dependency("C", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_c11)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_fails_if_mismatch_root_python_versions(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "^3.4")
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_b.python_versions = "^3.6"
+    package_c = get_package("C", "1.0")
+    package_c.python_versions = "~3.3"
+    package_b.add_dependency(Factory.create_dependency("C", "~1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_ignores_python_restricted_if_mismatch_root_package_python_versions(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~3.8")
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "1.0", "python": "<3.8"})
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "1.0", "markers": "python_version < '3.8'"}
+        )
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [])
+
+
+def test_solver_solves_optional_and_compatible_packages(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~3.4")
+    package.extras = {canonicalize_name("foo"): [get_dependency("B")]}
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "python": "^3.4"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "optional": True})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_b.python_versions = "^3.3"
+    package_c = get_package("C", "1.0")
+    package_c.python_versions = "^3.4"
+    package_b.add_dependency(Factory.create_dependency("C", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_does_not_return_extras_if_not_requested(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    package_b.extras = {canonicalize_name("foo"): [get_dependency("C", "^1.0")]}
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_returns_extras_if_requested(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "extras": ["foo"]})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    dep = get_dependency("C", "^1.0", optional=True)
+    dep.marker = parse_marker("extra == 'foo'")
+    package_b.extras = {canonicalize_name("foo"): [dep]}
+    package_b.add_dependency(dep)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+    assert ops[-1].package.marker.is_any()
+    assert ops[0].package.marker.is_any()
+
+
+@pytest.mark.parametrize("num_groups", [0, 1, 2])
+def test_solver_returns_extras_if_requested_in_multiple_groups(
+    solver: Solver, repo: Repository, package: ProjectPackage, num_groups: int
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    if num_groups:
+        package.add_dependency(
+            Factory.create_dependency(
+                "B",
+                {"version": "*", "extras": ["foo"]},
+                groups=[f"group{i}" for i in range(num_groups)],
+            )
+        )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    dep = get_dependency("C", "^1.0", optional=True)
+    dep.marker = parse_marker("extra == 'foo'")
+    package_b.extras = {canonicalize_name("foo"): [dep]}
+    package_b.add_dependency(dep)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    expected = [
+        {"job": "install", "package": package_a},
+        {"job": "install", "package": package_b},
+    ]
+    if num_groups:
+        expected = [{"job": "install", "package": package_c}, *expected]
+
+    ops = check_solver_result(transaction, expected)
+
+    assert ops[-1].package.marker.is_any()
+    assert ops[0].package.marker.is_any()
+
+
+@pytest.mark.parametrize(
+    ("enabled_extras", "expected_packages"),
+    [
+        ([], ["a"]),
+        (["all"], ["download-package", "install-package", "a"]),
+        (["nested"], ["download-package", "install-package", "a"]),
+        (["cyclic"], ["download-package", "install-package", "a"]),
+        (["install", "download"], ["download-package", "install-package", "a"]),
+        (["install"], ["install-package", "a"]),
+        (["download"], ["download-package", "a"]),
+        # test to ensure target extra dependencies with markers are respected
+        (["py"], ["py310-package", "a"]),
+    ],
+)
+@pytest.mark.parametrize("merge_extras", [True, False])
+@pytest.mark.parametrize("top_level_dependency", [True, False])
+def test_solver_resolves_self_referential_extras(
+    enabled_extras: list[str],
+    expected_packages: list[Literal["a", "b", "download-package", "install-package"]],
+    top_level_dependency: bool,
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    create_package: PackageFactory,
+    merge_extras: bool,
+) -> None:
+    dependency = (
+        create_package(
+            "A",
+            str(package.version),
+            extras={
+                "download": ["download-package"],
+                "download2": ["download-package"],  # same package as download
+                "install": ["install-package"],
+                "py38": ["py38-package ; python_version == '3.8'"],
+                "py310": ["py310-package ; python_version > '3.8'"],
+                "all": ["a[download,download2,install]"],
+                "py": ["a[py38,py310]"],
+                "nested": ["a[all]"],
+                "cyclic": ["a[cyclic2]", "download-package"],
+                "cyclic2": ["a[cyclic]", "install-package"],
+            },
+            merge_extras=merge_extras,
+        )
+        .to_dependency()
+        .with_features(enabled_extras)
+    )
+
+    if not top_level_dependency:
+        dependency = create_package(
+            "B", "1.0", dependencies=[dependency]
+        ).to_dependency()
+        # we do not use append() here to avoid flaky tests
+        expected_packages = [*expected_packages, "b"]
+
+    package.add_dependency(dependency)
+
+    # Solving the dependency graph
+    with solver.use_environment(MockEnv((3, 10, 0))):
+        transaction = solver.solve()
+
+    # Verifying the results
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": repo.package(name, package.version)}
+            for name in expected_packages
+        ],
+    )
+
+
+def test_solver_resolves_self_referential_extras_markers(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    create_package: PackageFactory,
+) -> None:
+    package.python_versions = ".".join([str(i) for i in sys.version_info[:3]])
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "extras": ["all"]})
+    )
+
+    create_package(
+        "A",
+        str(package.version),
+        extras={
+            "download": ["download-package"],
+            "install": ["install-package"],
+            "all": ["a[download,install] ; python_version < '3.9'"],
+        },
+    )
+
+    # Solving the dependency graph
+    with solver.use_environment(MockEnv((3, 10, 0))):
+        transaction = solver.solve()
+
+    # Verifying the results
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": repo.package(name, package.version)}
+            # FIXME: At the time of writing this test case, the markers from self-ref extras are not
+            #  correctly propagated into the dependency specs. For example, given this case,
+            #  the package "install-package" should have a final marker of
+            #  "extra == 'install' or extra == 'all' and python_version < '3.9'".
+            #  Once fixed, this should only install package "a".
+            for name in ["download-package", "install-package", "a"]
+        ],
+    )
+
+
+@pytest.mark.parametrize("enabled_extra", ["one", "two", None])
+def test_solver_returns_extras_only_requested(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    enabled_extra: str | None,
+) -> None:
+    extras = [enabled_extra] if enabled_extra is not None else []
+
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "extras": extras})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c10 = get_package("C", "1.0")
+    package_c20 = get_package("C", "2.0")
+
+    dep10 = get_dependency("C", "1.0", optional=True)
+    dep10._in_extras = [canonicalize_name("one")]
+    dep10.marker = parse_marker("extra == 'one'")
+
+    dep20 = get_dependency("C", "2.0", optional=True)
+    dep20._in_extras = [canonicalize_name("two")]
+    dep20.marker = parse_marker("extra == 'two'")
+
+    package_b.extras = {
+        canonicalize_name("one"): [dep10],
+        canonicalize_name("two"): [dep20],
+    }
+
+    package_b.add_dependency(dep10)
+    package_b.add_dependency(dep20)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c10)
+    repo.add_package(package_c20)
+
+    transaction = solver.solve()
+
+    expected = [
+        {"job": "install", "package": package_a},
+        {"job": "install", "package": package_b},
+    ]
+
+    if enabled_extra is not None:
+        expected.insert(
+            0,
+            {
+                "job": "install",
+                "package": package_c10 if enabled_extra == "one" else package_c20,
+            },
+        )
+
+    ops = check_solver_result(
+        transaction,
+        expected,
+    )
+
+    assert ops[-1].package.marker.is_any()
+    assert ops[0].package.marker.is_any()
+
+
+@pytest.mark.parametrize("enabled_extra", ["one", "two", None])
+def test_solver_returns_extras_when_multiple_extras_use_same_dependency(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    enabled_extra: bool | None,
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    dep = get_dependency("C", "*", optional=True)
+    dep._in_extras = [canonicalize_name("one"), canonicalize_name("two")]
+
+    package_b.extras = {
+        canonicalize_name("one"): [dep],
+        canonicalize_name("two"): [dep],
+    }
+
+    package_b.add_dependency(dep)
+
+    extras = [enabled_extra] if enabled_extra is not None else []
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "extras": extras})
+    )
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    expected = [
+        {"job": "install", "package": package_b},
+        {"job": "install", "package": package_a},
+    ]
+
+    if enabled_extra is not None:
+        expected.insert(0, {"job": "install", "package": package_c})
+
+    ops = check_solver_result(
+        transaction,
+        expected,
+    )
+
+    assert ops[-1].package.marker.is_any()
+    assert ops[0].package.marker.is_any()
+
+
+def test_solver_locks_all_extras_when_multiple_extras_require_same_dependency(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+) -> None:
+    """
+    - root depends on A[extra-b1] and C
+    - C depends on A[extra-b2]
+    - B is required by both extras
+    -> the locked dependency A on B must have both extra markers
+    """
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+
+    dep_b1 = get_dependency("B", "*", optional=True)
+    dep_b1.marker = parse_marker("extra == 'extra-b1'")
+
+    dep_b2 = get_dependency("B", "*", optional=True)
+    dep_b2.marker = parse_marker("extra == 'extra-b2'")
+
+    package_a.extras = {
+        canonicalize_name("extra-b1"): [dep_b1],
+        canonicalize_name("extra-b2"): [dep_b2],
+    }
+    package_a.add_dependency(dep_b1)
+    package_a.add_dependency(dep_b2)
+
+    package.add_dependency(
+        get_dependency("A", {"version": "*", "extras": ["extra-b1"]})
+    )
+    package.add_dependency(get_dependency("C", "*"))
+    package_c.add_dependency(
+        get_dependency("A", {"version": "*", "extras": ["extra-b2"]})
+    )
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    expected = [
+        {"job": "install", "package": package_b},
+        {"job": "install", "package": package_a},
+        {"job": "install", "package": package_c},
+    ]
+
+    ops = check_solver_result(transaction, expected)
+    locked_a_requires = ops[1].package.requires
+    assert len(locked_a_requires) == 2
+    assert {str(r.marker) for r in locked_a_requires} == {
+        'extra == "extra-b1"',
+        'extra == "extra-b2"',
+    }
+
+
+@pytest.mark.parametrize("enabled_extra", ["one", "two", None])
+def test_solver_returns_extras_only_requested_nested(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    enabled_extra: str | None,
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c10 = get_package("C", "1.0")
+    package_c20 = get_package("C", "2.0")
+
+    dep10 = get_dependency("C", "1.0", optional=True)
+    dep10._in_extras = [canonicalize_name("one")]
+    dep10.marker = parse_marker("extra == 'one'")
+
+    dep20 = get_dependency("C", "2.0", optional=True)
+    dep20._in_extras = [canonicalize_name("two")]
+    dep20.marker = parse_marker("extra == 'two'")
+
+    package_b.extras = {
+        canonicalize_name("one"): [dep10],
+        canonicalize_name("two"): [dep20],
+    }
+
+    package_b.add_dependency(dep10)
+    package_b.add_dependency(dep20)
+
+    extras = [enabled_extra] if enabled_extra is not None else []
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "extras": extras})
+    )
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c10)
+    repo.add_package(package_c20)
+
+    transaction = solver.solve()
+
+    expected = [
+        {"job": "install", "package": package_b},
+        {"job": "install", "package": package_a},
+    ]
+
+    if enabled_extra is not None:
+        expected.insert(
+            0,
+            {
+                "job": "install",
+                "package": package_c10 if enabled_extra == "one" else package_c20,
+            },
+        )
+
+    ops = check_solver_result(transaction, expected)
+
+    assert ops[-1].package.marker.is_any()
+    assert ops[0].package.marker.is_any()
+
+
+def test_solver_finds_extras_next_to_non_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    # Root depends on A[foo]
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "extras": ["foo"]})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_d = get_package("D", "1.0")
+
+    # A depends on B; A[foo] depends on B[bar].
+    package_a.add_dependency(Factory.create_dependency("B", "*"))
+    package_a.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "*", "extras": ["bar"], "markers": "extra == 'foo'"}
+        )
+    )
+    package_a.extras = {canonicalize_name("foo"): [get_dependency("B", "*")]}
+
+    # B depends on C; B[bar] depends on D.
+    package_b.add_dependency(Factory.create_dependency("C", "*"))
+    package_b.add_dependency(
+        Factory.create_dependency("D", {"version": "*", "markers": 'extra == "bar"'})
+    )
+    package_b.extras = {canonicalize_name("bar"): [get_dependency("D", "*")]}
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_merge_extras_into_base_package_multiple_repos_fixes_5727(
+    solver: Solver, repo: Repository, pool: RepositoryPool, package: ProjectPackage
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "source": "legacy"})
+    )
+    package.add_dependency(Factory.create_dependency("B", {"version": "*"}))
+
+    package_a = get_package("A", "1.0")
+    package_a.extras = {canonicalize_name("foo"): []}
+
+    repo.add_package(package_a)
+
+    package_b = Package("B", "1.0", source_type="legacy")
+    package_b.add_dependency(package_a.with_features(["foo"]).to_dependency())
+
+    package_a = Package("A", "1.0", source_type="legacy", source_reference="legacy")
+    package_a.extras = {canonicalize_name("foo"): []}
+
+    repo = Repository("legacy")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    pool.add_repository(repo)
+
+    transaction = solver.solve()
+
+    ops = transaction.calculate_operations(synchronize=True)
+
+    assert len(ops[0].package.requires) == 0, "a should not require itself"
+
+
+def test_solver_returns_extras_if_excluded_by_markers_without_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "extras": ["foo"]})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+
+    # mandatory dependency with marker
+    dep = get_dependency("B", "^1.0")
+    dep.marker = parse_marker("sys_platform != 'linux'")
+    package_a.add_dependency(dep)
+
+    # optional dependency with same constraint and no marker except for extra
+    dep = get_dependency("B", "^1.0", optional=True)
+    dep.marker = parse_marker("extra == 'foo'")
+    package_a.extras = {canonicalize_name("foo"): [dep]}
+    package_a.add_dependency(dep)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+    assert (
+        str(ops[1].package.requires[0].marker)
+        == 'sys_platform != "linux" or extra == "foo"'
+    )
+
+
+def test_solver_returns_prereleases_if_requested(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(
+        Factory.create_dependency("C", {"version": "*", "allow-prereleases": True})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_c_dev = get_package("C", "1.1-beta.1")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_c_dev)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_c_dev},
+        ],
+    )
+
+
+def test_solver_does_not_return_prereleases_if_not_requested(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(Factory.create_dependency("C", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_c_dev = get_package("C", "1.1-beta.1")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_c_dev)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_c},
+        ],
+    )
+
+
+def test_solver_sub_dependencies_with_requirements(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_d = get_package("D", "1.0")
+
+    package_c.add_dependency(
+        Factory.create_dependency("D", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_a.add_dependency(Factory.create_dependency("C", "*"))
+    package_b.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+    op = ops[1]
+    assert op.package.marker.is_any()
+
+
+def test_solver_sub_dependencies_with_requirements_complex(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "<5.0"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<5.0"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "python": "<4.0"})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_d = get_package("D", "1.0")
+    package_e = get_package("E", "1.0")
+    package_f = get_package("F", "1.0")
+
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("D", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_b.add_dependency(
+        Factory.create_dependency("E", {"version": "^1.0", "platform": "win32"})
+    )
+    package_b.add_dependency(
+        Factory.create_dependency("F", {"version": "^1.0", "python": "<5.0"})
+    )
+    package_c.add_dependency(
+        Factory.create_dependency("F", {"version": "^1.0", "python": "<4.0"})
+    )
+    package_d.add_dependency(Factory.create_dependency("F", "*"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+    repo.add_package(package_e)
+    repo.add_package(package_f)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_e},
+            {"job": "install", "package": package_f},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_c},
+        ],
+    )
+
+
+def test_solver_sub_dependencies_with_not_supported_python_version(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "^3.5")
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_b.python_versions = "<2.0"
+
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<2.0"})
+    )
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "install", "package": package_a}])
+
+
+def test_solver_sub_dependencies_with_not_supported_python_version_transitive(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "^3.4")
+
+    package.add_dependency(
+        Factory.create_dependency("httpx", {"version": "^0.17.1", "python": "^3.6"})
+    )
+
+    httpx = get_package("httpx", "0.17.1")
+    httpx.python_versions = ">=3.6"
+
+    httpcore = get_package("httpcore", "0.12.3")
+    httpcore.python_versions = ">=3.6"
+
+    sniffio_1_1_0 = get_package("sniffio", "1.1.0")
+    sniffio_1_1_0.python_versions = ">=3.5"
+
+    sniffio = get_package("sniffio", "1.2.0")
+    sniffio.python_versions = ">=3.5"
+
+    httpx.add_dependency(
+        Factory.create_dependency("httpcore", {"version": ">=0.12.1,<0.13"})
+    )
+    httpx.add_dependency(Factory.create_dependency("sniffio", {"version": "*"}))
+    httpcore.add_dependency(Factory.create_dependency("sniffio", {"version": "==1.*"}))
+
+    repo.add_package(httpx)
+    repo.add_package(httpcore)
+    repo.add_package(sniffio)
+    repo.add_package(sniffio_1_1_0)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": sniffio, "skipped": False},
+            {"job": "install", "package": httpcore, "skipped": False},
+            {"job": "install", "package": httpx, "skipped": False},
+        ],
+    )
+
+
+def test_solver_with_dependency_in_both_main_and_dev_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "^3.5")
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "*", "extras": ["foo"]}, groups=["dev"]
+        )
+    )
+
+    package_a = get_package("A", "1.0")
+    package_a.extras = {canonicalize_name("foo"): [get_dependency("C")]}
+    package_a.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    )
+    package_a.add_dependency(Factory.create_dependency("B", {"version": "^1.0"}))
+
+    package_b = get_package("B", "1.0")
+
+    package_c = get_package("C", "1.0")
+    package_c.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    package_d = get_package("D", "1.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    transaction = solver.solve()
+
+    _ = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_with_dependency_in_both_main_and_dev_dependencies_with_one_more_dependent(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("E", "*"))
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "*", "extras": ["foo"]}, groups=["dev"]
+        )
+    )
+
+    package_a = get_package("A", "1.0")
+    package_a.extras = {canonicalize_name("foo"): [get_dependency("C")]}
+    package_a.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "optional": True})
+    )
+    package_a.add_dependency(Factory.create_dependency("B", {"version": "^1.0"}))
+
+    package_b = get_package("B", "1.0")
+
+    package_c = get_package("C", "1.0")
+    package_c.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    package_d = get_package("D", "1.0")
+
+    package_e = get_package("E", "1.0")
+    package_e.add_dependency(Factory.create_dependency("A", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+    repo.add_package(package_e)
+
+    transaction = solver.solve()
+
+    _ = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_e},
+        ],
+    )
+
+
+def test_solver_with_dependency_and_prerelease_sub_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", ">=1.0.0.dev2"))
+
+    repo.add_package(package_a)
+    repo.add_package(get_package("B", "0.9.0"))
+    repo.add_package(get_package("B", "1.0.0.dev1"))
+    repo.add_package(get_package("B", "1.0.0.dev2"))
+    repo.add_package(get_package("B", "1.0.0.dev3"))
+    package_b = get_package("B", "1.0.0.dev4")
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_with_dependency_and_prerelease_sub_dependencies_increasing_constraints(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    mocker: MockerFixture,
+) -> None:
+    """Regression test to ensure the solver eventually uses pre-release
+    dependencies if the package is progressively constrained enough.
+
+    This is different from test_solver_with_dependency_and_prerelease_sub_dependencies
+    above because it also has a wildcard dependency on B at the root level.
+    This causes the solver to first narrow B's candidate versions down to
+    {0.9.0} at an early level, then eventually down to the empty set once A's
+    dependencies are processed at a later level.
+
+    Once the candidate version set is narrowed down to the empty set, the
+    solver should re-evaluate available candidate versions from the source, but
+    include pre-release versions this time as there are no other options.
+    """
+    # Note: The order matters here; B must be added before A or the solver
+    # evaluates A first and we don't encounter the issue. This is a bit
+    # fragile, but the mock call assertions ensure this ordering is maintained.
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", ">0.9.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(get_package("B", "0.9.0"))
+    package_b = get_package("B", "1.0.0.dev4")
+    repo.add_package(package_b)
+
+    search_for_spy = mocker.spy(solver._provider, "search_for")
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+    # The assertions below aren't really the point of this test, but are just
+    # being used to ensure the dependency resolution ordering remains the same.
+    search_calls = [
+        call.args[0]
+        for call in search_for_spy.mock_calls
+        if call.args[0].name in ("a", "b")
+    ]
+    assert search_calls == [
+        Dependency("a", "*"),
+        Dependency("b", "*"),
+        Dependency("b", ">0.9.0"),
+    ]
+
+
+def test_solver_circular_dependency(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("A", "^1.0"))
+    package_b.add_dependency(Factory.create_dependency("C", "^1.0"))
+
+    package_c = get_package("C", "1.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    transaction = solver.solve()
+
+    _ = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_circular_dependency_chain(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("C", "^1.0"))
+
+    package_c = get_package("C", "1.0")
+    package_c.add_dependency(Factory.create_dependency("D", "^1.0"))
+
+    package_d = get_package("D", "1.0")
+    package_d.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    transaction = solver.solve()
+
+    _ = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_dense_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    # The root package depends on packages A0...An-1,
+    # And package Ai depends  on packages A0...Ai-1
+    # This graph is a transitive tournament
+    packages = []
+    n = 22
+    for i in range(n):
+        package_ai = get_package("a" + str(i), "1.0")
+        repo.add_package(package_ai)
+        packages.append(package_ai)
+        package.add_dependency(Factory.create_dependency("a" + str(i), "^1.0"))
+        for j in range(i):
+            package_ai.add_dependency(Factory.create_dependency("a" + str(j), "^1.0"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction, [{"job": "install", "package": packages[i]} for i in range(n)]
+    )
+
+
+def test_solver_duplicate_dependencies_same_constraint(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "2.7"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": ">=3.4"})
+    )
+
+    package_b = get_package("B", "1.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<3.4"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": ">=3.4"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints_same_requirements(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", {"version": "^1.0"}))
+    package_a.add_dependency(Factory.create_dependency("B", {"version": "^2.0"}))
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+
+    with pytest.raises(IncompatibleConstraintsError) as e:
+        solver.solve()
+
+    expected = """\
+Incompatible constraints in requirements of a (1.0):
+B (>=1.0,<2.0)
+B (>=2.0,<3.0)"""
+
+    assert str(e.value) == expected
+
+
+def test_solver_duplicate_dependencies_different_constraints_merge_by_marker(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<3.4"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": ">=3.4"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "!=1.1", "python": "<3.4"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b11 = get_package("B", "1.1")
+    package_b20 = get_package("B", "2.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b11)
+    repo.add_package(package_b20)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+@pytest.mark.parametrize("git_first", [False, True])
+def test_solver_duplicate_dependencies_different_sources_direct_origin_preserved(
+    solver: Solver, repo: Repository, package: ProjectPackage, git_first: bool
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+    repo.add_package(get_package("cleo", "1.0.0"))
+    repo.add_package(get_package("demo", "0.1.0"))
+
+    dependency_pypi = Factory.create_dependency("demo", ">=0.1.0")
+    dependency_git = Factory.create_dependency(
+        "demo", {"git": "https://github.com/demo/demo.git"}, groups=["dev"]
+    )
+    if git_first:
+        package.add_dependency(dependency_git)
+        package.add_dependency(dependency_pypi)
+    else:
+        package.add_dependency(dependency_pypi)
+        package.add_dependency(dependency_git)
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.source_type == demo.source_type
+    assert op.package.source_reference == DEFAULT_SOURCE_REF
+    assert op.package.source_resolved_reference is not None
+    assert demo.source_resolved_reference is not None
+    assert op.package.source_resolved_reference.startswith(
+        demo.source_resolved_reference
+    )
+
+    complete_package = solver.provider.complete_package(
+        DependencyPackage(package.to_dependency(), package)
+    )
+
+    assert len(complete_package.package.all_requires) == 1
+    dep = complete_package.package.all_requires[0]
+
+    assert isinstance(dep, VCSDependency)
+    assert dep.constraint == demo.version
+    assert (dep.name, dep.source_type, dep.source_url, dep.source_reference) == (
+        dependency_git.name,
+        dependency_git.source_type,
+        dependency_git.source_url,
+        DEFAULT_SOURCE_REF,
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints_merge_no_markers(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "1.0"))
+
+    package_a10 = get_package("A", "1.0")
+    package_a10.add_dependency(Factory.create_dependency("C", {"version": "^1.0"}))
+
+    package_a20 = get_package("A", "2.0")
+    package_a20.add_dependency(
+        Factory.create_dependency("C", {"version": "^2.0"})  # incompatible with B
+    )
+    package_a20.add_dependency(
+        Factory.create_dependency("C", {"version": "!=2.1", "python": "3.10"})
+    )
+
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("C", {"version": "<2.0"}))
+
+    package_c10 = get_package("C", "1.0")
+    package_c20 = get_package("C", "2.0")
+    package_c21 = get_package("C", "2.1")
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a20)
+    repo.add_package(package_b)
+    repo.add_package(package_c10)
+    repo.add_package(package_c20)
+    repo.add_package(package_c21)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c10},
+            {"job": "install", "package": package_a10},  # only a10, not a20
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints_conflict(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", ">=1.1"))
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "<1.1", "python": "3.10"})
+    )
+
+    repo.add_package(get_package("A", "1.0"))
+    repo.add_package(get_package("A", "1.1"))
+    repo.add_package(get_package("A", "1.2"))
+
+    expectation = (
+        "Incompatible constraints in requirements of root (1.0):\n"
+        "A (>=1.1)\n"
+        'A (<1.1) ; python_version == "3.10"'
+    )
+    with pytest.raises(IncompatibleConstraintsError, match=re.escape(expectation)):
+        solver.solve()
+
+
+def test_solver_duplicate_dependencies_different_constraints_discard_no_markers1(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Initial dependencies:
+        A (>=1.0)
+        A (<1.2) ; python >= 3.10
+        A (<1.1) ; python < 3.10
+
+    Merged dependencies:
+        A (>=1.0) ; <empty>
+        A (>=1.0,<1.2) ; python >= 3.10
+        A (>=1.0,<1.1) ; python < 3.10
+
+    The dependency with an empty marker has to be ignored.
+    """
+    package.add_dependency(Factory.create_dependency("A", ">=1.0"))
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "<1.2", "python": ">=3.10"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "<1.1", "python": "<3.10"})
+    )
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a10 = get_package("A", "1.0")
+    package_a11 = get_package("A", "1.1")
+    package_a12 = get_package("A", "1.2")
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("A", "*"))
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a11)
+    repo.add_package(package_a12)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            # only a10 and a11, not a12
+            {"job": "install", "package": package_a10},
+            {"job": "install", "package": package_a11},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints_discard_no_markers2(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Initial dependencies:
+        A (>=1.0)
+        A (<1.2) ; python == 3.10
+
+    Merged dependencies:
+        A (>=1.0) ; python != 3.10
+        A (>=1.0,<1.2) ; python == 3.10
+
+    The first dependency has to be ignored
+    because it is not compatible with the project's python constraint.
+    """
+    set_package_python_versions(solver.provider, "~3.10")
+    package.add_dependency(Factory.create_dependency("A", ">=1.0"))
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "<1.2", "python": "3.10"})
+    )
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a10 = get_package("A", "1.0")
+    package_a11 = get_package("A", "1.1")
+    package_a12 = get_package("A", "1.2")
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("A", "*"))
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a11)
+    repo.add_package(package_a12)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a11},  # only a11, not a12
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_different_constraints_discard_no_markers3(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Initial dependencies:
+        A (>=1.0)
+        A (<1.2) ; python == 3.10
+
+    Merged dependencies:
+        A (>=1.0) ; python != 3.10
+        A (>=1.0,<1.2) ; python == 3.10
+
+    The first dependency has to be ignored
+    because it is not compatible with the current environment.
+    """
+    package.add_dependency(Factory.create_dependency("A", ">=1.0"))
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "<1.2", "python": "3.10"})
+    )
+    package.add_dependency(Factory.create_dependency("B", "*"))
+
+    package_a10 = get_package("A", "1.0")
+    package_a11 = get_package("A", "1.1")
+    package_a12 = get_package("A", "1.2")
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("A", "*"))
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a11)
+    repo.add_package(package_a12)
+    repo.add_package(package_b)
+
+    with solver.use_environment(MockEnv((3, 10, 0))):
+        transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a11},  # only a11, not a12
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_ignore_overrides_with_empty_marker_intersection(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Distinct requirements per marker:
+    * Python 2.7: A (which requires B) and B
+    * Python 3.6: same as Python 2.7 but with different versions
+    * Python 3.7: only A
+    * Python 3.8: only B
+    """
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "1.0", "python": "~2.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "2.0", "python": "~3.6"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "3.0", "python": "~3.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "1.0", "python": "~2.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "2.0", "python": "~3.6"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "3.0", "python": "~3.8"})
+    )
+
+    package_a10 = get_package("A", "1.0")
+    package_a10.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "~2.7"})
+    )
+
+    package_a20 = get_package("A", "2.0")
+    package_a20.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": "~3.6"})
+    )
+
+    package_a30 = get_package("A", "3.0")  # no dep to B
+
+    package_b10 = get_package("B", "1.0")
+    package_b11 = get_package("B", "1.1")
+    package_b20 = get_package("B", "2.0")
+    package_b21 = get_package("B", "2.1")
+    package_b30 = get_package("B", "3.0")
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a20)
+    repo.add_package(package_a30)
+    repo.add_package(package_b10)
+    repo.add_package(package_b11)
+    repo.add_package(package_b20)
+    repo.add_package(package_b21)
+    repo.add_package(package_b30)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a10},
+            {"job": "install", "package": package_a20},
+            {"job": "install", "package": package_a30},
+            {"job": "install", "package": package_b30},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_ignore_overrides_with_empty_marker_intersection2(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Empty intersection between top level dependency and transitive dependency.
+    """
+    package.add_dependency(Factory.create_dependency("A", {"version": "1.0"}))
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": ">=2.0", "python": ">=3.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "python": "<3.7"})
+    )
+
+    package_a10 = get_package("A", "1.0")
+    package_a10.add_dependency(
+        Factory.create_dependency("B", {"version": ">=2.0", "python": ">=3.7"})
+    )
+    package_a10.add_dependency(
+        Factory.create_dependency("B", {"version": "*", "python": "<3.7"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b10.python_versions = "<3.7"
+    package_b20 = get_package("B", "2.0")
+    package_b20.python_versions = ">=3.7"
+
+    repo.add_package(package_a10)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a10},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_sub_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "<3.4"})
+    )
+    package_a.add_dependency(
+        Factory.create_dependency("B", {"version": "^2.0", "python": ">=3.4"})
+    )
+
+    package_b10 = get_package("B", "1.0")
+    package_b20 = get_package("B", "2.0")
+    package_b10.add_dependency(Factory.create_dependency("C", "1.2"))
+    package_b20.add_dependency(Factory.create_dependency("C", "1.5"))
+
+    package_c12 = get_package("C", "1.2")
+    package_c15 = get_package("C", "1.5")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+    repo.add_package(package_c12)
+    repo.add_package(package_c15)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c12},
+            {"job": "install", "package": package_c15},
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_duplicate_dependencies_with_overlapping_markers_simple(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(get_dependency("b", "1.0"))
+
+    package_b = get_package("b", "1.0")
+    dep_strings = [
+        "a (>=1.0)",
+        "a (>=1.1) ; python_version >= '3.7'",
+        "a (<2.0) ; python_version < '3.8'",
+        "a (!=1.2) ; python_version == '3.7'",
+    ]
+    deps = [Dependency.create_from_pep_508(dep) for dep in dep_strings]
+    for dep in deps:
+        package_b.add_dependency(dep)
+
+    package_a09 = get_package("a", "0.9")
+    package_a10 = get_package("a", "1.0")
+    package_a11 = get_package("a", "1.1")
+    package_a12 = get_package("a", "1.2")
+    package_a20 = get_package("a", "2.0")
+
+    package_a11.python_versions = ">=3.7"
+    package_a12.python_versions = ">=3.7"
+    package_a20.python_versions = ">=3.7"
+
+    repo.add_package(package_a09)
+    repo.add_package(package_a10)
+    repo.add_package(package_a11)
+    repo.add_package(package_a12)
+    repo.add_package(package_a20)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a10},
+            {"job": "install", "package": package_a11},
+            {"job": "install", "package": package_a20},
+            {"job": "install", "package": package_b},
+        ],
+    )
+    package_b_requires = {dep.to_pep_508() for dep in ops[-1].package.requires}
+    assert package_b_requires == {
+        'a (>=1.0,<2.0) ; python_version < "3.7"',
+        'a (>=1.1,!=1.2,<2.0) ; python_version == "3.7"',
+        'a (>=1.1) ; python_version >= "3.8"',
+    }
+
+
+def test_solver_duplicate_dependencies_with_overlapping_markers_complex(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    Dependencies with overlapping markers from
+    https://pypi.org/project/opencv-python/4.6.0.66/
+    """
+    package.add_dependency(get_dependency("opencv", "4.6.0.66"))
+
+    opencv_package = get_package("opencv", "4.6.0.66")
+    dep_strings = [
+        "numpy (>=1.13.3) ; python_version < '3.7'",
+        "numpy (>=1.21.2) ; python_version >= '3.10'",
+        (
+            "numpy (>=1.21.2) ; python_version >= '3.6' "
+            "and platform_system == 'Darwin' and platform_machine == 'arm64'"
+        ),
+        (
+            "numpy (>=1.19.3) ; python_version >= '3.6' "
+            "and platform_system == 'Linux' and platform_machine == 'aarch64'"
+        ),
+        "numpy (>=1.14.5) ; python_version >= '3.7'",
+        "numpy (>=1.17.3) ; python_version >= '3.8'",
+        "numpy (>=1.19.3) ; python_version >= '3.9'",
+    ]
+    deps = [Dependency.create_from_pep_508(dep) for dep in dep_strings]
+    for dep in deps:
+        opencv_package.add_dependency(dep)
+
+    for version in {"1.13.3", "1.21.2", "1.19.3", "1.14.5", "1.17.3"}:
+        repo.add_package(get_package("numpy", version))
+    repo.add_package(opencv_package)
+
+    transaction = solver.solve()
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("numpy", "1.21.2")},
+            {"job": "install", "package": opencv_package},
+        ],
+    )
+    opencv_requires = {dep.to_pep_508() for dep in ops[-1].package.requires}
+
+    # before https://github.com/python-poetry/poetry-core/pull/851
+    expected1 = {
+        (
+            "numpy (>=1.21.2) ;"
+            ' python_version >= "3.6" and platform_system == "Darwin"'
+            ' and platform_machine == "arm64" or python_version >= "3.10"'
+        ),
+        (
+            'numpy (>=1.19.3) ; platform_system == "Linux"'
+            ' and platform_machine == "aarch64" and python_version < "3.10"'
+            ' and python_version >= "3.6" or python_version == "3.9"'
+            ' and platform_system != "Darwin" or python_version == "3.9"'
+            ' and platform_machine != "arm64"'
+        ),
+        (
+            'numpy (>=1.17.3) ; python_version == "3.8"'
+            ' and (platform_system != "Darwin" or platform_machine != "arm64")'
+            ' and (platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+        (
+            'numpy (>=1.14.5) ; python_version == "3.7"'
+            ' and (platform_system != "Darwin" or platform_machine != "arm64")'
+            ' and (platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+        (
+            'numpy (>=1.13.3) ; python_version < "3.7"'
+            ' and (python_version < "3.6" or platform_system != "Darwin"'
+            ' or platform_machine != "arm64") and (python_version < "3.6"'
+            ' or platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+    }
+    # after https://github.com/python-poetry/poetry-core/pull/851
+    expected2 = {
+        (
+            "numpy (>=1.21.2) ;"
+            ' platform_system == "Darwin" and platform_machine == "arm64"'
+            ' and python_version >= "3.6" or python_version >= "3.10"'
+        ),
+        (
+            'numpy (>=1.19.3) ; python_version >= "3.6" and python_version < "3.10"'
+            ' and platform_system == "Linux" and platform_machine == "aarch64"'
+            ' or python_version == "3.9" and platform_machine != "arm64"'
+            ' or python_version == "3.9" and platform_system != "Darwin"'
+        ),
+        (
+            'numpy (>=1.17.3) ; python_version == "3.8"'
+            ' and (platform_system != "Darwin" or platform_machine != "arm64")'
+            ' and (platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+        (
+            'numpy (>=1.14.5) ; python_version == "3.7"'
+            ' and (platform_system != "Darwin" or platform_machine != "arm64")'
+            ' and (platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+        (
+            'numpy (>=1.13.3) ; python_version < "3.7"'
+            ' and (python_version < "3.6" or platform_system != "Darwin"'
+            ' or platform_machine != "arm64") and (python_version < "3.6"'
+            ' or platform_system != "Linux" or platform_machine != "aarch64")'
+        ),
+    }
+
+    assert opencv_requires in (expected1, expected2)
+
+
+def test_duplicate_path_dependencies(
+    solver: Solver,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    set_package_python_versions(solver.provider, "^3.7")
+    project_dir = shutil.copytree(
+        fixture_dir("with_conditional_path_deps"), tmp_path / "project"
+    )
+
+    path1 = (project_dir / "demo_one").as_posix()
+    demo1 = Package("demo", "1.2.3", source_type="directory", source_url=path1)
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"path": path1, "markers": "sys_platform == 'linux'"}
+        )
+    )
+
+    path2 = (project_dir / "demo_two").as_posix()
+    demo2 = Package("demo", "1.2.3", source_type="directory", source_url=path2)
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"path": path2, "markers": "sys_platform == 'win32'"}
+        )
+    )
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": demo1},
+            {"job": "install", "package": demo2},
+        ],
+    )
+
+
+def test_duplicate_path_dependencies_same_path(
+    solver: Solver,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    set_package_python_versions(solver.provider, "^3.7")
+    project_dir = shutil.copytree(
+        fixture_dir("with_conditional_path_deps"), tmp_path / "project"
+    )
+
+    path1 = (project_dir / "demo_one").as_posix()
+    demo1 = Package("demo", "1.2.3", source_type="directory", source_url=path1)
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"path": path1, "markers": "sys_platform == 'linux'"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"path": path1, "markers": "sys_platform == 'win32'"}
+        )
+    )
+
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "install", "package": demo1}])
+
+
+def test_solver_fails_if_dependency_name_does_not_match_package(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency(
+            "my-demo", {"git": "https://github.com/demo/demo.git"}
+        )
+    )
+
+    with pytest.raises(RuntimeError):
+        solver.solve()
+
+
+def test_solver_does_not_get_stuck_in_recursion_on_circular_dependency(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package_a = get_package("A", "1.0")
+    package_a.add_dependency(Factory.create_dependency("B", "^1.0"))
+    package_b = get_package("B", "1.0")
+    package_b.add_dependency(Factory.create_dependency("C", "^1.0"))
+    package_c = get_package("C", "1.0")
+    package_c.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_can_resolve_git_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    transaction = solver.solve()
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.source_type == "git"
+    assert op.package.source_reference == DEFAULT_SOURCE_REF
+    assert op.package.source_resolved_reference is not None
+    assert op.package.source_resolved_reference.startswith("9cf87a2")
+
+
+def test_solver_can_resolve_git_dependencies_with_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"git": "https://github.com/demo/demo.git", "extras": ["foo"]}
+        )
+    )
+
+    transaction = solver.solve()
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": cleo},
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo},
+        ],
+    )
+
+
+@pytest.mark.parametrize(
+    "ref",
+    [{"branch": "a-branch"}, {"tag": "a-tag"}, {"rev": "9cf8"}],
+    ids=["branch", "tag", "rev"],
+)
+def test_solver_can_resolve_git_dependencies_with_ref(
+    solver: Solver, repo: Repository, package: ProjectPackage, ref: dict[str, str]
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=ref[next(iter(ref.keys()))],
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    assert demo.source_type is not None
+    assert demo.source_url is not None
+    git_config = {demo.source_type: demo.source_url}
+    git_config.update(ref)
+    package.add_dependency(Factory.create_dependency("demo", git_config))
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.source_type == "git"
+    assert op.package.source_reference == ref[next(iter(ref.keys()))]
+    assert op.package.source_resolved_reference is not None
+    assert op.package.source_resolved_reference.startswith("9cf87a2")
+
+
+def test_solver_does_not_trigger_conflict_for_python_constraint_if_python_requirement_is_compatible(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.4")
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "^3.6"})
+    )
+
+    package_a = get_package("A", "1.0.0")
+    package_a.python_versions = ">=3.6"
+
+    repo.add_package(package_a)
+
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "install", "package": package_a}])
+
+
+def test_solver_does_not_trigger_conflict_for_python_constraint_if_python_requirement_is_compatible_multiple(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.4")
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "^3.6"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("B", {"version": "^1.0", "python": "^3.5.3"})
+    )
+
+    package_a = get_package("A", "1.0.0")
+    package_a.python_versions = ">=3.6"
+    package_a.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    package_b = get_package("B", "1.0.0")
+    package_b.python_versions = ">=3.5.3"
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_triggers_conflict_for_dependency_python_not_fully_compatible_with_package_python(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.4")
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "^3.5"})
+    )
+
+    package_a = get_package("A", "1.0.0")
+    package_a.python_versions = ">=3.6"
+
+    repo.add_package(package_a)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_finds_compatible_package_for_dependency_python_not_fully_compatible_with_package_python(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.4")
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "python": "^3.5"})
+    )
+
+    package_a101 = get_package("A", "1.0.1")
+    package_a101.python_versions = ">=3.6"
+
+    package_a100 = get_package("A", "1.0.0")
+    package_a100.python_versions = ">=3.5"
+
+    repo.add_package(package_a100)
+    repo.add_package(package_a101)
+
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "install", "package": package_a100}])
+
+
+def test_solver_does_not_trigger_new_resolution_on_duplicate_dependencies_if_only_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    dep1 = Dependency.create_from_pep_508('B (>=1.0); extra == "foo"')
+    dep1.activate()
+    dep2 = Dependency.create_from_pep_508('B (>=2.0); extra == "bar"')
+    dep2.activate()
+
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "^1.0", "extras": ["foo", "bar"]})
+    )
+
+    package_a = get_package("A", "1.0.0")
+    package_a.extras = {
+        canonicalize_name("foo"): [dep1],
+        canonicalize_name("bar"): [dep2],
+    }
+    package_a.add_dependency(dep1)
+    package_a.add_dependency(dep2)
+
+    package_b2 = get_package("B", "2.0.0")
+    package_b1 = get_package("B", "1.0.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b1)
+    repo.add_package(package_b2)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b2},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+    assert str(ops[0].package.marker) == ""
+    assert str(ops[1].package.marker) == ""
+
+
+def test_solver_does_not_raise_conflict_for_locked_conditional_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.4")
+    dependency_a = Factory.create_dependency("A", {"version": "^1.0", "python": "^3.6"})
+    package.add_dependency(dependency_a)
+    package.add_dependency(Factory.create_dependency("B", "^1.0"))
+
+    package_a = get_package("A", "1.0.0")
+    package_a.python_versions = ">=3.6"
+    package_a.marker = parse_marker(
+        'python_version >= "3.6" and python_version < "4.0"'
+    )
+
+    package_b = get_package("B", "1.0.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+
+    dep_package_a = DependencyPackage(dependency_a, package_a)
+    solver.provider._locked = {canonicalize_name("A"): [dep_package_a]}
+    transaction = solver.solve(use_latest=[package_b.name])
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_returns_extras_if_requested_in_dependencies_and_not_in_root_package(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(Factory.create_dependency("C", "*"))
+
+    package_a = get_package("A", "1.0")
+    package_b = get_package("B", "1.0")
+    package_c = get_package("C", "1.0")
+    package_d = get_package("D", "1.0")
+
+    package_b.add_dependency(
+        Factory.create_dependency("C", {"version": "^1.0", "extras": ["foo"]})
+    )
+
+    package_c.add_dependency(
+        Factory.create_dependency("D", {"version": "^1.0", "optional": True})
+    )
+    package_c.extras = {
+        canonicalize_name("foo"): [Factory.create_dependency("D", "^1.0")]
+    }
+
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+    repo.add_package(package_d)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_d},
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b},
+        ],
+    )
+
+
+def test_solver_should_not_resolve_prerelease_version_if_not_requested(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("A", "~1.8.0"))
+    package.add_dependency(Factory.create_dependency("B", "^0.5.0"))
+
+    package_a185 = get_package("A", "1.8.5")
+    package_a19b1 = get_package("A", "1.9b1")
+    package_b = get_package("B", "0.5.0")
+    package_b.add_dependency(Factory.create_dependency("A", ">=1.9b1"))
+
+    repo.add_package(package_a185)
+    repo.add_package(package_a19b1)
+    repo.add_package(package_b)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_ignores_dependencies_with_incompatible_python_full_version_marker(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "^3.6")
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+    package.add_dependency(Factory.create_dependency("B", "^2.0"))
+
+    package_a = get_package("A", "1.0.0")
+    package_a.add_dependency(
+        Dependency.create_from_pep_508(
+            'B (<2.0); platform_python_implementation == "PyPy" and python_full_version'
+            ' < "2.7.9"'
+        )
+    )
+
+    package_b200 = get_package("B", "2.0.0")
+    package_b100 = get_package("B", "1.0.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b100)
+    repo.add_package(package_b200)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a},
+            {"job": "install", "package": package_b200},
+        ],
+    )
+
+
+def test_solver_git_dependencies_update(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    demo_installed = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference="123456",
+    )
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    solver = Solver(package, pool, [demo_installed], [], io)
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": pendulum},
+            {"job": "update", "from": demo_installed, "to": demo},
+        ],
+    )
+
+    op = ops[1]
+
+    assert op.job_type == "update"
+    assert isinstance(op, Update)
+    assert op.package.source_type == "git"
+    assert op.package.source_reference == DEFAULT_SOURCE_REF
+    assert op.package.source_resolved_reference is not None
+    assert op.package.source_resolved_reference.startswith("9cf87a2")
+    assert op.initial_package.source_resolved_reference == "123456"
+
+
+def test_solver_git_dependencies_update_skipped(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference="master",
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    solver = Solver(package, pool, [demo], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo, "skipped": True},
+        ],
+    )
+
+
+def test_solver_git_dependencies_short_hash_update_skipped(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    demo = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=MOCK_DEFAULT_GIT_REVISION,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo", {"git": "https://github.com/demo/demo.git", "rev": "9cf87a2"}
+        )
+    )
+
+    solver = Solver(package, pool, [demo], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": pendulum},
+            {
+                "job": "install",
+                "package": Package(
+                    "demo",
+                    "0.1.2",
+                    source_type="git",
+                    source_url="https://github.com/demo/demo.git",
+                    source_reference=MOCK_DEFAULT_GIT_REVISION,
+                    source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+                ),
+                "skipped": True,
+            },
+        ],
+    )
+
+
+def test_solver_can_resolve_directory_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+
+    project_dir = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo",
+        tmp_path / "project",
+    )
+    path = project_dir.as_posix()
+
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.2", source_type="directory", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.2"
+    assert op.package.source_type == "directory"
+    assert op.package.source_url == path
+
+
+def test_solver_can_resolve_directory_dependencies_nested_editable(
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    base = fixture_dir("project_with_nested_local")
+    poetry = Factory().create_poetry(cwd=base)
+    package = poetry.package
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "quix",
+                    "1.2.3",
+                    source_type="directory",
+                    source_url=(base / "quix").as_posix(),
+                ),
+                "skipped": False,
+            },
+            {
+                "job": "install",
+                "package": Package(
+                    "bar",
+                    "1.2.3",
+                    source_type="directory",
+                    source_url=(base / "bar").as_posix(),
+                ),
+                "skipped": False,
+            },
+            {
+                "job": "install",
+                "package": Package(
+                    "foo",
+                    "1.2.3",
+                    source_type="directory",
+                    source_url=(base / "foo").as_posix(),
+                ),
+                "skipped": False,
+            },
+        ],
+    )
+
+    for op in ops:
+        assert op.package.source_type == "directory"
+        assert op.package.develop is True
+
+
+def test_solver_can_resolve_directory_dependencies_with_extras(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    project_dir = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo",
+        tmp_path / "project",
+    )
+    path = project_dir.as_posix()
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"path": path, "extras": ["foo"]})
+    )
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.2", source_type="directory", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": cleo},
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo},
+        ],
+    )
+
+    op = ops[2]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.2"
+    assert op.package.source_type == "directory"
+    assert op.package.source_url == path
+
+
+def test_solver_can_resolve_sdist_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(fixture_dir("distributions") / "demo-0.1.0.tar.gz", project_dir)
+    path = Path(path).as_posix()
+
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.0", source_type="file", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.0"
+    assert op.package.source_type == "file"
+    assert op.package.source_url == path
+
+
+def test_solver_can_resolve_sdist_dependencies_with_extras(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(fixture_dir("distributions") / "demo-0.1.0.tar.gz", project_dir)
+    path = Path(path).as_posix()
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"path": path, "extras": ["foo"]})
+    )
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.0", source_type="file", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": cleo},
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo},
+        ],
+    )
+
+    op = ops[2]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.0"
+    assert op.package.source_type == "file"
+    assert op.package.source_url == path
+
+
+def test_solver_can_resolve_wheel_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl", project_dir
+    )
+    path = Path(path).as_posix()
+
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.0", source_type="file", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [{"job": "install", "package": pendulum}, {"job": "install", "package": demo}],
+    )
+
+    op = ops[1]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.0"
+    assert op.package.source_type == "file"
+    assert op.package.source_url == path
+
+
+def test_solver_can_resolve_wheel_dependencies_with_extras(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    cleo = get_package("cleo", "1.0.0")
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl", project_dir
+    )
+    path = Path(path).as_posix()
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"path": path, "extras": ["foo"]})
+    )
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.0", source_type="file", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": cleo},
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo},
+        ],
+    )
+
+    op = ops[2]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.0"
+    assert op.package.source_type == "file"
+    assert op.package.source_url == path
+
+
+def test_solver_can_solve_with_legacy_repository_using_proper_dists(
+    package: ProjectPackage, io: NullIO, legacy_repository: LegacyRepository
+) -> None:
+    repo = legacy_repository
+    pool = RepositoryPool([repo])
+
+    solver = Solver(package, pool, [], [], io)
+
+    package.add_dependency(Factory.create_dependency("isort", "4.3.4"))
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "futures",
+                    "3.2.0",
+                    source_type="legacy",
+                    source_url=repo.url,
+                    source_reference=repo.name,
+                ),
+            },
+            {
+                "job": "install",
+                "package": Package(
+                    "isort",
+                    "4.3.4",
+                    source_type="legacy",
+                    source_url=repo.url,
+                    source_reference=repo.name,
+                ),
+            },
+        ],
+    )
+
+    futures = ops[0].package
+    assert futures.python_versions == ">=2.6, <3"
+
+
+def test_solver_can_solve_with_legacy_repository_using_proper_python_compatible_dists(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+) -> None:
+    package.python_versions = "^3.7"
+
+    repo = legacy_repository
+    pool = RepositoryPool([repo])
+
+    solver = Solver(package, pool, [], [], io)
+
+    package.add_dependency(Factory.create_dependency("isort", "4.3.4"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "isort",
+                    "4.3.4",
+                    source_type="legacy",
+                    source_url=repo.url,
+                    source_reference=repo.name,
+                ),
+            }
+        ],
+    )
+
+
+def test_solver_skips_invalid_versions(
+    package: ProjectPackage, io: NullIO, pypi_repository: PyPiRepository
+) -> None:
+    package.python_versions = "^3.9"
+
+    pool = RepositoryPool([pypi_repository])
+
+    solver = Solver(package, pool, [], [], io)
+
+    package.add_dependency(Factory.create_dependency("six-unknown-version", "^1.11"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [{"job": "install", "package": get_package("six-unknown-version", "1.11.0")}],
+    )
+
+
+def test_multiple_constraints_on_root(
+    package: ProjectPackage, solver: Solver, repo: Repository
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("foo", {"version": "^1.0", "python": "^2.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("foo", {"version": "^2.0", "python": "^3.7"})
+    )
+
+    foo15 = get_package("foo", "1.5.0")
+    foo25 = get_package("foo", "2.5.0")
+
+    repo.add_package(foo15)
+    repo.add_package(foo25)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [{"job": "install", "package": foo15}, {"job": "install", "package": foo25}],
+    )
+
+
+def test_solver_chooses_most_recent_version_amongst_repositories(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(Factory.create_dependency("tomlkit", {"version": "^0.5"}))
+
+    pool = RepositoryPool([legacy_repository, pypi_repository])
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction, [{"job": "install", "package": get_package("tomlkit", "0.5.3")}]
+    )
+
+    assert ops[0].package.source_type is None
+    assert ops[0].package.source_url is None
+
+
+def test_solver_chooses_from_correct_repository_if_forced(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(
+        Factory.create_dependency("tomlkit", {"version": "^0.5", "source": "legacy"})
+    )
+
+    pool = RepositoryPool([legacy_repository, pypi_repository])
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "tomlkit",
+                    "0.5.2",
+                    source_type="legacy",
+                    source_url=legacy_repository.url,
+                    source_reference=legacy_repository.name,
+                ),
+            }
+        ],
+    )
+
+    assert ops[0].package.source_url == legacy_repository.url
+
+
+@pytest.mark.parametrize("project_dependencies", [True, False])
+def test_solver_chooses_from_correct_repository_if_forced_and_transitive_dependency(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+    project_dependencies: bool,
+) -> None:
+    package.python_versions = "^3.7"
+    if project_dependencies:
+        main_group = DependencyGroup(MAIN_GROUP)
+        package.add_dependency_group(main_group)
+        main_group.add_dependency(Factory.create_dependency("foo", "^1.0"))
+        main_group.add_dependency(Factory.create_dependency("tomlkit", "^0.5"))
+        main_group.add_poetry_dependency(
+            Factory.create_dependency("tomlkit", {"source": "legacy"})
+        )
+    else:
+        package.add_dependency(Factory.create_dependency("foo", "^1.0"))
+        package.add_dependency(
+            Factory.create_dependency(
+                "tomlkit", {"version": "^0.5", "source": "legacy"}
+            )
+        )
+
+    repo = Repository("repo")
+    foo = get_package("foo", "1.0.0")
+    foo.add_dependency(Factory.create_dependency("tomlkit", "^0.5.0"))
+    repo.add_package(foo)
+
+    pool = RepositoryPool([legacy_repository, repo, pypi_repository])
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "tomlkit",
+                    "0.5.2",
+                    source_type="legacy",
+                    source_url=legacy_repository.url,
+                    source_reference="legacy",
+                ),
+            },
+            {"job": "install", "package": foo},
+        ],
+    )
+
+    assert ops[0].package.source_url == legacy_repository.url
+
+    assert ops[1].package.source_type is None
+    assert ops[1].package.source_url is None
+
+
+def test_solver_does_not_choose_from_supplemental_repository_by_default(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(Factory.create_dependency("clikit", {"version": "^0.2.0"}))
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository, priority=Priority.SUPPLEMENTAL)
+    pool.add_repository(legacy_repository)
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "pastel",
+                    "0.1.0",
+                    source_type="legacy",
+                    source_url=legacy_repository.url,
+                    source_reference="legacy",
+                ),
+            },
+            {"job": "install", "package": get_package("pylev", "1.3.0")},
+            {
+                "job": "install",
+                "package": Package(
+                    "clikit",
+                    "0.2.4",
+                    source_type="legacy",
+                    source_url=legacy_repository.url,
+                    source_reference="legacy",
+                ),
+            },
+        ],
+    )
+
+    assert ops[0].package.source_url == legacy_repository.url
+    assert ops[1].package.source_type is None
+    assert ops[1].package.source_url is None
+    assert ops[2].package.source_url == legacy_repository.url
+
+
+def test_solver_chooses_from_supplemental_if_explicit(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(
+        Factory.create_dependency("clikit", {"version": "^0.2.0", "source": "PyPI"})
+    )
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository, priority=Priority.SUPPLEMENTAL)
+    pool.add_repository(legacy_repository)
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {
+                "job": "install",
+                "package": Package(
+                    "pastel",
+                    "0.1.0",
+                    source_type="legacy",
+                    source_url=legacy_repository.url,
+                    source_reference="legacy",
+                ),
+            },
+            {"job": "install", "package": get_package("pylev", "1.3.0")},
+            {"job": "install", "package": get_package("clikit", "0.2.4")},
+        ],
+    )
+
+    assert ops[0].package.source_url == legacy_repository.url
+    assert ops[1].package.source_type is None
+    assert ops[1].package.source_url is None
+    assert ops[2].package.source_type is None
+    assert ops[2].package.source_url is None
+
+
+def test_solver_does_not_choose_from_explicit_repository(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(Factory.create_dependency("attrs", {"version": "^17.4.0"}))
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository, priority=Priority.EXPLICIT)
+    pool.add_repository(legacy_repository)
+
+    solver = Solver(package, pool, [], [], io)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_chooses_direct_dependency_from_explicit_if_explicit(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    package.python_versions = "^3.7"
+    package.add_dependency(
+        Factory.create_dependency("pylev", {"version": "^1.2.0", "source": "PyPI"})
+    )
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository, priority=Priority.EXPLICIT)
+    pool.add_repository(legacy_repository)
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("pylev", "1.3.0")},
+        ],
+    )
+
+    assert ops[0].package.source_type is None
+    assert ops[0].package.source_url is None
+
+
+def test_solver_ignores_explicit_repo_for_transitive_dependencies(
+    package: ProjectPackage,
+    io: NullIO,
+    legacy_repository: LegacyRepository,
+    pypi_repository: PyPiRepository,
+) -> None:
+    # clikit depends on pylev, which is in pypi_repository (explicit) but not in
+    # legacy_repository
+    package.python_versions = "^3.7"
+    package.add_dependency(
+        Factory.create_dependency("clikit", {"version": "^0.2.0", "source": "PyPI"})
+    )
+
+    pool = RepositoryPool()
+    pool.add_repository(pypi_repository, priority=Priority.EXPLICIT)
+    pool.add_repository(legacy_repository)
+
+    solver = Solver(package, pool, [], [], io)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+@pytest.mark.parametrize(
+    ("lib_versions", "other_versions"),
+    [
+        # number of versions influences which dependency is resolved first
+        (["1.0", "2.0"], ["1.0", "1.1", "2.0"]),  # more other than lib
+        (["1.0", "1.1", "2.0"], ["1.0", "2.0"]),  # more lib than other
+    ],
+)
+def test_direct_dependency_with_extras_from_explicit_and_transitive_dependency(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    lib_versions: list[str],
+    other_versions: list[str],
+) -> None:
+    """
+    The root package depends on "lib[extra]" and "other", both with an explicit source.
+    "other" depends on "lib" (without an extra and of course without an explicit source
+    because explicit sources can only be defined in the root package).
+
+    If "other" is resolved before "lib[extra]", the solver must not try to fetch "lib"
+    from the default source but from the explicit source defined for "lib[extra]".
+    """
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib", {"version": ">=1.0", "extras": ["extra"], "source": "explicit"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency("other", {"version": ">=1.0", "source": "explicit"})
+    )
+
+    explicit_repo = Repository("explicit")
+    pool.add_repository(explicit_repo, priority=Priority.EXPLICIT)
+
+    package_extra = get_package("extra", "1.0")
+    repo.add_package(package_extra)  # extra only in default repo
+
+    for version in lib_versions:
+        package_lib = Package(
+            "lib", version, source_type="legacy", source_reference="explicit"
+        )
+
+        dep_extra = get_dependency("extra", ">=1.0")
+        package_lib.add_dependency(
+            Factory.create_dependency("extra", {"version": ">=1.0", "optional": True})
+        )
+        package_lib.extras = {canonicalize_name("extra"): [dep_extra]}
+
+        explicit_repo.add_package(package_lib)  # lib only in explicit repo
+
+    for version in other_versions:
+        package_other = Package(
+            "other", version, source_type="legacy", source_reference="explicit"
+        )
+        package_other.add_dependency(Factory.create_dependency("lib", ">=1.0"))
+        explicit_repo.add_package(package_other)  # other only in explicit repo
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    expected_lib = Package(
+        "lib", "2.0", source_type="legacy", source_reference="explicit"
+    )
+    expected_other = Package(
+        "other", "2.0", source_type="legacy", source_reference="explicit"
+    )
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("extra", "1.0")},
+            {"job": "install", "package": expected_lib},
+            {"job": "install", "package": expected_other},
+        ],
+    )
+
+
+@pytest.mark.parametrize(
+    ("lib_versions", "other_versions"),
+    [
+        # number of versions influences which dependency is resolved first
+        (["1.0", "2.0"], ["1.0", "1.1", "2.0"]),  # more other than lib
+        (["1.0", "1.1", "2.0"], ["1.0", "2.0"]),  # more lib than other
+    ],
+)
+def test_direct_dependency_with_extras_from_explicit_and_transitive_dependency2(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    lib_versions: list[str],
+    other_versions: list[str],
+) -> None:
+    """
+    The root package depends on "lib[extra]" and "other", both with an explicit source.
+    "other" depends on "lib[other-extra]" (with another extra and of course without an
+    explicit source because explicit sources can only be defined in the root package).
+
+    The solver must not try to fetch "lib[other-extra]" from the default source
+    but from the explicit source defined for "lib[extra]".
+    """
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib", {"version": ">=1.0", "extras": ["extra"], "source": "explicit"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency("other", {"version": ">=1.0", "source": "explicit"})
+    )
+
+    explicit_repo = Repository("explicit")
+    pool.add_repository(explicit_repo, priority=Priority.EXPLICIT)
+
+    package_extra = get_package("extra", "1.0")
+    repo.add_package(package_extra)  # extra only in default repo
+    package_other_extra = get_package("other-extra", "1.0")
+    repo.add_package(package_other_extra)  # extra only in default repo
+
+    for version in lib_versions:
+        package_lib = Package(
+            "lib", version, source_type="legacy", source_reference="explicit"
+        )
+
+        dep_extra = get_dependency("extra", ">=1.0")
+        package_lib.add_dependency(
+            Factory.create_dependency("extra", {"version": ">=1.0", "optional": True})
+        )
+
+        dep_other_extra = get_dependency("other-extra", ">=1.0")
+        package_lib.add_dependency(
+            Factory.create_dependency(
+                "other-extra", {"version": ">=1.0", "optional": True}
+            )
+        )
+        package_lib.extras = {
+            canonicalize_name("extra"): [dep_extra],
+            canonicalize_name("other-extra"): [dep_other_extra],
+        }
+
+        explicit_repo.add_package(package_lib)  # lib only in explicit repo
+
+    for version in other_versions:
+        package_other = Package(
+            "other", version, source_type="legacy", source_reference="explicit"
+        )
+        package_other.add_dependency(
+            Factory.create_dependency(
+                "lib", {"version": ">=1.0", "extras": ["other-extra"]}
+            )
+        )
+        explicit_repo.add_package(package_other)  # other only in explicit repo
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    expected_lib = Package(
+        "lib", "2.0", source_type="legacy", source_reference="explicit"
+    )
+    expected_other = Package(
+        "other", "2.0", source_type="legacy", source_reference="explicit"
+    )
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("other-extra", "1.0")},
+            {"job": "install", "package": get_package("extra", "1.0")},
+            {"job": "install", "package": expected_lib},
+            {"job": "install", "package": expected_other},
+        ],
+    )
+
+
+@pytest.mark.parametrize("locked", [False, True])
+def test_multiple_constraints_explicit_source_transitive_locked_use_latest(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    locked: bool,
+) -> None:
+    """
+    The root package depends on
+     * lib[extra] == 1.0; sys_platform != "linux" with source=explicit1
+     * lib[extra] == 2.0; sys_platform == "linux" with source=explicit2
+     * other >= 1.0
+    "other" depends on "lib" (without an extra and of course without an explicit source
+    because explicit sources can only be defined in the root package).
+
+    If only "other" is in use_latest (equivalent to "poetry update other"),
+    the transitive dependency of "other" on "lib" is resolved before
+    the direct dependency on "lib[extra]" (if packages have been locked before).
+    We still have to make sure that the locked package is looked up in the explicit
+    source although the DependencyCache is not used for locked packages,
+    so we can't rely on it to propagate the correct source.
+    """
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib",
+            {
+                "version": "1.0",
+                "extras": ["extra"],
+                "source": "explicit1",
+                "markers": "sys_platform != 'linux'",
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib",
+            {
+                "version": "2.0",
+                "extras": ["extra"],
+                "source": "explicit2",
+                "markers": "sys_platform == 'linux'",
+            },
+        )
+    )
+    package.add_dependency(Factory.create_dependency("other", {"version": ">=1.0"}))
+
+    explicit_repo1 = Repository("explicit1")
+    pool.add_repository(explicit_repo1, priority=Priority.EXPLICIT)
+    explicit_repo2 = Repository("explicit2")
+    pool.add_repository(explicit_repo2, priority=Priority.EXPLICIT)
+
+    dep_extra = get_dependency("extra", ">=1.0")
+    dep_extra_opt = Factory.create_dependency(
+        "extra", {"version": ">=1.0", "optional": True}
+    )
+    package_lib1 = Package(
+        "lib", "1.0", source_type="legacy", source_reference="explicit1"
+    )
+    package_lib1.extras = {canonicalize_name("extra"): [dep_extra]}
+    package_lib1.add_dependency(dep_extra_opt)
+    explicit_repo1.add_package(package_lib1)
+    package_lib2 = Package(
+        "lib", "2.0", source_type="legacy", source_reference="explicit2"
+    )
+    package_lib2.extras = {canonicalize_name("extra"): [dep_extra]}
+    package_lib2.add_dependency(dep_extra_opt)
+    explicit_repo2.add_package(package_lib2)
+
+    package_extra = Package("extra", "1.0")
+    repo.add_package(package_extra)
+    package_other = Package("other", "1.5")
+    package_other.add_dependency(Factory.create_dependency("lib", ">=1.0"))
+    repo.add_package(package_other)
+
+    if locked:
+        locked_packages = [package_extra, package_lib1, package_lib2, package_other]
+        use_latest = [canonicalize_name("other")]
+    else:
+        locked_packages = []
+        use_latest = None
+    solver = Solver(package, pool, [], locked_packages, io)
+
+    transaction = solver.solve(use_latest=use_latest)
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_extra},
+            {"job": "install", "package": package_lib1},
+            {"job": "install", "package": package_lib2},
+            {"job": "install", "package": package_other},
+        ],
+    )
+    assert ops[1].package.source_reference == "explicit1"
+    assert ops[2].package.source_reference == "explicit2"
+
+
+@pytest.mark.parametrize("locked", [False, True])
+def test_multiple_constraints_incomplete_explicit_source_transitive_locked(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    locked: bool,
+) -> None:
+    """
+    The root package depends on
+     * lib == 1.0+cu ; sys_platform == "linux" with source=explicit
+     * lib == 1.0 ; sys_platform == "darwin" with no explicit source
+     * other >= 1.0
+    "other" depends on "lib"
+
+    Since the source for lib 1.0+cu has the priority "explicit",
+    the default source must be chosen for lib 1.0.
+    Since the multiple constraints are incomplete - they are only defined for linux
+    and darwin, there is another hidden override that also requires lib via other.
+    In this hidden override lib 1.0 from the default source must be chosen
+    (because the other source has the priority "explicit").
+    """
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib",
+            {
+                "version": "1.0+cu",
+                "source": "explicit",
+                "markers": "sys_platform == 'linux'",
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "lib",
+            {
+                "version": "1.0",
+                "markers": "sys_platform == 'darwin'",
+            },
+        )
+    )
+    package.add_dependency(Factory.create_dependency("other", {"version": ">=1.0"}))
+
+    explicit_repo = Repository("explicit")
+    pool.add_repository(explicit_repo, priority=Priority.EXPLICIT)
+
+    package_lib_explicit = Package(
+        "lib", "1.0+cu", source_type="legacy", source_reference="explicit"
+    )
+    explicit_repo.add_package(package_lib_explicit)
+    package_lib_default = Package("lib", "1.0")
+    repo.add_package(package_lib_default)
+
+    package_other = Package("other", "1.5")
+    package_other.add_dependency(Factory.create_dependency("lib", ">=1.0"))
+    repo.add_package(package_other)
+
+    if locked:
+        # order does not matter because packages are sorted in the provicer
+        # (latest first) so that the package from the explicit source is preferred
+        locked_packages = [package_lib_default, package_lib_explicit, package_other]
+    else:
+        locked_packages = []
+    solver = Solver(package, pool, [], locked_packages, io)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_lib_default},
+            {"job": "install", "package": package_lib_explicit},
+            {"job": "install", "package": package_other},
+        ],
+    )
+
+
+def test_solver_discards_packages_with_empty_markers(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+) -> None:
+    package.python_versions = "~2.7 || ^3.4"
+    package.add_dependency(
+        Factory.create_dependency(
+            "a", {"version": "^0.1.0", "markers": "python_version >= '3.4'"}
+        )
+    )
+
+    package_a = get_package("a", "0.1.0")
+    package_a.add_dependency(
+        Factory.create_dependency(
+            "b", {"version": "^0.1.0", "markers": "python_version < '3.2'"}
+        )
+    )
+    package_a.add_dependency(Factory.create_dependency("c", "^0.2.0"))
+    package_b = get_package("b", "0.1.0")
+    package_c = get_package("c", "0.2.0")
+    repo.add_package(package_a)
+    repo.add_package(package_b)
+    repo.add_package(package_c)
+
+    solver = Solver(package, pool, [], [], io)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_does_not_raise_conflict_for_conditional_dev_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.5")
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "^1.0", "python": "~2.7"}, groups=["dev"]
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "^2.0", "python": "^3.5"}, groups=["dev"]
+        )
+    )
+
+    package_a100 = get_package("A", "1.0.0")
+    package_a200 = get_package("A", "2.0.0")
+
+    repo.add_package(package_a100)
+    repo.add_package(package_a200)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a100},
+            {"job": "install", "package": package_a200},
+        ],
+    )
+
+
+def test_solver_does_not_loop_indefinitely_on_duplicate_constraints_with_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.5")
+    package.add_dependency(
+        Factory.create_dependency(
+            "requests", {"version": "^2.22.0", "extras": ["security"]}
+        )
+    )
+
+    requests = get_package("requests", "2.22.0")
+    requests.add_dependency(Factory.create_dependency("idna", ">=2.5,<2.9"))
+    requests.add_dependency(
+        Factory.create_dependency(
+            "idna", {"version": ">=2.0.0", "markers": "extra == 'security'"}
+        )
+    )
+    requests.extras = {
+        canonicalize_name("security"): [get_dependency("idna", ">=2.0.0")]
+    }
+    idna = get_package("idna", "2.8")
+
+    repo.add_package(requests)
+    repo.add_package(idna)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [{"job": "install", "package": idna}, {"job": "install", "package": requests}],
+    )
+
+
+def test_solver_does_not_fail_with_locked_git_and_non_git_dependencies(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+    package.add_dependency(Factory.create_dependency("a", "^1.2.3"))
+
+    git_package = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=MOCK_DEFAULT_GIT_REVISION,
+    )
+
+    repo.add_package(get_package("a", "1.2.3"))
+    repo.add_package(Package("pendulum", "2.1.2"))
+
+    installed = [git_package]
+    locked = [get_package("a", "1.2.3"), git_package]
+
+    solver = Solver(package, pool, installed, locked, io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("a", "1.2.3")},
+            {"job": "install", "package": git_package, "skipped": True},
+        ],
+    )
+
+
+def test_ignore_python_constraint_no_overlap_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    pytest = get_package("demo", "1.0.0")
+    pytest.add_dependency(
+        Factory.create_dependency(
+            "configparser", {"version": "^1.2.3", "python": "<3.2"}
+        )
+    )
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"version": "^1.0.0", "python": "^3.6"})
+    )
+
+    repo.add_package(pytest)
+    repo.add_package(get_package("configparser", "1.2.3"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [{"job": "install", "package": pytest}],
+    )
+
+
+def test_solver_should_not_go_into_an_infinite_loop_on_duplicate_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.5")
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+
+    package_a = get_package("A", "1.0.0")
+    package_a.add_dependency(Factory.create_dependency("B", "*"))
+    package_a.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "^1.0", "markers": "implementation_name == 'pypy'"}
+        )
+    )
+
+    package_b20 = get_package("B", "2.0.0")
+    package_b10 = get_package("B", "1.0.0")
+
+    repo.add_package(package_a)
+    repo.add_package(package_b10)
+    repo.add_package(package_b20)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_b10},
+            {"job": "install", "package": package_b20},
+            {"job": "install", "package": package_a},
+        ],
+    )
+
+
+def test_solver_synchronize_single(
+    package: ProjectPackage, pool: RepositoryPool, io: NullIO
+) -> None:
+    package_a = get_package("a", "1.0")
+
+    solver = Solver(package, pool, [package_a], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction, [{"job": "remove", "package": package_a}], synchronize=True
+    )
+
+
+def test_solver_cannot_choose_another_version_for_directory_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    demo = get_package("demo", "0.1.0")
+    foo = get_package("foo", "1.2.3")
+    foo.add_dependency(Factory.create_dependency("demo", "<0.1.2"))
+    repo.add_package(foo)
+    repo.add_package(demo)
+    repo.add_package(pendulum)
+
+    project_dir = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo", tmp_path / "project"
+    )
+    path = project_dir.as_posix()
+
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+    package.add_dependency(Factory.create_dependency("foo", "^1.2.3"))
+
+    # This is not solvable since the demo version is pinned
+    # via the directory dependency
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_cannot_choose_another_version_for_file_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    demo = get_package("demo", "0.0.8")
+    foo = get_package("foo", "1.2.3")
+    foo.add_dependency(Factory.create_dependency("demo", "<0.1.0"))
+    repo.add_package(foo)
+    repo.add_package(demo)
+    repo.add_package(pendulum)
+
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl", project_dir
+    )
+
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+    package.add_dependency(Factory.create_dependency("foo", "^1.2.3"))
+
+    # This is not solvable since the demo version is pinned
+    # via the file dependency
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_cannot_choose_another_version_for_git_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    pendulum = get_package("pendulum", "2.0.3")
+    demo = get_package("demo", "0.0.8")
+    foo = get_package("foo", "1.2.3")
+    foo.add_dependency(Factory.create_dependency("demo", "<0.1.0"))
+    repo.add_package(foo)
+    repo.add_package(demo)
+    repo.add_package(pendulum)
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+    package.add_dependency(Factory.create_dependency("foo", "^1.2.3"))
+
+    # This is not solvable since the demo version is pinned
+    # via the file dependency
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_cannot_choose_another_version_for_url_dependencies(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    http: type[httpretty.httpretty],
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    project_dir = tmp_path / "project"
+    project_dir.mkdir()
+    path = shutil.copy(
+        fixture_dir("distributions") / "demo-0.1.0-py2.py3-none-any.whl", project_dir
+    )
+
+    http.register_uri(
+        "GET",
+        "https://files.pythonhosted.org/demo-0.1.0-py2.py3-none-any.whl",
+        body=Path(path).read_bytes(),
+        streaming=True,
+    )
+    pendulum = get_package("pendulum", "2.0.3")
+    demo = get_package("demo", "0.0.8")
+    foo = get_package("foo", "1.2.3")
+    foo.add_dependency(Factory.create_dependency("demo", "<0.1.0"))
+    repo.add_package(foo)
+    repo.add_package(demo)
+    repo.add_package(pendulum)
+
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "url": "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+            },
+        )
+    )
+    package.add_dependency(Factory.create_dependency("foo", "^1.2.3"))
+
+    # This is not solvable since the demo version is pinned
+    # via the git dependency
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+@pytest.mark.parametrize("explicit_source", [True, False])
+def test_solver_cannot_choose_url_dependency_for_explicit_source(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    explicit_source: bool,
+) -> None:
+    """A direct origin dependency cannot satisfy a version dependency with an explicit
+    source. (It can satisfy a version dependency without an explicit source.)
+    """
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "markers": "sys_platform != 'darwin'",
+                "url": "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl",
+            },
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "demo",
+            {
+                "version": "0.1.0",
+                "markers": "sys_platform == 'darwin'",
+                "source": "repo" if explicit_source else None,
+            },
+        )
+    )
+
+    package_pendulum = get_package("pendulum", "1.4.4")
+    package_demo = Package(
+        "demo",
+        "0.1.0",
+        source_type="legacy" if explicit_source else None,
+        source_reference="repo" if explicit_source else None,
+    )
+    package_demo_url = Package(
+        "demo",
+        "0.1.0",
+        source_type="url",
+        source_url="https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl",
+    )
+    # The url demo dependency depends on pendulum.
+    repo.add_package(package_pendulum)
+    repo.add_package(package_demo)
+
+    transaction = solver.solve()
+
+    if explicit_source:
+        # direct origin cannot satisfy explicit source
+        # -> package_demo MUST be included
+        expected = [
+            {"job": "install", "package": package_pendulum},
+            {"job": "install", "package": package_demo_url},
+            {"job": "install", "package": package_demo},
+        ]
+    else:
+        # direct origin can satisfy dependency without source
+        # -> package_demo NEED NOT (but could) be included
+        expected = [
+            {"job": "install", "package": package_pendulum},
+            {"job": "install", "package": package_demo_url},
+        ]
+
+    check_solver_result(transaction, expected)
+
+
+def test_solver_should_not_update_same_version_packages_if_installed_has_no_source_type(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(Factory.create_dependency("foo", "1.0.0"))
+
+    foo = Package(
+        "foo",
+        "1.0.0",
+        source_type="legacy",
+        source_url="https://foo.bar",
+        source_reference="custom",
+    )
+    repo.add_package(foo)
+
+    solver = Solver(package, pool, [get_package("foo", "1.0.0")], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction, [{"job": "install", "package": foo, "skipped": True}]
+    )
+
+
+def test_solver_should_use_the_python_constraint_from_the_environment_if_available(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    set_package_python_versions(solver.provider, "~2.7 || ^3.5")
+    package.add_dependency(Factory.create_dependency("A", "^1.0"))
+
+    a = get_package("A", "1.0.0")
+    a.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "^1.0.0", "markers": 'python_version < "3.2"'}
+        )
+    )
+    b = get_package("B", "1.0.0")
+    b.python_versions = ">=2.6, <3"
+
+    repo.add_package(a)
+    repo.add_package(b)
+
+    with solver.use_environment(MockEnv((2, 7, 18))):
+        transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [{"job": "install", "package": b}, {"job": "install", "package": a}],
+    )
+
+
+def test_solver_should_resolve_all_versions_for_multiple_duplicate_dependencies(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.python_versions = "~2.7 || ^3.5"
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "^1.0", "markers": "python_version < '3.5'"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "A", {"version": "^2.0", "markers": "python_version >= '3.5'"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "^3.0", "markers": "python_version < '3.5'"}
+        )
+    )
+    package.add_dependency(
+        Factory.create_dependency(
+            "B", {"version": "^4.0", "markers": "python_version >= '3.5'"}
+        )
+    )
+
+    package_a10 = get_package("A", "1.0.0")
+    package_a20 = get_package("A", "2.0.0")
+    package_b30 = get_package("B", "3.0.0")
+    package_b40 = get_package("B", "4.0.0")
+
+    repo.add_package(package_a10)
+    repo.add_package(package_a20)
+    repo.add_package(package_b30)
+    repo.add_package(package_b40)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_a10},
+            {"job": "install", "package": package_a20},
+            {"job": "install", "package": package_b30},
+            {"job": "install", "package": package_b40},
+        ],
+    )
+
+
+def test_solver_should_not_raise_errors_for_irrelevant_python_constraints(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.python_versions = "^3.6"
+    set_package_python_versions(solver.provider, "^3.6")
+    package.add_dependency(
+        Factory.create_dependency("dataclasses", {"version": "^0.7", "python": "<3.7"})
+    )
+
+    dataclasses = get_package("dataclasses", "0.7")
+    dataclasses.python_versions = ">=3.6, <3.7"
+
+    repo.add_package(dataclasses)
+    transaction = solver.solve()
+
+    check_solver_result(transaction, [{"job": "install", "package": dataclasses}])
+
+
+def test_solver_can_resolve_transitive_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(Factory.create_dependency("requests", "^2.24.0"))
+    package.add_dependency(Factory.create_dependency("PyOTA", "^2.1.0"))
+
+    requests = get_package("requests", "2.24.0")
+    requests.add_dependency(Factory.create_dependency("certifi", ">=2017.4.17"))
+    dep = get_dependency("PyOpenSSL", ">=0.14")
+    requests.add_dependency(
+        Factory.create_dependency("PyOpenSSL", {"version": ">=0.14", "optional": True})
+    )
+    requests.extras = {canonicalize_name("security"): [dep]}
+    pyota = get_package("PyOTA", "2.1.0")
+    pyota.add_dependency(
+        Factory.create_dependency(
+            "requests", {"version": ">=2.24.0", "extras": ["security"]}
+        )
+    )
+
+    repo.add_package(requests)
+    repo.add_package(pyota)
+    repo.add_package(get_package("certifi", "2017.4.17"))
+    repo.add_package(get_package("pyopenssl", "0.14"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": get_package("certifi", "2017.4.17")},
+            {"job": "install", "package": get_package("pyopenssl", "0.14")},
+            {"job": "install", "package": requests},
+            {"job": "install", "package": pyota},
+        ],
+    )
+
+
+def test_solver_can_resolve_for_packages_with_missing_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency(
+            "django-anymail", {"version": "^6.0", "extras": ["postmark"]}
+        )
+    )
+
+    django_anymail = get_package("django-anymail", "6.1.0")
+    django_anymail.add_dependency(Factory.create_dependency("django", ">=2.0"))
+    django_anymail.add_dependency(Factory.create_dependency("requests", ">=2.4.3"))
+    django_anymail.add_dependency(
+        Factory.create_dependency("boto3", {"version": "*", "optional": True})
+    )
+    django_anymail.extras = {
+        canonicalize_name("amazon_ses"): [Factory.create_dependency("boto3", "*")]
+    }
+    django = get_package("django", "2.2.0")
+    boto3 = get_package("boto3", "1.0.0")
+    requests = get_package("requests", "2.24.0")
+
+    repo.add_package(django_anymail)
+    repo.add_package(django)
+    repo.add_package(boto3)
+    repo.add_package(requests)
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": django},
+            {"job": "install", "package": requests},
+            {"job": "install", "package": django_anymail},
+        ],
+    )
+
+
+def test_solver_can_resolve_python_restricted_package_dependencies(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("futures", {"version": "^3.3.0", "python": "~2.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("pre-commit", {"version": "^2.6", "python": "^3.6.1"})
+    )
+
+    futures = Package("futures", "3.3.0")
+    futures.python_versions = ">=2.6, <3"
+
+    pre_commit = Package("pre-commit", "2.7.1")
+    pre_commit.python_versions = ">=3.6.1"
+
+    repo.add_package(futures)
+    repo.add_package(pre_commit)
+
+    solver = Solver(package, pool, [], [futures, pre_commit], io)
+    transaction = solver.solve(use_latest=[canonicalize_name("pre-commit")])
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": futures},
+            {"job": "install", "package": pre_commit},
+        ],
+    )
+
+
+@pytest.mark.parametrize("virtualenv_before_pre_commit", [False, True])
+def test_solver_should_not_raise_errors_for_irrelevant_transitive_python_constraints(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    mocker: MockerFixture,
+    virtualenv_before_pre_commit: bool,
+) -> None:
+    package.python_versions = "~2.7 || ^3.5"
+    set_package_python_versions(solver.provider, "~2.7 || ^3.5")
+    package.add_dependency(Factory.create_dependency("virtualenv", "^20.4.3"))
+    package.add_dependency(
+        Factory.create_dependency("pre-commit", {"version": "^2.6", "python": "^3.6.1"})
+    )
+
+    virtualenv = get_package("virtualenv", "20.4.3")
+    virtualenv.python_versions = "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,>=2.7"
+    virtualenv.add_dependency(
+        Factory.create_dependency(
+            "importlib-resources", {"version": "*", "markers": 'python_version < "3.7"'}
+        )
+    )
+
+    pre_commit = Package("pre-commit", "2.7.1")
+    pre_commit.python_versions = ">=3.6.1"
+    pre_commit.add_dependency(
+        Factory.create_dependency(
+            "importlib-resources", {"version": "*", "markers": 'python_version < "3.7"'}
+        )
+    )
+
+    importlib_resources = get_package("importlib-resources", "5.1.2")
+    importlib_resources.python_versions = ">=3.6"
+
+    importlib_resources_3_2_1 = get_package("importlib-resources", "3.2.1")
+    importlib_resources_3_2_1.python_versions = (
+        "!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*,>=2.7"
+    )
+
+    repo.add_package(virtualenv)
+    repo.add_package(pre_commit)
+    repo.add_package(importlib_resources)
+    repo.add_package(importlib_resources_3_2_1)
+
+    def patched_choose_next(unsatisfied: list[Dependency]) -> Dependency:
+        order = (
+            ("root", "virtualenv", "pre-commit", "importlib-resources")
+            if virtualenv_before_pre_commit
+            else ("root", "pre-commit", "virtualenv", "importlib-resources")
+        )
+        for preferred in order:
+            for dep in unsatisfied:
+                if dep.name == preferred:
+                    return dep
+        raise RuntimeError
+
+    mocker.patch(
+        "poetry.mixology.version_solver.VersionSolver._choose_next",
+        side_effect=patched_choose_next,
+    )
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": importlib_resources_3_2_1},
+            {"job": "install", "package": pre_commit},
+            {"job": "install", "package": virtualenv},
+        ],
+    )
+
+
+@pytest.mark.parametrize("numpy_before_pandas", [False, True])
+@pytest.mark.parametrize("conflict", [False, True])
+def test_solver_should_not_raise_errors_for_irrelevant_transitive_python_constraints2(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    mocker: MockerFixture,
+    numpy_before_pandas: bool,
+    conflict: bool,
+) -> None:
+    """This time with overrides."""
+    package.python_versions = ">=3.6.2, <3.10"
+    set_package_python_versions(solver.provider, ">=3.6.2, <3.10")
+    package.add_dependency(Factory.create_dependency("pandas", ">=1"))
+    package.add_dependency(
+        Factory.create_dependency("numpy", {"version": ">=1.20.0", "python": ">=3.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("numpy", {"version": "*", "python": "<3.7"})
+    )
+
+    pandas = get_package("pandas", "1.1.5")
+    pandas.add_dependency(Factory.create_dependency("numpy", ">=1.15"))
+
+    numpy_19 = get_package("numpy", "1.19")
+    numpy_19.python_versions = ">=3.6"
+    numpy_20 = get_package("numpy", "1.20")
+    numpy_20.python_versions = ">=3.8" if conflict else ">=3.7"
+
+    repo.add_package(pandas)
+    repo.add_package(numpy_19)
+    repo.add_package(numpy_20)
+
+    def patched_choose_next(unsatisfied: list[Dependency]) -> Dependency:
+        order = (
+            ("root", "pandas", "numpy")
+            if numpy_before_pandas
+            else ("root", "numpy", "pandas")
+        )
+        for preferred in order:
+            for dep in unsatisfied:
+                if dep.name == preferred:
+                    return dep
+        raise RuntimeError
+
+    mocker.patch(
+        "poetry.mixology.version_solver.VersionSolver._choose_next",
+        side_effect=patched_choose_next,
+    )
+
+    if conflict:
+        with pytest.raises(SolverProblemError):
+            solver.solve()
+    else:
+        transaction = solver.solve()
+
+        check_solver_result(
+            transaction,
+            [
+                {"job": "install", "package": numpy_19},
+                {"job": "install", "package": numpy_20},
+                {"job": "install", "package": pandas},
+            ],
+        )
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+def test_solver_keeps_multiple_locked_dependencies_for_same_package(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    is_locked: bool,
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "~1.1", "python": "<3.7"})
+    )
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "~1.2", "python": ">=3.7"})
+    )
+
+    a11 = Package("A", "1.1")
+    a12 = Package("A", "1.2")
+
+    a11.add_dependency(Factory.create_dependency("B", {"version": ">=0.3"}))
+    a12.add_dependency(Factory.create_dependency("B", {"version": ">=0.3"}))
+
+    b03 = Package("B", "0.3")
+    b04 = Package("B", "0.4")
+    b04.python_versions = ">=3.6.2,<4.0.0"
+
+    repo.add_package(a11)
+    repo.add_package(a12)
+    repo.add_package(b03)
+    repo.add_package(b04)
+
+    if is_locked:
+        a11_locked = a11.clone()
+        a11_locked.python_versions = "<3.7"
+        a12_locked = a12.clone()
+        a12_locked.python_versions = ">=3.7"
+        locked = [a11_locked, a12_locked, b03.clone(), b04.clone()]
+    else:
+        locked = []
+
+    solver = Solver(package, pool, [], locked, io)
+    set_package_python_versions(solver.provider, "^3.6")
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": b03},
+            {"job": "install", "package": b04},
+            {"job": "install", "package": a11},
+            {"job": "install", "package": a12},
+        ],
+    )
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+def test_solver_does_not_update_ref_of_locked_vcs_package(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    is_locked: bool,
+) -> None:
+    locked_ref = "123456"
+    latest_ref = "9cf87a285a2d3fbb0b9fa621997b3acc3631ed24"
+    demo_locked = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=locked_ref,
+    )
+    demo_locked.add_dependency(Factory.create_dependency("pendulum", "*"))
+    demo_latest = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=latest_ref,
+    )
+    locked = [demo_locked] if is_locked else []
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    # transitive dependencies of demo
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+
+    solver = Solver(package, pool, [], locked, io)
+    transaction = solver.solve()
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo_locked if is_locked else demo_latest},
+        ],
+    )
+
+    op = ops[1]
+
+    assert op.package.source_type == "git"
+    assert op.package.source_reference == DEFAULT_SOURCE_REF
+    assert (
+        op.package.source_resolved_reference == locked_ref if is_locked else latest_ref
+    )
+
+
+def test_solver_does_not_fetch_locked_vcs_package_with_ref(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    mocker: MockerFixture,
+) -> None:
+    locked_ref = "123456"
+    demo_locked = Package(
+        "demo",
+        "0.1.2",
+        source_type="git",
+        source_url="https://github.com/demo/demo.git",
+        source_reference=DEFAULT_SOURCE_REF,
+        source_resolved_reference=locked_ref,
+    )
+    demo_locked.add_dependency(Factory.create_dependency("pendulum", "*"))
+
+    package.add_dependency(
+        Factory.create_dependency("demo", {"git": "https://github.com/demo/demo.git"})
+    )
+
+    # transitive dependencies of demo
+    pendulum = get_package("pendulum", "2.0.3")
+    repo.add_package(pendulum)
+
+    solver = Solver(package, pool, [], [demo_locked], io)
+    spy = mocker.spy(solver._provider, "_search_for_vcs")
+
+    solver.solve()
+
+    spy.assert_not_called()
+
+
+def test_solver_direct_origin_dependency_with_extras_requested_by_other_package(
+    solver: Solver,
+    repo: Repository,
+    package: ProjectPackage,
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+) -> None:
+    """
+    Another package requires the same dependency with extras that is required
+    by the project as direct origin dependency without any extras.
+    """
+    pendulum = get_package("pendulum", "2.0.3")  # required by demo
+    cleo = get_package("cleo", "1.0.0")  # required by demo[foo]
+    demo_foo = get_package("demo-foo", "1.2.3")
+    demo_foo.add_dependency(
+        Factory.create_dependency("demo", {"version": ">=0.1", "extras": ["foo"]})
+    )
+    repo.add_package(demo_foo)
+    repo.add_package(pendulum)
+    repo.add_package(cleo)
+
+    project_dir = shutil.copytree(
+        fixture_dir("git") / "github.com" / "demo" / "demo",
+        tmp_path / "project",
+    )
+    path = project_dir.as_posix()
+
+    # project requires path dependency of demo while demo-foo requires demo[foo]
+    package.add_dependency(Factory.create_dependency("demo", {"path": path}))
+    package.add_dependency(Factory.create_dependency("demo-foo", "^1.2.3"))
+
+    transaction = solver.solve()
+
+    demo = Package("demo", "0.1.2", source_type="directory", source_url=path)
+
+    ops = check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": cleo},
+            {"job": "install", "package": pendulum},
+            {"job": "install", "package": demo},
+            {"job": "install", "package": demo_foo},
+        ],
+    )
+
+    op = ops[2]
+
+    assert op.package.name == "demo"
+    assert op.package.version.text == "0.1.2"
+    assert op.package.source_type == "directory"
+    assert op.package.source_url == path
+
+
+def test_solver_incompatible_dependency_with_and_without_extras(
+    solver: Solver, repo: Repository, package: ProjectPackage
+) -> None:
+    """
+    The solver first encounters a requirement for google-auth and then later an
+    incompatible requirement for google-auth[aiohttp].
+
+    Testcase derived from https://github.com/python-poetry/poetry/issues/6054.
+    """
+    # Incompatible requirements from foo and bar2.
+    foo = get_package("foo", "1.0.0")
+    foo.add_dependency(Factory.create_dependency("google-auth", {"version": "^1"}))
+
+    bar = get_package("bar", "1.0.0")
+
+    bar2 = get_package("bar", "2.0.0")
+    bar2.add_dependency(
+        Factory.create_dependency(
+            "google-auth", {"version": "^2", "extras": ["aiohttp"]}
+        )
+    )
+
+    baz = get_package("baz", "1.0.0")  # required by google-auth[aiohttp]
+
+    google_auth = get_package("google-auth", "1.2.3")
+    google_auth.extras = {canonicalize_name("aiohttp"): [get_dependency("baz", "^1.0")]}
+
+    google_auth2 = get_package("google-auth", "2.3.4")
+    google_auth2.extras = {
+        canonicalize_name("aiohttp"): [get_dependency("baz", "^1.0")]
+    }
+
+    repo.add_package(foo)
+    repo.add_package(bar)
+    repo.add_package(bar2)
+    repo.add_package(baz)
+    repo.add_package(google_auth)
+    repo.add_package(google_auth2)
+
+    package.add_dependency(Factory.create_dependency("foo", ">=1"))
+    package.add_dependency(Factory.create_dependency("bar", ">=1"))
+
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": google_auth},
+            {"job": "install", "package": bar},
+            {"job": "install", "package": foo},
+        ],
+    )
+
+
+def test_update_with_prerelease_and_no_solution(
+    package: ProjectPackage, repo: Repository, pool: RepositoryPool, io: NullIO
+) -> None:
+    # Locked and installed: cleo which depends on an old version of crashtest.
+    cleo = get_package("cleo", "1.0.0a5")
+    crashtest = get_package("crashtest", "0.3.0")
+    cleo.add_dependency(Factory.create_dependency("crashtest", {"version": "<0.4.0"}))
+    installed = [cleo, crashtest]
+    locked = [cleo, crashtest]
+
+    # Try to upgrade to a new version of crashtest, this will be disallowed by the
+    # dependency from cleo.
+    package.add_dependency(Factory.create_dependency("cleo", "^1.0.0a5"))
+    package.add_dependency(Factory.create_dependency("crashtest", "^0.4.0"))
+
+    newer_crashtest = get_package("crashtest", "0.4.0")
+    even_newer_crashtest = get_package("crashtest", "0.4.1")
+    repo.add_package(cleo)
+    repo.add_package(crashtest)
+    repo.add_package(newer_crashtest)
+    repo.add_package(even_newer_crashtest)
+
+    solver = Solver(package, pool, installed, locked, io)
+
+    with pytest.raises(SolverProblemError):
+        solver.solve()
+
+
+def test_solver_yanked_warning(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+) -> None:
+    package.add_dependency(Factory.create_dependency("foo", "==1"))
+    package.add_dependency(Factory.create_dependency("bar", "==2"))
+    package.add_dependency(Factory.create_dependency("baz", "==3"))
+    foo = get_package("foo", "1", yanked=False)
+    bar = get_package("bar", "2", yanked=True)
+    baz = get_package("baz", "3", yanked="just wrong")
+    repo.add_package(foo)
+    repo.add_package(bar)
+    repo.add_package(baz)
+
+    io = BufferedIO(decorated=False)
+    solver = Solver(package, pool, [], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": bar},
+            {"job": "install", "package": baz},
+            {"job": "install", "package": foo},
+        ],
+    )
+    error = io.fetch_error()
+    assert "foo" not in error
+    assert "The locked version 2 for bar is a yanked version." in error
+    assert (
+        "The locked version 3 for baz is a yanked version. Reason for being yanked:"
+        " just wrong" in error
+    )
+    assert error.count("is a yanked version") == 2
+    assert error.count("Reason for being yanked") == 1
+
+
+@pytest.mark.parametrize("is_locked", [False, True])
+def test_update_with_use_latest_vs_lock(
+    package: ProjectPackage,
+    repo: Repository,
+    pool: RepositoryPool,
+    io: NullIO,
+    is_locked: bool,
+) -> None:
+    """
+    A1 depends on B2, A2 and A3 depend on B1. Same for C.
+    B1 depends on A2/C2, B2 depends on A1/C1.
+
+    Because there are more versions of B than of A and C, B is resolved first
+    so that latest version of B is used.
+    There shouldn't be a difference between `poetry lock` (not is_locked)
+    and `poetry update` (is_locked + use_latest)
+    """
+    # B added between A and C (and also alphabetically between)
+    # to ensure that neither the first nor the last one is resolved first
+    package.add_dependency(Factory.create_dependency("A", "*"))
+    package.add_dependency(Factory.create_dependency("B", "*"))
+    package.add_dependency(Factory.create_dependency("C", "*"))
+
+    package_a1 = get_package("A", "1")
+    package_a1.add_dependency(Factory.create_dependency("B", "3"))
+    package_a2 = get_package("A", "2")
+    package_a2.add_dependency(Factory.create_dependency("B", "1"))
+
+    package_c1 = get_package("C", "1")
+    package_c1.add_dependency(Factory.create_dependency("B", "3"))
+    package_c2 = get_package("C", "2")
+    package_c2.add_dependency(Factory.create_dependency("B", "1"))
+
+    package_b1 = get_package("B", "1")
+    package_b1.add_dependency(Factory.create_dependency("A", "2"))
+    package_b1.add_dependency(Factory.create_dependency("C", "2"))
+    package_b2 = get_package("B", "2")
+    package_b2.add_dependency(Factory.create_dependency("A", "1"))
+    package_b2.add_dependency(Factory.create_dependency("C", "1"))
+    package_b3 = get_package("B", "3")
+    package_b3.add_dependency(Factory.create_dependency("A", "1"))
+    package_b3.add_dependency(Factory.create_dependency("C", "1"))
+
+    repo.add_package(package_a1)
+    repo.add_package(package_a2)
+    repo.add_package(package_b1)
+    repo.add_package(package_b2)
+    repo.add_package(package_b3)
+    repo.add_package(package_c1)
+    repo.add_package(package_c2)
+
+    if is_locked:
+        locked = [package_a1, package_b3, package_c1]
+        use_latest = [package.name for package in locked]
+    else:
+        locked = []
+        use_latest = []
+
+    solver = Solver(package, pool, [], locked, io)
+    transaction = solver.solve(use_latest)
+
+    check_solver_result(
+        transaction,
+        [
+            {"job": "install", "package": package_c1},
+            {"job": "install", "package": package_b3},
+            {"job": "install", "package": package_a1},
+        ],
+    )
+
+
+@pytest.mark.parametrize("with_extra", [False, True])
+def test_solver_resolves_duplicate_dependency_in_extra(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+    io: NullIO,
+    with_extra: bool,
+) -> None:
+    """
+    Without extras, a newer version of B can be chosen than with extras.
+    See https://github.com/python-poetry/poetry/issues/8380.
+    """
+    constraint: dict[str, Any] = {"version": "*"}
+    if with_extra:
+        constraint["extras"] = ["foo"]
+    package.add_dependency(Factory.create_dependency("A", constraint))
+
+    package_a = get_package("A", "1.0")
+    package_b1 = get_package("B", "1.0")
+    package_b2 = get_package("B", "2.0")
+
+    dep = get_dependency("B", ">=1.0")
+    package_a.add_dependency(dep)
+
+    dep_extra = get_dependency("B", "^1.0", optional=True)
+    dep_extra.marker = parse_marker("extra == 'foo'")
+    package_a.extras = {canonicalize_name("foo"): [dep_extra]}
+    package_a.add_dependency(dep_extra)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b1)
+    repo.add_package(package_b2)
+
+    solver = Solver(package, pool, [], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        (
+            [
+                {"job": "install", "package": package_b1 if with_extra else package_b2},
+                {"job": "install", "package": package_a},
+            ]
+        ),
+    )
+
+
+def test_solver_resolves_conflicting_dependency_in_root_extra(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+    io: NullIO,
+) -> None:
+    package_a1 = get_package("A", "1.0")
+    package_a2 = get_package("A", "2.0")
+
+    dep = get_dependency("A", {"version": "1.0", "markers": "extra != 'foo'"})
+    package.add_dependency(dep)
+
+    dep_extra = get_dependency("A", "2.0", optional=True)
+    dep_extra._in_extras = [canonicalize_name("foo")]
+    package.extras = {canonicalize_name("foo"): [dep_extra]}
+    package.add_dependency(dep_extra)
+
+    repo.add_package(package_a1)
+    repo.add_package(package_a2)
+
+    solver = Solver(package, pool, [], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        (
+            [
+                {"job": "install", "package": package_a1},
+                {"job": "install", "package": package_a2},
+            ]
+        ),
+    )
+    solved_packages = transaction.get_solved_packages()
+    assert solved_packages[package_a1].markers[MAIN_GROUP] == parse_marker(
+        "extra != 'foo'"
+    )
+    assert solved_packages[package_a2].markers[MAIN_GROUP] == parse_marker(
+        "extra == 'foo'"
+    )
+
+
+def test_solver_resolves_conflicting_dependency_in_root_extras(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+    io: NullIO,
+) -> None:
+    package_a1 = get_package("A", "1.0")
+    package_a2 = get_package("A", "2.0")
+
+    dep_extra1 = get_dependency(  # extra == 'foo' is implicit via _in_extras!
+        "A", {"version": "1.0", "markers": "extra != 'bar'"}, optional=True
+    )
+    dep_extra1._in_extras = [canonicalize_name("foo")]
+    package.add_dependency(dep_extra1)
+
+    dep_extra2 = get_dependency(  # extra == 'bar' is implicit via _in_extras!
+        "A", {"version": "2.0", "markers": "extra != 'foo'"}, optional=True
+    )
+    dep_extra2._in_extras = [canonicalize_name("bar")]
+    package.extras = {
+        canonicalize_name("foo"): [dep_extra1],
+        canonicalize_name("bar"): [dep_extra2],
+    }
+    package.add_dependency(dep_extra1)
+    package.add_dependency(dep_extra2)
+
+    repo.add_package(package_a1)
+    repo.add_package(package_a2)
+
+    solver = Solver(package, pool, [], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        (
+            [
+                {"job": "install", "package": package_a1},
+                {"job": "install", "package": package_a2},
+            ]
+        ),
+    )
+    solved_packages = transaction.get_solved_packages()
+    assert solved_packages[package_a1].markers[MAIN_GROUP] == parse_marker(
+        "extra != 'bar' and extra == 'foo'"
+    )
+    assert solved_packages[package_a2].markers[MAIN_GROUP] == parse_marker(
+        "extra != 'foo' and extra == 'bar'"
+    )
+
+
+@pytest.mark.parametrize("with_extra", [False, True])
+def test_solver_resolves_duplicate_dependency_in_root_extra_for_installation(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+    io: NullIO,
+    with_extra: bool,
+) -> None:
+    """
+    Without extras, a newer version of A can be chosen than with root extras.
+    """
+    extra = [canonicalize_name("foo")] if with_extra else []
+
+    package_a1 = get_package("A", "1.0")
+    package_a2 = get_package("A", "2.0")
+
+    dep = get_dependency("A", ">=1.0")
+    package.add_dependency(dep)
+
+    dep_extra = get_dependency("A", "^1.0", optional=True)
+    dep_extra.marker = parse_marker("extra == 'foo'")
+    package.extras = {canonicalize_name("foo"): [dep_extra]}
+    package.add_dependency(dep_extra)
+
+    repo.add_package(package_a1)
+    repo.add_package(package_a2)
+
+    solver = Solver(
+        package, pool, [], [package_a1, package_a2], io, active_root_extras=extra
+    )
+    with solver.use_environment(MockEnv()):
+        transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        (
+            [
+                {"job": "install", "package": package_a1 if with_extra else package_a2},
+            ]
+        ),
+    )
+
+
+def test_solver_resolves_duplicate_dependencies_with_restricted_extras(
+    package: ProjectPackage,
+    pool: RepositoryPool,
+    repo: Repository,
+    io: NullIO,
+) -> None:
+    package.add_dependency(
+        Factory.create_dependency("A", {"version": "*", "extras": ["foo"]})
+    )
+
+    package_a = get_package("A", "1.0")
+    package_b1 = get_package("B", "1.0")
+    package_b2 = get_package("B", "2.0")
+
+    dep1 = get_dependency("B", "^1.0", optional=True)
+    dep1.marker = parse_marker("sys_platform == 'win32' and extra == 'foo'")
+    dep2 = get_dependency("B", "^2.0", optional=True)
+    dep2.marker = parse_marker("sys_platform == 'linux' and extra == 'foo'")
+    package_a.extras = {canonicalize_name("foo"): [dep1, dep2]}
+    package_a.add_dependency(dep1)
+    package_a.add_dependency(dep2)
+
+    repo.add_package(package_a)
+    repo.add_package(package_b1)
+    repo.add_package(package_b2)
+
+    solver = Solver(package, pool, [], [], io)
+    transaction = solver.solve()
+
+    check_solver_result(
+        transaction,
+        (
+            [
+                {"job": "install", "package": package_b1},
+                {"job": "install", "package": package_b2},
+                {"job": "install", "package": package_a},
+            ]
+        ),
+    )
diff --git b/tests/puzzle/test_solver_internals.py a/tests/puzzle/test_solver_internals.py
new file mode 100644
index 0000000..a7ed32a
--- /dev/null
+++ a/tests/puzzle/test_solver_internals.py
@@ -0,0 +1,625 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from packaging.utils import canonicalize_name
+from poetry.core.constraints.version import parse_constraint
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.dependency_group import MAIN_GROUP
+from poetry.core.packages.package import Package
+from poetry.core.version.markers import AnyMarker
+from poetry.core.version.markers import parse_marker
+
+from poetry.factory import Factory
+from poetry.packages.transitive_package_info import TransitivePackageInfo
+from poetry.puzzle.solver import PackageNode
+from poetry.puzzle.solver import Solver
+from poetry.puzzle.solver import depth_first_search
+from poetry.puzzle.solver import merge_override_packages
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterable
+    from collections.abc import Sequence
+
+    from poetry.core.packages.project_package import ProjectPackage
+
+
+DEV_GROUP = canonicalize_name("dev")
+
+
+def dep(
+    name: str,
+    marker: str = "",
+    extras: Iterable[str] = (),
+    in_extras: Sequence[str] = (),
+    groups: Iterable[str] = (),
+) -> Dependency:
+    d = Dependency(name, "1", groups=groups, extras=extras)
+    d._in_extras = [canonicalize_name(e) for e in in_extras]
+    if marker:
+        d.marker = marker
+    return d
+
+
+def tm(info: TransitivePackageInfo) -> dict[str, str]:
+    return {key: str(value) for key, value in info.markers.items()}
+
+
+def test_dfs_depth(package: ProjectPackage) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    packages = [package, a, b, c]
+    package.add_dependency(dep("a"))
+    package.add_dependency(dep("b"))
+    a.add_dependency(dep("b"))
+    b.add_dependency(dep("c"))
+
+    result, __ = depth_first_search(PackageNode(package, packages))
+    depths = {
+        nodes[0].package.complete_name: [node.depth for node in nodes]
+        for nodes in result
+    }
+
+    assert depths == {"root": [-1], "a": [0], "b": [1], "c": [2]}
+
+
+def test_dfs_depth_with_cycle(package: ProjectPackage) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    packages = [package, a, b, c]
+    package.add_dependency(dep("a"))
+    package.add_dependency(dep("b"))
+    a.add_dependency(dep("b"))
+    b.add_dependency(dep("a"))
+    a.add_dependency(dep("c"))
+
+    result, __ = depth_first_search(PackageNode(package, packages))
+    depths = {
+        nodes[0].package.complete_name: [node.depth for node in nodes]
+        for nodes in result
+    }
+
+    assert depths == {"root": [-1], "a": [0], "b": [1], "c": [1]}
+
+
+def test_dfs_depth_with_extra(package: ProjectPackage) -> None:
+    a_foo = Package("a", "1", features=["foo"])
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    packages = [package, a_foo, a, b, c]
+    package.add_dependency(dep("a", extras=["foo"]))
+    a_foo.add_dependency(dep("a"))
+    a_foo.add_dependency(dep("b"))
+    a_foo.add_dependency(dep("c", 'extra == "foo"'))
+    a.add_dependency(dep("b"))
+
+    result, __ = depth_first_search(PackageNode(package, packages))
+    depths = {
+        nodes[0].package.complete_name: [node.depth for node in nodes]
+        for nodes in result
+    }
+
+    assert depths == {"root": [-1], "a[foo]": [0], "a": [0], "b": [1], "c": [1]}
+
+
+def test_propagate_markers(package: ProjectPackage, solver: Solver) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    d = Package("d", "1")
+    e = Package("e", "1")
+    package.add_dependency(dep("a", 'sys_platform == "win32"'))
+    package.add_dependency(dep("b", 'sys_platform == "linux"'))
+    a.add_dependency(dep("c", 'python_version == "3.8"'))
+    b.add_dependency(dep("d", 'python_version == "3.9"'))
+    a.add_dependency(dep("e", 'python_version == "3.10"'))
+    b.add_dependency(dep("e", 'python_version == "3.11"'))
+
+    packages = [package, a, b, c, d, e]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == 6
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {"main": 'sys_platform == "win32"'}
+    assert tm(result[b]) == {"main": 'sys_platform == "linux"'}
+    assert tm(result[c]) == {
+        "main": 'sys_platform == "win32" and python_version == "3.8"'
+    }
+    assert tm(result[d]) == {
+        "main": 'sys_platform == "linux" and python_version == "3.9"'
+    }
+    assert tm(result[e]) == {
+        "main": 'sys_platform == "win32" and python_version == "3.10"'
+        ' or sys_platform == "linux" and python_version == "3.11"'
+    }
+
+
+def test_propagate_markers_same_name(package: ProjectPackage, solver: Solver) -> None:
+    urls = {
+        "linux": "https://files.pythonhosted.org/distributions/demo-0.1.0.tar.gz",
+        "win32": (
+            "https://files.pythonhosted.org/distributions/demo-0.1.0-py2.py3-none-any.whl"
+        ),
+    }
+    sdist = Package("demo", "0.1.0", source_type="url", source_url=urls["linux"])
+    wheel = Package("demo", "0.1.0", source_type="url", source_url=urls["win32"])
+    for platform, url in urls.items():
+        package.add_dependency(
+            Factory.create_dependency(
+                "demo",
+                {"url": url, "markers": f"sys_platform == '{platform}'"},
+            )
+        )
+
+    packages = [package, sdist, wheel]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == 3
+    assert tm(result[package]) == {}
+    assert tm(result[sdist]) == {"main": 'sys_platform == "linux"'}
+    assert tm(result[wheel]) == {"main": 'sys_platform == "win32"'}
+
+
+def test_propagate_markers_with_extra(package: ProjectPackage, solver: Solver) -> None:
+    a_foo = Package("a", "1", features=["foo"])
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    d = Package("d", "1")
+    package.add_dependency(dep("a", 'sys_platform == "win32"', extras=["foo"]))
+    package.add_dependency(dep("b", 'sys_platform == "linux"'))
+    a_foo.add_dependency(dep("a"))
+    a_foo.add_dependency(dep("c", 'python_version == "3.8"'))
+    a_foo.add_dependency(dep("d", 'extra == "foo"'))
+    a.add_dependency(dep("c", 'python_version == "3.8"'))
+    b.add_dependency(dep("a", 'python_version == "3.9"'))
+
+    packages = [package, a_foo, a, b, c, d]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages) - 1
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {
+        "main": (
+            'sys_platform == "linux" and python_version == "3.9" or sys_platform == "win32"'
+        )
+    }
+    assert tm(result[b]) == {"main": 'sys_platform == "linux"'}
+    assert tm(result[c]) == {
+        "main": 'sys_platform == "win32" and python_version == "3.8"'
+    }
+    assert tm(result[d]) == {"main": 'sys_platform == "win32"'}
+
+
+def test_propagate_markers_with_root_extra(
+    package: ProjectPackage, solver: Solver
+) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    d = Package("d", "1")
+    # "extra" is not present in the marker of an extra dependency of the root package,
+    # there is only "in_extras"...
+    package.add_dependency(dep("a", in_extras=["foo"]))
+    package.add_dependency(
+        dep("b", 'sys_platform == "linux"', in_extras=["foo", "bar"])
+    )
+    a.add_dependency(dep("c", 'python_version == "3.8"'))
+    b.add_dependency(dep("d", 'python_version == "3.9"'))
+
+    packages = [package, a, b, c, d]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages)
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {"main": 'extra == "foo"'}
+    assert tm(result[b]) == {
+        "main": 'sys_platform == "linux" and (extra == "foo" or extra == "bar")',
+    }
+    assert tm(result[c]) == {"main": 'extra == "foo" and python_version == "3.8"'}
+    assert tm(result[d]) == {
+        "main": (
+            'sys_platform == "linux" and (extra == "foo" or extra == "bar")'
+            ' and python_version == "3.9"'
+        )
+    }
+
+
+def test_propagate_markers_with_duplicate_dependency_root_extra(
+    package: ProjectPackage, solver: Solver
+) -> None:
+    a = Package("a", "1")
+    package.add_dependency(dep("a"))
+    # "extra" is not present in the marker of an extra dependency of the root package,
+    # there is only "in_extras"...
+    package.add_dependency(dep("a", in_extras=["foo"]))
+
+    packages = [package, a]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages)
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {"main": ""}  # not "extra == 'foo'" !
+
+
+def test_propagate_groups_with_extra(package: ProjectPackage, solver: Solver) -> None:
+    a_foo = Package("a", "1", features=["foo"])
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    package.add_dependency(dep("a", groups=["main"]))
+    package.add_dependency(dep("a", groups=["dev"], extras=["foo"]))
+    a_foo.add_dependency(dep("a"))
+    a_foo.add_dependency(dep("b"))
+    a_foo.add_dependency(dep("c", 'extra == "foo"'))
+    a.add_dependency(dep("b"))
+
+    packages = [package, a_foo, a, b, c]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages) - 1
+    assert result[package].groups == set()
+    assert result[a].groups == {"main", "dev"}
+    assert result[b].groups == {"main", "dev"}
+    assert result[c].groups == {"dev"}
+
+
+def test_propagate_markers_for_groups1(package: ProjectPackage, solver: Solver) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    package.add_dependency(dep("a", 'sys_platform == "win32"', groups=["main"]))
+    package.add_dependency(dep("b", 'sys_platform == "linux"', groups=["dev"]))
+    a.add_dependency(dep("c", 'python_version == "3.8"'))
+    b.add_dependency(dep("c", 'python_version == "3.9"'))
+
+    packages = [package, a, b, c]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages)
+    assert result[package].groups == set()
+    assert result[a].groups == {"main"}
+    assert result[b].groups == {"dev"}
+    assert result[c].groups == {"main", "dev"}
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {"main": 'sys_platform == "win32"'}
+    assert tm(result[b]) == {"dev": 'sys_platform == "linux"'}
+    assert tm(result[c]) == {
+        "main": 'sys_platform == "win32" and python_version == "3.8"',
+        "dev": 'sys_platform == "linux" and python_version == "3.9"',
+    }
+
+
+def test_propagate_markers_for_groups2(package: ProjectPackage, solver: Solver) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    c = Package("c", "1")
+    d = Package("d", "1")
+    package.add_dependency(dep("a", 'sys_platform == "win32"', groups=["main"]))
+    package.add_dependency(dep("b", 'sys_platform == "linux"', groups=["dev"]))
+    package.add_dependency(dep("c", 'sys_platform == "darwin"', groups=["main", "dev"]))
+    a.add_dependency(dep("d", 'python_version == "3.8"'))
+    b.add_dependency(dep("d", 'python_version == "3.9"'))
+    c.add_dependency(dep("d", 'python_version == "3.10"'))
+
+    packages = [package, a, b, c, d]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == len(packages)
+    assert result[package].groups == set()
+    assert result[a].groups == {"main"}
+    assert result[b].groups == {"dev"}
+    assert result[c].groups == {"main", "dev"}
+    assert result[d].groups == {"main", "dev"}
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {"main": 'sys_platform == "win32"'}
+    assert tm(result[b]) == {"dev": 'sys_platform == "linux"'}
+    assert tm(result[c]) == {
+        "main": 'sys_platform == "darwin"',
+        "dev": 'sys_platform == "darwin"',
+    }
+    assert tm(result[d]) == {
+        "main": (
+            'sys_platform == "win32" and python_version == "3.8"'
+            ' or sys_platform == "darwin" and python_version == "3.10"'
+        ),
+        "dev": (
+            'sys_platform == "darwin" and python_version == "3.10"'
+            ' or sys_platform == "linux" and python_version == "3.9"'
+        ),
+    }
+
+
+def test_propagate_markers_with_cycle(package: ProjectPackage, solver: Solver) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+    package.add_dependency(dep("a", 'sys_platform == "win32"'))
+    package.add_dependency(dep("b", 'sys_platform == "linux"'))
+    a.add_dependency(dep("b", 'python_version == "3.8"'))
+    b.add_dependency(dep("a", 'python_version == "3.9"'))
+
+    packages = [package, a, b]
+    result = solver._aggregate_solved_packages(packages)
+
+    assert len(result) == 3
+    assert tm(result[package]) == {}
+    assert tm(result[a]) == {
+        "main": (
+            'sys_platform == "linux" and python_version == "3.9"'
+            ' or sys_platform == "win32"'
+        )
+    }
+    assert tm(result[b]) == {
+        "main": (
+            'sys_platform == "win32" and python_version == "3.8"'
+            ' or sys_platform == "linux"'
+        )
+    }
+
+
+def test_merge_override_packages_restricted(package: ProjectPackage) -> None:
+    """Markers of dependencies should be intersected with override markers."""
+    a = Package("a", "1")
+
+    packages = merge_override_packages(
+        [
+            (
+                {package: {"a": dep("b", 'python_version < "3.9"')}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {MAIN_GROUP: parse_marker("sys_platform == 'win32'")},
+                    )
+                },
+            ),
+            (
+                {package: {"a": dep("b", 'python_version >= "3.9"')}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {MAIN_GROUP: parse_marker("sys_platform == 'linux'")},
+                    )
+                },
+            ),
+        ],
+        parse_constraint("*"),
+    )
+    assert len(packages) == 1
+    assert packages[a].groups == {"main"}
+    assert tm(packages[a]) == {
+        "main": (
+            'python_version < "3.9" and sys_platform == "win32"'
+            ' or sys_platform == "linux" and python_version >= "3.9"'
+        )
+    }
+
+
+def test_merge_override_packages_extras(package: ProjectPackage) -> None:
+    """Extras from overrides should not be visible in the resulting marker."""
+    a = Package("a", "1")
+
+    packages = merge_override_packages(
+        [
+            (
+                {package: {"a": dep("b", 'python_version < "3.9" and extra == "foo"')}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {MAIN_GROUP: parse_marker("sys_platform == 'win32'")},
+                    )
+                },
+            ),
+            (
+                {
+                    package: {
+                        "a": dep("b", 'python_version >= "3.9" and extra == "foo"')
+                    }
+                },
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {MAIN_GROUP: parse_marker("sys_platform == 'linux'")},
+                    )
+                },
+            ),
+        ],
+        parse_constraint("*"),
+    )
+    assert len(packages) == 1
+    assert packages[a].groups == {"main"}
+    assert tm(packages[a]) == {
+        "main": (
+            'python_version < "3.9" and sys_platform == "win32"'
+            ' or sys_platform == "linux" and python_version >= "3.9"'
+        )
+    }
+
+
+@pytest.mark.parametrize(
+    ("python_constraint", "expected"),
+    [
+        (">=3.8", 'python_version > "3.8" or sys_platform != "linux"'),
+        (">=3.9", ""),
+    ],
+)
+def test_merge_override_packages_python_constraint(
+    package: ProjectPackage, python_constraint: str, expected: str
+) -> None:
+    """The resulting marker depends on the project's python constraint."""
+    a = Package("a", "1")
+
+    packages = merge_override_packages(
+        [
+            (
+                {
+                    package: {
+                        "a": dep(
+                            "b", "sys_platform == 'linux' and python_version > '3.8'"
+                        )
+                    }
+                },
+                {a: TransitivePackageInfo(0, {MAIN_GROUP}, {MAIN_GROUP: AnyMarker()})},
+            ),
+            (
+                {package: {"a": dep("b", "sys_platform != 'linux'")}},
+                {a: TransitivePackageInfo(0, {MAIN_GROUP}, {MAIN_GROUP: AnyMarker()})},
+            ),
+        ],
+        parse_constraint(python_constraint),
+    )
+    assert len(packages) == 1
+    assert packages[a].groups == {"main"}
+    assert tm(packages[a]) == {"main": expected}
+
+
+def test_merge_override_packages_multiple_deps(package: ProjectPackage) -> None:
+    """All override markers should be intersected."""
+    a = Package("a", "1")
+
+    packages = merge_override_packages(
+        [
+            (
+                {
+                    package: {
+                        "a": dep("b", 'python_version < "3.9"'),
+                        "c": dep("d", 'sys_platform == "linux"'),
+                    },
+                    a: {"e": dep("f", 'python_version >= "3.8"')},
+                },
+                {a: TransitivePackageInfo(0, {MAIN_GROUP}, {MAIN_GROUP: AnyMarker()})},
+            ),
+        ],
+        parse_constraint("*"),
+    )
+
+    assert len(packages) == 1
+    assert packages[a].groups == {"main"}
+    assert tm(packages[a]) == {
+        "main": 'python_version == "3.8" and sys_platform == "linux"'
+    }
+
+
+def test_merge_override_packages_groups(package: ProjectPackage) -> None:
+    a = Package("a", "1")
+    b = Package("b", "1")
+
+    packages = merge_override_packages(
+        [
+            (
+                {package: {"a": dep("b", 'python_version < "3.9"')}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {MAIN_GROUP: parse_marker("sys_platform == 'win32'")},
+                    ),
+                    b: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP, DEV_GROUP},
+                        {
+                            MAIN_GROUP: parse_marker("sys_platform == 'win32'"),
+                            DEV_GROUP: parse_marker("sys_platform == 'linux'"),
+                        },
+                    ),
+                },
+            ),
+            (
+                {package: {"a": dep("b", 'python_version >= "3.9"')}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {DEV_GROUP},
+                        {DEV_GROUP: parse_marker("sys_platform == 'linux'")},
+                    ),
+                    b: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP, DEV_GROUP},
+                        {
+                            MAIN_GROUP: parse_marker("platform_machine == 'amd64'"),
+                            DEV_GROUP: parse_marker("platform_machine == 'aarch64'"),
+                        },
+                    ),
+                },
+            ),
+        ],
+        parse_constraint("*"),
+    )
+    assert len(packages) == 2
+    assert packages[a].groups == {"main", "dev"}
+    assert tm(packages[a]) == {
+        "main": 'python_version < "3.9" and sys_platform == "win32"',
+        "dev": 'python_version >= "3.9" and sys_platform == "linux"',
+    }
+    assert packages[b].groups == {"main", "dev"}
+    assert tm(packages[b]) == {
+        "main": (
+            'python_version < "3.9" and sys_platform == "win32"'
+            ' or python_version >= "3.9" and platform_machine == "amd64"'
+        ),
+        "dev": (
+            'python_version < "3.9" and sys_platform == "linux"'
+            ' or python_version >= "3.9" and platform_machine == "aarch64"'
+        ),
+    }
+
+
+def test_merge_override_packages_shortcut(package: ProjectPackage) -> None:
+    a = Package("a", "1")
+    common_marker = (
+        'extra == "test" and sys_platform == "win32" or platform_system == "Windows"'
+        ' or sys_platform == "linux" and extra == "stretch"'
+    )
+    override_marker1 = 'python_version >= "3.12" and platform_system != "Emscripten"'
+    override_marker2 = 'python_version >= "3.12" and platform_system == "Emscripten"'
+
+    packages = merge_override_packages(
+        [
+            (
+                {package: {"a": dep("b", override_marker1)}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {
+                            MAIN_GROUP: parse_marker(
+                                f"{override_marker1} and ({common_marker})"
+                            )
+                        },
+                    )
+                },
+            ),
+            (
+                {package: {"a": dep("b", override_marker2)}},
+                {
+                    a: TransitivePackageInfo(
+                        0,
+                        {MAIN_GROUP},
+                        {
+                            MAIN_GROUP: parse_marker(
+                                f"{override_marker2} and ({common_marker})"
+                            )
+                        },
+                    )
+                },
+            ),
+        ],
+        parse_constraint("*"),
+    )
+    assert len(packages) == 1
+    assert packages[a].groups == {"main"}
+    assert tm(packages[a]) == {
+        "main": f'({common_marker}) and python_version >= "3.12"'
+    }
+
+
+# TODO: root extras
diff --git b/tests/puzzle/test_transaction.py a/tests/puzzle/test_transaction.py
new file mode 100644
index 0000000..3f940c6
--- /dev/null
+++ a/tests/puzzle/test_transaction.py
@@ -0,0 +1,515 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+
+from packaging.utils import canonicalize_name
+from poetry.core.packages.dependency import Dependency
+from poetry.core.packages.dependency_group import MAIN_GROUP
+from poetry.core.packages.package import Package
+from poetry.core.packages.project_package import ProjectPackage
+from poetry.core.version.markers import AnyMarker
+from poetry.core.version.markers import parse_marker
+
+from poetry.installation.operations.update import Update
+from poetry.packages.transitive_package_info import TransitivePackageInfo
+from poetry.puzzle.transaction import Transaction
+
+
+if TYPE_CHECKING:
+    from poetry.installation.operations.operation import Operation
+
+
+DEV_GROUP = canonicalize_name("dev")
+
+
+def get_transitive_info(depth: int) -> TransitivePackageInfo:
+    return TransitivePackageInfo(depth, set(), {})
+
+
+def check_operations(ops: list[Operation], expected: list[dict[str, Any]]) -> None:
+    for e in expected:
+        if "skipped" not in e:
+            e["skipped"] = False
+
+    result = []
+    for op in ops:
+        if op.job_type == "update":
+            assert isinstance(op, Update)
+            result.append(
+                {
+                    "job": "update",
+                    "from": op.initial_package,
+                    "to": op.target_package,
+                    "skipped": op.skipped,
+                }
+            )
+        else:
+            job = "install"
+            if op.job_type == "uninstall":
+                job = "remove"
+
+            result.append({"job": job, "package": op.package, "skipped": op.skipped})
+
+    assert result == expected
+
+
+def test_it_should_calculate_operations_in_correct_order() -> None:
+    transaction = Transaction(
+        [Package("a", "1.0.0"), Package("b", "2.0.0"), Package("c", "3.0.0")],
+        {
+            Package("a", "1.0.0"): get_transitive_info(1),
+            Package("b", "2.1.0"): get_transitive_info(2),
+            Package("d", "4.0.0"): get_transitive_info(0),
+        },
+    )
+
+    check_operations(
+        transaction.calculate_operations(),
+        [
+            {"job": "install", "package": Package("b", "2.1.0")},
+            {"job": "install", "package": Package("a", "1.0.0")},
+            {"job": "install", "package": Package("d", "4.0.0")},
+        ],
+    )
+
+
+def test_it_should_calculate_operations_for_installed_packages() -> None:
+    transaction = Transaction(
+        [Package("a", "1.0.0"), Package("b", "2.0.0"), Package("c", "3.0.0")],
+        {
+            Package("a", "1.0.0"): get_transitive_info(1),
+            Package("b", "2.1.0"): get_transitive_info(2),
+            Package("d", "4.0.0"): get_transitive_info(0),
+        },
+        installed_packages=[
+            Package("a", "1.0.0"),
+            Package("b", "2.0.0"),
+            Package("c", "3.0.0"),
+            Package("e", "5.0.0"),
+        ],
+    )
+
+    check_operations(
+        transaction.calculate_operations(),
+        [
+            {"job": "remove", "package": Package("c", "3.0.0")},
+            {
+                "job": "update",
+                "from": Package("b", "2.0.0"),
+                "to": Package("b", "2.1.0"),
+            },
+            {"job": "install", "package": Package("a", "1.0.0"), "skipped": True},
+            {"job": "install", "package": Package("d", "4.0.0")},
+        ],
+    )
+
+
+def test_it_should_remove_installed_packages_if_required() -> None:
+    transaction = Transaction(
+        [Package("a", "1.0.0"), Package("b", "2.0.0"), Package("c", "3.0.0")],
+        {
+            Package("a", "1.0.0"): get_transitive_info(1),
+            Package("b", "2.1.0"): get_transitive_info(2),
+            Package("d", "4.0.0"): get_transitive_info(0),
+        },
+        installed_packages=[
+            Package("a", "1.0.0"),
+            Package("b", "2.0.0"),
+            Package("c", "3.0.0"),
+            Package("e", "5.0.0"),
+        ],
+    )
+
+    check_operations(
+        transaction.calculate_operations(synchronize=True),
+        [
+            {"job": "remove", "package": Package("c", "3.0.0")},
+            {"job": "remove", "package": Package("e", "5.0.0")},
+            {
+                "job": "update",
+                "from": Package("b", "2.0.0"),
+                "to": Package("b", "2.1.0"),
+            },
+            {"job": "install", "package": Package("a", "1.0.0"), "skipped": True},
+            {"job": "install", "package": Package("d", "4.0.0")},
+        ],
+    )
+
+
+def test_it_should_not_remove_system_site_packages() -> None:
+    """
+    Different types of uninstalls:
+    - c: tracked but not required
+    - e: not tracked
+    - f: root extra that is not requested
+    """
+    extra_name = canonicalize_name("foo")
+    package = ProjectPackage("root", "1.0")
+    dep_f = Dependency("f", "1", optional=True)
+    dep_f._in_extras = [extra_name]
+    package.add_dependency(dep_f)
+    package.extras = {extra_name: [dep_f]}
+    opt_f = Package("f", "6.0.0")
+    opt_f.optional = True
+    transaction = Transaction(
+        [Package("a", "1.0.0"), Package("b", "2.0.0"), Package("c", "3.0.0")],
+        {
+            Package("a", "1.0.0"): get_transitive_info(1),
+            Package("b", "2.1.0"): get_transitive_info(2),
+            Package("d", "4.0.0"): get_transitive_info(0),
+            opt_f: get_transitive_info(0),
+        },
+        installed_packages=[
+            Package("a", "1.0.0"),
+            Package("b", "2.0.0"),
+            Package("c", "3.0.0"),
+            Package("e", "5.0.0"),
+            Package("f", "6.0.0"),
+        ],
+        root_package=package,
+    )
+
+    check_operations(
+        transaction.calculate_operations(
+            synchronize=True,
+            extras=set(),
+            system_site_packages={
+                canonicalize_name(name) for name in ("a", "b", "c", "e", "f")
+            },
+        ),
+        [
+            {
+                "job": "update",
+                "from": Package("b", "2.0.0"),
+                "to": Package("b", "2.1.0"),
+            },
+            {"job": "install", "package": Package("a", "1.0.0"), "skipped": True},
+            {"job": "install", "package": Package("d", "4.0.0")},
+        ],
+    )
+
+
+def test_it_should_not_remove_installed_packages_that_are_in_result() -> None:
+    transaction = Transaction(
+        [],
+        {
+            Package("a", "1.0.0"): get_transitive_info(1),
+            Package("b", "2.0.0"): get_transitive_info(2),
+            Package("c", "3.0.0"): get_transitive_info(0),
+        },
+        installed_packages=[
+            Package("a", "1.0.0"),
+            Package("b", "2.0.0"),
+            Package("c", "3.0.0"),
+        ],
+    )
+
+    check_operations(
+        transaction.calculate_operations(synchronize=True),
+        [
+            {"job": "install", "package": Package("a", "1.0.0"), "skipped": True},
+            {"job": "install", "package": Package("b", "2.0.0"), "skipped": True},
+            {"job": "install", "package": Package("c", "3.0.0"), "skipped": True},
+        ],
+    )
+
+
+def test_it_should_update_installed_packages_if_sources_are_different() -> None:
+    transaction = Transaction(
+        [Package("a", "1.0.0")],
+        {
+            Package(
+                "a",
+                "1.0.0",
+                source_url="https://github.com/demo/demo.git",
+                source_type="git",
+                source_reference="main",
+                source_resolved_reference="123456",
+            ): get_transitive_info(1)
+        },
+        installed_packages=[Package("a", "1.0.0")],
+    )
+
+    check_operations(
+        transaction.calculate_operations(synchronize=True),
+        [
+            {
+                "job": "update",
+                "from": Package("a", "1.0.0"),
+                "to": Package(
+                    "a",
+                    "1.0.0",
+                    source_url="https://github.com/demo/demo.git",
+                    source_type="git",
+                    source_reference="main",
+                    source_resolved_reference="123456",
+                ),
+            }
+        ],
+    )
+
+
+@pytest.mark.parametrize(
+    ("groups", "expected"),
+    [
+        (set(), []),
+        ({"main"}, ["a", "c"]),
+        ({"dev"}, ["b", "c"]),
+        ({"main", "dev"}, ["a", "b", "c"]),
+    ],
+)
+@pytest.mark.parametrize("installed", [False, True])
+@pytest.mark.parametrize("with_uninstalls", [False, True])
+@pytest.mark.parametrize("sync", [False, True])
+def test_calculate_operations_with_groups(
+    installed: bool,
+    with_uninstalls: bool,
+    sync: bool,
+    groups: set[str],
+    expected: list[str],
+) -> None:
+    transaction = Transaction(
+        [Package("a", "1"), Package("b", "1"), Package("c", "1"), Package("d", "1")],
+        {
+            Package("a", "1"): TransitivePackageInfo(
+                0, {MAIN_GROUP}, {MAIN_GROUP: AnyMarker()}
+            ),
+            Package("b", "1"): TransitivePackageInfo(
+                0, {DEV_GROUP}, {DEV_GROUP: AnyMarker()}
+            ),
+            Package("c", "1"): TransitivePackageInfo(
+                0,
+                {MAIN_GROUP, DEV_GROUP},
+                {MAIN_GROUP: AnyMarker(), DEV_GROUP: AnyMarker()},
+            ),
+        },
+        (
+            [Package("a", "1"), Package("b", "1"), Package("c", "1"), Package("d", "1")]
+            if installed
+            else []
+        ),
+        None,
+        {"python_version": "3.8"},
+        {canonicalize_name(g) for g in groups},
+    )
+
+    expected_ops = [
+        {"job": "install", "package": Package(name, "1")} for name in expected
+    ]
+    if installed:
+        for op in expected_ops:
+            op["skipped"] = True
+        if with_uninstalls:
+            expected_ops.insert(0, {"job": "remove", "package": Package("d", "1")})
+            if sync:
+                for name in sorted({"a", "b", "c"}.difference(expected), reverse=True):
+                    expected_ops.insert(
+                        0, {"job": "remove", "package": Package(name, "1")}
+                    )
+
+    check_operations(
+        transaction.calculate_operations(
+            with_uninstalls=with_uninstalls, synchronize=sync
+        ),
+        expected_ops,
+    )
+
+
+@pytest.mark.parametrize(
+    ("python_version", "expected"), [("3.8", ["a"]), ("3.9", ["b"])]
+)
+@pytest.mark.parametrize("installed", [False, True])
+@pytest.mark.parametrize("sync", [False, True])
+def test_calculate_operations_with_markers(
+    installed: bool, sync: bool, python_version: str, expected: list[str]
+) -> None:
+    transaction = Transaction(
+        [Package("a", "1"), Package("b", "1")],
+        {
+            Package("a", "1"): TransitivePackageInfo(
+                0, {MAIN_GROUP}, {MAIN_GROUP: parse_marker("python_version < '3.9'")}
+            ),
+            Package("b", "1"): TransitivePackageInfo(
+                0, {MAIN_GROUP}, {MAIN_GROUP: parse_marker("python_version >= '3.9'")}
+            ),
+        },
+        [Package("a", "1"), Package("b", "1")] if installed else [],
+        None,
+        {"python_version": python_version},
+        {MAIN_GROUP},
+    )
+
+    expected_ops = [
+        {"job": "install", "package": Package(name, "1")} for name in expected
+    ]
+    if installed:
+        for op in expected_ops:
+            op["skipped"] = True
+        if sync:
+            for name in sorted({"a", "b"}.difference(expected), reverse=True):
+                expected_ops.insert(0, {"job": "remove", "package": Package(name, "1")})
+
+    check_operations(
+        transaction.calculate_operations(with_uninstalls=sync, synchronize=sync),
+        expected_ops,
+    )
+
+
+@pytest.mark.parametrize(
+    ("python_version", "sys_platform", "groups", "expected"),
+    [
+        ("3.8", "win32", {"main"}, True),
+        ("3.9", "linux", {"main"}, False),
+        ("3.9", "linux", {"dev"}, True),
+        ("3.8", "win32", {"dev"}, False),
+        ("3.9", "linux", {"main", "dev"}, True),
+        ("3.8", "win32", {"main", "dev"}, True),
+        ("3.8", "linux", {"main", "dev"}, True),
+        ("3.9", "win32", {"main", "dev"}, False),
+    ],
+)
+def test_calculate_operations_with_groups_and_markers(
+    python_version: str,
+    sys_platform: str,
+    groups: set[str],
+    expected: bool,
+) -> None:
+    transaction = Transaction(
+        [Package("a", "1")],
+        {
+            Package("a", "1"): TransitivePackageInfo(
+                0,
+                {MAIN_GROUP, DEV_GROUP},
+                {
+                    MAIN_GROUP: parse_marker("python_version < '3.9'"),
+                    DEV_GROUP: parse_marker("sys_platform == 'linux'"),
+                },
+            ),
+        },
+        [],
+        None,
+        {"python_version": python_version, "sys_platform": sys_platform},
+        {canonicalize_name(g) for g in groups},
+    )
+
+    expected_ops = (
+        [{"job": "install", "package": Package("a", "1")}] if expected else []
+    )
+
+    check_operations(transaction.calculate_operations(), expected_ops)
+
+
+@pytest.mark.parametrize("extras", [False, True])
+@pytest.mark.parametrize("marker_env", [False, True])
+@pytest.mark.parametrize("installed", [False, True])
+@pytest.mark.parametrize("with_uninstalls", [False, True])
+@pytest.mark.parametrize("sync", [False, True])
+def test_calculate_operations_extras(
+    extras: bool,
+    marker_env: bool,
+    installed: bool,
+    with_uninstalls: bool,
+    sync: bool,
+) -> None:
+    extra_name = canonicalize_name("foo")
+    package = ProjectPackage("root", "1.0")
+    dep_a = Dependency("a", "1", optional=True)
+    dep_a._in_extras = [extra_name]
+    package.add_dependency(dep_a)
+    package.extras = {extra_name: [dep_a]}
+    opt_a = Package("a", "1")
+    opt_a.optional = True
+
+    transaction = Transaction(
+        [Package("a", "1")],
+        {
+            opt_a: TransitivePackageInfo(
+                0,
+                {MAIN_GROUP} if marker_env else set(),
+                {MAIN_GROUP: parse_marker("extra == 'foo'")} if marker_env else {},
+            )
+        },
+        [Package("a", "1")] if installed else [],
+        package,
+        {"python_version": "3.8"} if marker_env else None,
+        {MAIN_GROUP} if marker_env else None,
+    )
+
+    if extras:
+        ops = [{"job": "install", "package": Package("a", "1"), "skipped": installed}]
+    elif installed:
+        if with_uninstalls and sync:
+            ops = [{"job": "remove", "package": Package("a", "1")}]
+        else:
+            ops = []
+    else:
+        ops = [{"job": "install", "package": Package("a", "1"), "skipped": True}]
+
+    check_operations(
+        transaction.calculate_operations(
+            with_uninstalls=with_uninstalls,
+            synchronize=sync,
+            extras={extra_name} if extras else set(),
+        ),
+        ops,
+    )
+
+
+@pytest.mark.parametrize("extra", ["", "foo", "bar"])
+def test_calculate_operations_extras_no_redundant_uninstall(extra: str) -> None:
+    extra1 = canonicalize_name("foo")
+    extra2 = canonicalize_name("bar")
+    package = ProjectPackage("root", "1.0")
+    dep_a1 = Dependency("a", "1", optional=True)
+    dep_a1._in_extras = [canonicalize_name("foo")]
+    dep_a1.marker = parse_marker("extra != 'bar'")
+    dep_a2 = Dependency("a", "2", optional=True)
+    dep_a2._in_extras = [canonicalize_name("bar")]
+    dep_a2.marker = parse_marker("extra != 'foo'")
+    package.add_dependency(dep_a1)
+    package.add_dependency(dep_a2)
+    package.extras = {extra1: [dep_a1], extra2: [dep_a2]}
+    opt_a1 = Package("a", "1")
+    opt_a1.optional = True
+    opt_a2 = Package("a", "2")
+    opt_a2.optional = True
+
+    transaction = Transaction(
+        [Package("a", "1")],
+        {
+            opt_a1: TransitivePackageInfo(
+                0,
+                {MAIN_GROUP},
+                {MAIN_GROUP: parse_marker("extra == 'foo' and extra != 'bar'")},
+            ),
+            opt_a2: TransitivePackageInfo(
+                0,
+                {MAIN_GROUP},
+                {MAIN_GROUP: parse_marker("extra == 'bar' and extra != 'foo'")},
+            ),
+        },
+        [Package("a", "1")],
+        package,
+        {"python_version": "3.9"},
+        {MAIN_GROUP},
+    )
+
+    if not extra:
+        ops = [{"job": "remove", "package": Package("a", "1")}]
+    elif extra == "foo":
+        ops = [{"job": "install", "package": Package("a", "1"), "skipped": True}]
+    elif extra == "bar":
+        ops = [{"job": "update", "from": Package("a", "1"), "to": Package("a", "2")}]
+    else:
+        raise NotImplementedError
+
+    check_operations(
+        transaction.calculate_operations(
+            synchronize=True,
+            extras=set() if not extra else {canonicalize_name(extra)},
+        ),
+        ops,
+    )
diff --git b/tests/test_factory.py a/tests/test_factory.py
new file mode 100644
index 0000000..68cdbb3
--- /dev/null
+++ a/tests/test_factory.py
@@ -0,0 +1,477 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+
+from cleo.io.buffered_io import BufferedIO
+from deepdiff.diff import DeepDiff
+from packaging.utils import canonicalize_name
+from poetry.core.constraints.version import Version
+from poetry.core.constraints.version import parse_constraint
+from poetry.core.packages.package import Package
+from poetry.core.packages.vcs_dependency import VCSDependency
+
+from poetry.__version__ import __version__
+from poetry.exceptions import PoetryError
+from poetry.factory import Factory
+from poetry.plugins.plugin import Plugin
+from poetry.repositories.exceptions import InvalidSourceError
+from poetry.repositories.legacy_repository import LegacyRepository
+from poetry.repositories.pypi_repository import PyPiRepository
+from poetry.repositories.repository_pool import Priority
+from poetry.toml.file import TOMLFile
+from tests.helpers import mock_metadata_entry_points
+
+
+if TYPE_CHECKING:
+    from cleo.io.io import IO
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from poetry.poetry import Poetry
+    from tests.types import FixtureDirGetter
+
+
+class MyPlugin(Plugin):
+    def activate(self, poetry: Poetry, io: IO) -> None:
+        io.write_line("Setting readmes")
+        poetry.package.readmes = (Path("README.md"),)
+
+
+def test_create_poetry(fixture_dir: FixtureDirGetter) -> None:
+    poetry = Factory().create_poetry(fixture_dir("sample_project"))
+
+    package = poetry.package
+
+    assert package.name == "sample-project"
+    assert package.version.text == "1.2.3"
+    assert package.description == "Some description."
+    assert package.authors == ["Sébastien Eustace <sebastien@eustace.io>"]
+    assert package.license is not None
+    assert package.license.id == "MIT"
+
+    for readme in package.readmes:
+        assert (
+            readme.relative_to(fixture_dir("sample_project")).as_posix() == "README.rst"
+        )
+
+    assert package.homepage == "https://python-poetry.org"
+    assert package.repository_url == "https://github.com/python-poetry/poetry"
+    assert package.keywords == ["packaging", "dependency", "poetry"]
+
+    assert package.python_versions == "~2.7 || ^3.6"
+    assert str(package.python_constraint) == ">=2.7,<2.8 || >=3.6,<4.0"
+
+    dependencies = {}
+    for dep in package.requires:
+        dependencies[dep.name] = dep
+
+    cleo = dependencies[canonicalize_name("cleo")]
+    assert cleo.pretty_constraint == "^0.6"
+    assert not cleo.is_optional()
+
+    pendulum = dependencies[canonicalize_name("pendulum")]
+    assert pendulum.pretty_constraint == "branch 2.0"
+    assert pendulum.is_vcs()
+    assert isinstance(pendulum, VCSDependency)
+    assert pendulum.vcs == "git"
+    assert pendulum.branch == "2.0"
+    assert pendulum.source == "https://github.com/sdispater/pendulum.git"
+    assert pendulum.allows_prereleases()
+
+    requests = dependencies[canonicalize_name("requests")]
+    assert requests.pretty_constraint == "^2.18"
+    assert not requests.is_vcs()
+    assert not requests.allows_prereleases()
+    assert requests.is_optional()
+    assert requests.extras == frozenset(["security"])
+
+    pathlib2 = dependencies[canonicalize_name("pathlib2")]
+    assert pathlib2.pretty_constraint == "^2.2"
+    assert parse_constraint(pathlib2.python_versions) == parse_constraint("~2.7")
+    assert not pathlib2.is_optional()
+
+    demo = dependencies[canonicalize_name("demo")]
+    assert demo.is_file()
+    assert not demo.is_vcs()
+    assert demo.name == "demo"
+    assert demo.pretty_constraint == "*"
+
+    demo = dependencies[canonicalize_name("my-package")]
+    assert not demo.is_file()
+    assert demo.is_directory()
+    assert not demo.is_vcs()
+    assert demo.name == "my-package"
+    assert demo.pretty_constraint == "*"
+
+    simple_project = dependencies[canonicalize_name("simple-project")]
+    assert not simple_project.is_file()
+    assert simple_project.is_directory()
+    assert not simple_project.is_vcs()
+    assert simple_project.name == "simple-project"
+    assert simple_project.pretty_constraint == "*"
+
+    functools32 = dependencies[canonicalize_name("functools32")]
+    assert functools32.name == "functools32"
+    assert functools32.pretty_constraint == "^3.2.3"
+    assert (
+        str(functools32.marker)
+        == 'python_version ~= "2.7" and sys_platform == "win32" or python_version in'
+        ' "3.4 3.5"'
+    )
+
+    assert "db" in package.extras
+
+    classifiers = package.classifiers
+
+    assert classifiers == [
+        "Topic :: Software Development :: Build Tools",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+    ]
+
+    assert package.all_classifiers == [
+        "License :: OSI Approved :: MIT License",
+        *(
+            f"Programming Language :: Python :: {version}"
+            for version in sorted(
+                Package.AVAILABLE_PYTHONS,
+                key=lambda x: tuple(map(int, x.split("."))),
+            )
+            if package.python_constraint.allows_any(
+                parse_constraint(version + ".*")
+                if len(version) == 1
+                else Version.parse(version)
+            )
+        ),
+        "Topic :: Software Development :: Build Tools",
+        "Topic :: Software Development :: Libraries :: Python Modules",
+    ]
+
+
+@pytest.mark.parametrize(
+    ("project",),
+    [
+        ("simple_project_legacy",),
+        ("project_with_extras",),
+    ],
+)
+def test_create_pyproject_from_package(
+    project: str, fixture_dir: FixtureDirGetter
+) -> None:
+    poetry = Factory().create_poetry(fixture_dir(project))
+    package = poetry.package
+
+    pyproject: dict[str, Any] = Factory.create_legacy_pyproject_from_package(package)
+
+    result = pyproject["tool"]["poetry"]
+    expected = poetry.pyproject.poetry_config
+
+    # Extras are normalized as they are read.
+    extras = expected.pop("extras", None)
+    if extras is not None:
+        normalized_extras = {
+            canonicalize_name(extra): dependencies
+            for extra, dependencies in extras.items()
+        }
+        expected["extras"] = normalized_extras
+
+    # packages do not support this at present
+    expected.pop("scripts", None)
+
+    # remove any empty sections
+    sections = list(expected.keys())
+    for section in sections:
+        if not expected[section]:
+            expected.pop(section)
+
+    assert not DeepDiff(expected, result)
+
+
+def test_create_poetry_with_packages_and_includes(
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    poetry = Factory().create_poetry(fixture_dir("with-include"))
+
+    package = poetry.package
+
+    assert package.packages == [
+        {"include": "extra_dir/**/*.py", "format": ["sdist", "wheel"]},
+        {"include": "extra_dir/**/*.py", "format": ["sdist", "wheel"]},
+        {"include": "my_module.py", "format": ["sdist", "wheel"]},
+        {"include": "package_with_include", "format": ["sdist", "wheel"]},
+        {"include": "tests", "format": ["sdist"]},
+        {"include": "for_wheel_only", "format": ["wheel"]},
+        {"include": "src_package", "from": "src", "format": ["sdist", "wheel"]},
+    ]
+
+    assert package.include in (
+        # with https://github.com/python-poetry/poetry-core/pull/773
+        [
+            {"path": "extra_dir/vcs_excluded.txt", "format": ["sdist", "wheel"]},
+            {"path": "notes.txt", "format": ["sdist"]},
+        ],
+        # without https://github.com/python-poetry/poetry-core/pull/773
+        [
+            {"path": "extra_dir/vcs_excluded.txt", "format": ["sdist"]},
+            {"path": "notes.txt", "format": ["sdist"]},
+        ],
+    )
+
+
+def test_create_poetry_with_multi_constraints_dependency(
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    poetry = Factory().create_poetry(
+        fixture_dir("project_with_multi_constraints_dependency")
+    )
+
+    package = poetry.package
+
+    assert len(package.requires) == 2
+
+
+def test_create_poetry_non_package_mode(fixture_dir: FixtureDirGetter) -> None:
+    poetry = Factory().create_poetry(fixture_dir("non_package_mode"))
+
+    assert not poetry.is_package_mode
+
+
+def test_create_poetry_version_ok(fixture_dir: FixtureDirGetter) -> None:
+    io = BufferedIO()
+    Factory().create_poetry(fixture_dir("self_version_ok"), io=io)
+
+    assert io.fetch_output() == ""
+    assert io.fetch_error() == ""
+
+
+def test_create_poetry_version_not_ok(fixture_dir: FixtureDirGetter) -> None:
+    with pytest.raises(PoetryError) as e:
+        Factory().create_poetry(fixture_dir("self_version_not_ok"))
+    assert (
+        str(e.value)
+        == f"This project requires Poetry <1.2, but you are using Poetry {__version__}"
+    )
+
+
+@pytest.mark.parametrize(
+    "project",
+    ("with_primary_source_implicit", "with_primary_source_explicit"),
+)
+def test_poetry_with_primary_source(
+    project: str, fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    io = BufferedIO()
+    poetry = Factory().create_poetry(fixture_dir(project), io=io)
+
+    assert not poetry.pool.has_repository("PyPI")
+    assert poetry.pool.has_repository("foo")
+    assert poetry.pool.get_priority("foo") is Priority.PRIMARY
+    assert isinstance(poetry.pool.repository("foo"), LegacyRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"foo"}
+
+
+def test_poetry_with_multiple_supplemental_sources(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    poetry = Factory().create_poetry(fixture_dir("with_multiple_supplemental_sources"))
+
+    assert poetry.pool.has_repository("PyPI")
+    assert isinstance(poetry.pool.repository("PyPI"), PyPiRepository)
+    assert poetry.pool.get_priority("PyPI") is Priority.PRIMARY
+    assert poetry.pool.has_repository("foo")
+    assert isinstance(poetry.pool.repository("foo"), LegacyRepository)
+    assert poetry.pool.has_repository("bar")
+    assert isinstance(poetry.pool.repository("bar"), LegacyRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"PyPI", "foo", "bar"}
+
+
+def test_poetry_with_multiple_sources(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    poetry = Factory().create_poetry(fixture_dir("with_multiple_sources"))
+
+    assert not poetry.pool.has_repository("PyPI")
+    assert poetry.pool.has_repository("bar")
+    assert isinstance(poetry.pool.repository("bar"), LegacyRepository)
+    assert poetry.pool.has_repository("foo")
+    assert isinstance(poetry.pool.repository("foo"), LegacyRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"bar", "foo"}
+
+
+def test_poetry_with_multiple_sources_pypi(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    io = BufferedIO()
+    poetry = Factory().create_poetry(fixture_dir("with_multiple_sources_pypi"), io=io)
+
+    assert len(poetry.pool.repositories) == 4
+    assert poetry.pool.has_repository("PyPI")
+    assert isinstance(poetry.pool.repository("PyPI"), PyPiRepository)
+    assert poetry.pool.get_priority("PyPI") is Priority.PRIMARY
+    # PyPI must be between bar and baz!
+    expected = ["bar", "PyPI", "baz", "foo"]
+    assert [repo.name for repo in poetry.pool.repositories] == expected
+
+
+def test_poetry_with_no_default_source(fixture_dir: FixtureDirGetter) -> None:
+    poetry = Factory().create_poetry(fixture_dir("sample_project"))
+
+    assert poetry.pool.has_repository("PyPI")
+    assert poetry.pool.get_priority("PyPI") is Priority.PRIMARY
+    assert isinstance(poetry.pool.repository("PyPI"), PyPiRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"PyPI"}
+
+
+def test_poetry_with_supplemental_source(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    io = BufferedIO()
+    poetry = Factory().create_poetry(fixture_dir("with_supplemental_source"), io=io)
+
+    assert poetry.pool.has_repository("PyPI")
+    assert poetry.pool.get_priority("PyPI") is Priority.PRIMARY
+    assert isinstance(poetry.pool.repository("PyPI"), PyPiRepository)
+    assert poetry.pool.has_repository("supplemental")
+    assert poetry.pool.get_priority("supplemental") is Priority.SUPPLEMENTAL
+    assert isinstance(poetry.pool.repository("supplemental"), LegacyRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"PyPI", "supplemental"}
+    assert io.fetch_error() == ""
+
+
+def test_poetry_with_explicit_source(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    io = BufferedIO()
+    poetry = Factory().create_poetry(fixture_dir("with_explicit_source"), io=io)
+
+    assert len(poetry.pool.repositories) == 1
+    assert len(poetry.pool.all_repositories) == 2
+    assert poetry.pool.has_repository("PyPI")
+    assert poetry.pool.get_priority("PyPI") is Priority.PRIMARY
+    assert isinstance(poetry.pool.repository("PyPI"), PyPiRepository)
+    assert poetry.pool.has_repository("explicit")
+    assert isinstance(poetry.pool.repository("explicit"), LegacyRepository)
+    assert {repo.name for repo in poetry.pool.repositories} == {"PyPI"}
+    assert io.fetch_error() == ""
+
+
+def test_poetry_with_explicit_pypi_and_other(
+    fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    io = BufferedIO()
+    poetry = Factory().create_poetry(fixture_dir("with_explicit_pypi_and_other"), io=io)
+
+    assert len(poetry.pool.repositories) == 1
+    assert len(poetry.pool.all_repositories) == 2
+    error = io.fetch_error()
+    assert error == ""
+
+
+@pytest.mark.parametrize(
+    "project", ["with_explicit_pypi_no_other", "with_explicit_pypi_and_other_explicit"]
+)
+def test_poetry_with_pypi_explicit_only(
+    project: str, fixture_dir: FixtureDirGetter, with_simple_keyring: None
+) -> None:
+    with pytest.raises(PoetryError) as e:
+        Factory().create_poetry(fixture_dir(project))
+    assert str(e.value) == "At least one source must not be configured as 'explicit'."
+
+
+def test_validate(fixture_dir: FixtureDirGetter) -> None:
+    complete = TOMLFile(fixture_dir("complete.toml"))
+    pyproject: dict[str, Any] = complete.read()
+
+    assert Factory.validate(pyproject) == {"errors": [], "warnings": []}
+
+
+def test_validate_fails(fixture_dir: FixtureDirGetter) -> None:
+    complete = TOMLFile(fixture_dir("complete.toml"))
+    pyproject: dict[str, Any] = complete.read()
+    pyproject["tool"]["poetry"]["this key is not in the schema"] = ""
+    pyproject["tool"]["poetry"]["source"] = {}
+
+    expected = [
+        "tool.poetry.source must be array",
+        (
+            "Additional properties are not allowed "
+            "('this key is not in the schema' was unexpected)"
+        ),
+    ]
+
+    assert Factory.validate(pyproject) == {"errors": expected, "warnings": []}
+
+
+def test_create_poetry_fails_on_invalid_configuration(
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    with pytest.raises(RuntimeError) as e:
+        Factory().create_poetry(fixture_dir("invalid_pyproject_dep_name"))
+
+    expected = """\
+The Poetry configuration is invalid:
+  - Project name (invalid) is same as one of its dependencies
+"""
+
+    assert str(e.value) == expected
+
+
+def test_create_poetry_fails_on_nameless_project(
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    with pytest.raises(RuntimeError) as e:
+        Factory().create_poetry(fixture_dir("nameless_pyproject"))
+
+    expected = """\
+The Poetry configuration is invalid:
+  - Either [project.name] or [tool.poetry.name] is required in package mode.
+"""
+
+    assert str(e.value) == expected
+
+
+def test_create_poetry_with_local_config(fixture_dir: FixtureDirGetter) -> None:
+    poetry = Factory().create_poetry(fixture_dir("with_local_config"))
+
+    assert not poetry.config.get("virtualenvs.in-project")
+    assert not poetry.config.get("virtualenvs.create")
+    assert not poetry.config.get("virtualenvs.options.always-copy")
+    assert not poetry.config.get("virtualenvs.options.no-pip")
+    assert not poetry.config.get("virtualenvs.options.system-site-packages")
+
+
+def test_create_poetry_with_plugins(
+    mocker: MockerFixture, fixture_dir: FixtureDirGetter
+) -> None:
+    mock_metadata_entry_points(mocker, MyPlugin)
+
+    poetry = Factory().create_poetry(fixture_dir("sample_project"))
+
+    assert poetry.package.readmes == (Path("README.md"),)
+
+
+@pytest.mark.parametrize(
+    ("source", "expected"),
+    [
+        ({}, "Missing [name] in source."),
+        ({"name": "foo"}, "Missing [url] in source 'foo'."),
+        (
+            {"name": "PyPI", "url": "https://example.com"},
+            "The PyPI repository cannot be configured with a custom url.",
+        ),
+    ],
+)
+def test_create_package_source_invalid(
+    source: dict[str, str],
+    expected: str,
+    config: Config,
+    fixture_dir: FixtureDirGetter,
+) -> None:
+    with pytest.raises(InvalidSourceError) as e:
+        Factory.create_package_source(source, config=config)
+        Factory().create_poetry(fixture_dir("with_source_pypi_url"))
+
+    assert str(e.value) == expected
diff --git b/tests/utils/conftest.py a/tests/utils/conftest.py
new file mode 100644
index 0000000..e9ec0be
--- /dev/null
+++ a/tests/utils/conftest.py
@@ -0,0 +1,21 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+
+if TYPE_CHECKING:
+    from poetry.poetry import Poetry
+    from poetry.utils.env import EnvManager
+
+
+@pytest.fixture
+def venv_name(
+    manager: EnvManager,
+    poetry: Poetry,
+) -> str:
+    return manager.generate_env_name(
+        poetry.package.name,
+        str(poetry.file.path.parent),
+    )
diff --git b/tests/utils/env/conftest.py a/tests/utils/env/conftest.py
new file mode 100644
index 0000000..c525019
--- /dev/null
+++ a/tests/utils/env/conftest.py
@@ -0,0 +1,23 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils.env import EnvManager
+
+
+if TYPE_CHECKING:
+    from poetry.poetry import Poetry
+    from tests.types import FixtureDirGetter
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture
+def poetry(project_factory: ProjectFactory, fixture_dir: FixtureDirGetter) -> Poetry:
+    return project_factory("simple", source=fixture_dir("simple_project"))
+
+
+@pytest.fixture
+def manager(poetry: Poetry) -> EnvManager:
+    return EnvManager(poetry)
diff --git b/tests/utils/env/python/test_manager.py a/tests/utils/env/python/test_manager.py
new file mode 100644
index 0000000..ec2ffef
--- /dev/null
+++ a/tests/utils/env/python/test_manager.py
@@ -0,0 +1,137 @@
+from __future__ import annotations
+
+import platform
+import sys
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.constraints.version import Version
+from poetry.core.constraints.version import parse_constraint
+
+from poetry.utils.env.python import Python
+from tests.helpers import pbs_installer_supported_arch
+
+
+if TYPE_CHECKING:
+    from tests.types import MockedPoetryPythonRegister
+    from tests.types import MockedPythonRegister
+
+
+def test_find_all(without_mocked_findpython: None) -> None:
+    assert len(list(Python.find_all())) > 1
+
+
+def test_find_all_with_poetry_managed(
+    without_mocked_findpython: None,
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+) -> None:
+    cpython_path = mocked_poetry_managed_python_register("3.9.1", "cpython")
+    pypy_path = mocked_poetry_managed_python_register("3.10.8", "pypy")
+    found_pythons = list(Python.find_all())
+    assert len(found_pythons) > 3
+    for poetry_python in (cpython_path, pypy_path):
+        assert any(p.executable.parent == poetry_python for p in found_pythons)
+
+
+def test_find_poetry_managed_pythons_none() -> None:
+    assert list(Python.find_poetry_managed_pythons()) == []
+
+
+def test_find_poetry_managed_pythons(
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+) -> None:
+    mocked_poetry_managed_python_register("3.9.1", "cpython")
+    mocked_poetry_managed_python_register("3.10.8", "pypy")
+
+    assert len(list(Python.find_poetry_managed_pythons())) == 3
+
+
+@pytest.mark.parametrize(
+    ("constraint", "implementation", "expected"),
+    [
+        (None, None, 3),
+        (None, "CPython", 2),
+        (None, "cpython", 2),
+        (None, "pypy", 1),
+        ("~3.9", None, 2),
+        ("~3.9", "cpython", 2),
+        ("~3.9", "pypy", 0),
+        (">=3.9.2", None, 2),
+        (">=3.9.2", "cpython", 1),
+        (">=3.9.2", "pypy", 1),
+        (">=3.10", None, 1),
+        ("~3.11", None, 0),
+    ],
+)
+def test_find_all_versions(
+    mocked_python_register: MockedPythonRegister,
+    constraint: str | None,
+    implementation: str | None,
+    expected: int,
+) -> None:
+    mocked_python_register("3.9.1", implementation="CPython", parent="a")
+    mocked_python_register("3.9.3", implementation="CPython", parent="b")
+    mocked_python_register("3.10.4", implementation="PyPy", parent="c")
+
+    assert len(list(Python.find_all_versions(constraint, implementation))) == expected
+
+
+@pytest.mark.parametrize("constraint", [None, "~3.9", ">=3.10"])
+def test_find_downloadable_versions(constraint: str | None) -> None:
+    versions = list(Python.find_downloadable_versions(constraint))
+    if platform.system() == "FreeBSD" or not pbs_installer_supported_arch(
+        platform.machine()
+    ):
+        assert len(versions) == 0
+    else:
+        assert len(versions) > 0
+    if constraint:
+        parsed_constraint = parse_constraint(constraint)
+        assert all(
+            parsed_constraint.allows(Version.parse(f"{v.major}.{v.minor}.{v.patch}"))
+            for v in versions
+        )
+
+
+def find_downloadable_versions_include_incompatible() -> None:
+    assert len(
+        list(Python.find_downloadable_versions(include_incompatible=True))
+    ) > len(list(Python.find_downloadable_versions()))
+
+
+@pytest.mark.parametrize(
+    ("name", "expected_minor"),
+    [
+        ("3.9", 9),
+        ("3.10", 10),
+        ("3.11", None),
+    ],
+)
+def test_get_by_name_version(
+    mocked_python_register: MockedPythonRegister, name: str, expected_minor: int | None
+) -> None:
+    mocked_python_register("3.9.1", implementation="CPython", parent="a")
+    mocked_python_register("3.10.3", implementation="CPython", parent="b")
+
+    python = Python.get_by_name(name)
+    if expected_minor is None:
+        assert python is None
+    else:
+        assert python is not None
+        assert python.minor == expected_minor
+
+
+def test_get_by_name_python(without_mocked_findpython: None) -> None:
+    python = Python.get_by_name("python")
+    assert python is not None
+    assert python.version.major == 3
+    assert python.version.minor == sys.version_info.minor
+
+
+def test_get_by_name_path(without_mocked_findpython: None) -> None:
+    python = Python.get_by_name(sys.executable)
+    assert python is not None
+    assert python.version.major == 3
+    assert python.version.minor == sys.version_info.minor
diff --git b/tests/utils/env/python/test_python_installer.py a/tests/utils/env/python/test_python_installer.py
new file mode 100644
index 0000000..2af261a
--- /dev/null
+++ a/tests/utils/env/python/test_python_installer.py
@@ -0,0 +1,108 @@
+from __future__ import annotations
+
+from subprocess import CalledProcessError
+from typing import TYPE_CHECKING
+from typing import cast
+
+import pytest
+
+from poetry.core.constraints.version import Version
+
+from poetry.console.exceptions import PoetryRuntimeError
+from poetry.utils.env.python.installer import PythonDownloadNotFoundError
+from poetry.utils.env.python.installer import PythonInstallationError
+from poetry.utils.env.python.installer import PythonInstaller
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+    from unittest.mock import MagicMock
+
+    from pytest_mock import MockerFixture
+
+
+@pytest.fixture(autouse=True)
+def mock_get_download_link(mocker: MockerFixture) -> MagicMock:
+    return mocker.patch(
+        "pbs_installer.get_download_link",
+        return_value=(mocker.Mock(major=3, minor=9, micro=1), None),
+    )
+
+
+def test_python_installer_version() -> None:
+    installer = PythonInstaller(request="3.9.1")
+    assert installer.version == Version.from_parts(3, 9, 1)
+
+
+def test_python_installer_version_not_found(mock_get_download_link: MagicMock) -> None:
+    mock_get_download_link.return_value = []
+    installer = PythonInstaller(request="3.9.1")
+    with pytest.raises(PythonDownloadNotFoundError):
+        _ = installer.version
+
+
+def test_python_installer_exists(mocker: MockerFixture) -> None:
+    mocker.patch(
+        "poetry.utils.env.python.Python.find_poetry_managed_pythons",
+        return_value=[
+            mocker.Mock(implementation="cpython", version=Version.from_parts(3, 9, 1))
+        ],
+    )
+    installer = PythonInstaller(request="3.9.1")
+    assert installer.exists()
+
+
+def test_python_installer_does_not_exist(mocker: MockerFixture) -> None:
+    mocker.patch(
+        "poetry.utils.env.python.Python.find_poetry_managed_pythons", return_value=[]
+    )
+    installer = PythonInstaller(request="3.9.1")
+    assert not installer.exists()
+
+
+def test_python_installer_exists_with_bad_executables(mocker: MockerFixture) -> None:
+    class BadPython:
+        @property
+        def implementation(self) -> str:
+            return "cpython"
+
+        @property
+        def executable(self) -> Path:
+            return cast("Path", mocker.Mock(as_posix=lambda: "/path/to/bad/python"))
+
+        @property
+        def version(self) -> None:
+            raise CalledProcessError(1, "cmd")
+
+    mocker.patch(
+        "poetry.utils.env.python.Python.find_poetry_managed_pythons",
+        return_value=[BadPython()],
+    )
+
+    installer = PythonInstaller(request="3.9.1")
+    with pytest.raises(PoetryRuntimeError):
+        assert not installer.exists()
+
+
+def test_python_installer_install(mocker: MockerFixture) -> None:
+    mocker.patch(
+        "pbs_installer.get_download_link",
+        return_value=(mocker.Mock(major=3, minor=9, micro=1), None),
+    )
+    install = mocker.patch("pbs_installer.install")
+    installer = PythonInstaller(request="3.9.1")
+    installer.install()
+    install.assert_called_once_with(
+        "3.9.1",
+        installer.installation_directory,
+        version_dir=True,
+        implementation="cpython",
+        free_threaded=False,
+    )
+
+
+def test_python_installer_install_error(mocker: MockerFixture) -> None:
+    mocker.patch("pbs_installer.install", side_effect=ValueError)
+    installer = PythonInstaller(request="3.9.1")
+    with pytest.raises(PythonInstallationError):
+        installer.install()
diff --git b/tests/utils/env/python/test_python_providers.py a/tests/utils/env/python/test_python_providers.py
new file mode 100644
index 0000000..f2c3e6e
--- /dev/null
+++ a/tests/utils/env/python/test_python_providers.py
@@ -0,0 +1,57 @@
+from __future__ import annotations
+
+import sys
+
+from typing import TYPE_CHECKING
+
+from poetry.core.constraints.version import Version
+
+from poetry.utils.env.python.providers import PoetryPythonPathProvider
+from poetry.utils.env.python.providers import ShutilWhichPythonProvider
+
+
+if TYPE_CHECKING:
+    from tests.types import MockedPoetryPythonRegister
+
+
+def test_shutil_which_python_provider() -> None:
+    provider = ShutilWhichPythonProvider.create()
+    assert provider
+    pythons = list(provider.find_pythons())
+    assert len(pythons) == 1
+    assert pythons[0].minor == sys.version_info.minor
+
+
+def test_poetry_python_path_provider_no_pythons() -> None:
+    provider = PoetryPythonPathProvider.create()
+    assert provider
+    assert not provider.paths
+
+
+def test_poetry_python_path_provider(
+    mocked_poetry_managed_python_register: MockedPoetryPythonRegister,
+) -> None:
+    cpython_path = mocked_poetry_managed_python_register("3.9.1", "cpython")
+    pypy_path = mocked_poetry_managed_python_register("3.10.8", "pypy")
+    free_threaded_path = mocked_poetry_managed_python_register(
+        "3.13.2", "cpython", with_install_dir=True
+    )
+
+    provider = PoetryPythonPathProvider.create()
+
+    assert provider
+
+    assert set(provider.paths) == {cpython_path, pypy_path, free_threaded_path}
+    assert len(list(provider.find_pythons())) == 4
+
+    assert provider.installation_bin_paths(Version.parse("3.9.1"), "cpython") == [
+        cpython_path
+    ]
+    assert provider.installation_bin_paths(Version.parse("3.9.2"), "cpython") == []
+    assert provider.installation_bin_paths(Version.parse("3.10.8"), "pypy") == [
+        pypy_path
+    ]
+    assert provider.installation_bin_paths(Version.parse("3.10.8"), "cpython") == []
+    assert provider.installation_bin_paths(Version.parse("3.13.2"), "cpython") == [
+        free_threaded_path
+    ]
diff --git b/tests/utils/env/test_env.py a/tests/utils/env/test_env.py
new file mode 100644
index 0000000..6715b44
--- /dev/null
+++ a/tests/utils/env/test_env.py
@@ -0,0 +1,577 @@
+from __future__ import annotations
+
+import os
+import re
+import subprocess
+import sys
+
+from pathlib import Path
+from threading import Thread
+from typing import TYPE_CHECKING
+
+import packaging.tags
+import pytest
+
+from deepdiff.diff import DeepDiff
+from installer.utils import SCHEME_NAMES
+
+from poetry.factory import Factory
+from poetry.repositories.installed_repository import InstalledRepository
+from poetry.utils._compat import WINDOWS
+from poetry.utils._compat import metadata
+from poetry.utils.env import EnvCommandError
+from poetry.utils.env import EnvManager
+from poetry.utils.env import GenericEnv
+from poetry.utils.env import MockEnv
+from poetry.utils.env import SystemEnv
+from poetry.utils.env import VirtualEnv
+from poetry.utils.env import build_environment
+from poetry.utils.env import ephemeral_environment
+from poetry.utils.helpers import is_dir_writable
+
+
+if TYPE_CHECKING:
+    from collections.abc import Iterator
+
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from tests.types import FixtureDirGetter
+    from tests.types import SetProjectContext
+
+MINIMAL_SCRIPT = """\
+
+print("Minimal Output"),
+"""
+
+# Script expected to fail.
+ERRORING_SCRIPT = """\
+import nullpackage
+
+print("nullpackage loaded"),
+"""
+
+
+class MockVirtualEnv(VirtualEnv):
+    def __init__(
+        self,
+        path: Path,
+        base: Path | None = None,
+        sys_path: list[str] | None = None,
+    ) -> None:
+        super().__init__(path, base=base)
+
+        self._sys_path = sys_path
+
+    @property
+    def sys_path(self) -> list[str]:
+        if self._sys_path is not None:
+            return self._sys_path
+
+        return super().sys_path
+
+
+def test_virtualenvs_with_spaces_in_their_path_work_as_expected(
+    tmp_path: Path, manager: EnvManager
+) -> None:
+    venv_path = tmp_path / "Virtual Env"
+
+    manager.build_venv(venv_path)
+
+    venv = VirtualEnv(venv_path)
+
+    assert venv.run("python", "-V").startswith("Python")
+
+
+def test_env_commands_with_spaces_in_their_arg_work_as_expected(
+    tmp_path: Path, manager: EnvManager
+) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    manager.build_venv(venv_path)
+    venv = VirtualEnv(venv_path)
+    output = venv.run("python", str(venv.pip), "--version")
+    assert re.match(r"pip \S+ from", output)
+
+
+@pytest.mark.parametrize("differing_platform", [True, False])
+def test_env_get_supported_tags_matches_inside_virtualenv(
+    tmp_path: Path, manager: EnvManager, mocker: MockerFixture, differing_platform: bool
+) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    manager.build_venv(venv_path)
+    venv = VirtualEnv(venv_path)
+
+    run_python_script_spy = mocker.spy(venv, "run_python_script")
+
+    # determine expected tags before patching sysconfig!
+    expected_tags = list(packaging.tags.sys_tags())
+
+    if differing_platform:
+        mocker.patch("sysconfig.get_platform", return_value="some_other_platform")
+        expected_call_count = 2
+    else:
+        expected_call_count = 1
+
+    assert venv.get_supported_tags() == expected_tags
+    assert run_python_script_spy.call_count == expected_call_count
+
+
+@pytest.mark.skipif(os.name == "nt", reason="Symlinks are not support for Windows")
+def test_env_has_symlinks_on_nix(tmp_path: Path, tmp_venv: VirtualEnv) -> None:
+    assert os.path.islink(tmp_venv.python)
+
+
+def test_run_with_keyboard_interrupt(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch("subprocess.check_output", side_effect=KeyboardInterrupt())
+    with pytest.raises(KeyboardInterrupt):
+        tmp_venv.run("python", "-c", MINIMAL_SCRIPT)
+    subprocess.check_output.assert_called_once()  # type: ignore[attr-defined]
+
+
+def test_call_with_keyboard_interrupt(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch("subprocess.check_call", side_effect=KeyboardInterrupt())
+    kwargs = {"call": True}
+    with pytest.raises(KeyboardInterrupt):
+        tmp_venv.run("python", "-", **kwargs)
+    subprocess.check_call.assert_called_once()  # type: ignore[attr-defined]
+
+
+def test_run_with_called_process_error(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=subprocess.CalledProcessError(
+            42, "some_command", "some output", "some error"
+        ),
+    )
+    with pytest.raises(EnvCommandError) as error:
+        tmp_venv.run("python", "-c", MINIMAL_SCRIPT)
+    subprocess.check_output.assert_called_once()  # type: ignore[attr-defined]
+    assert "some output" in str(error.value)
+    assert "some error" in str(error.value)
+
+
+def test_call_no_input_with_called_process_error(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "subprocess.check_call",
+        side_effect=subprocess.CalledProcessError(
+            42, "some_command", "some output", "some error"
+        ),
+    )
+    kwargs = {"call": True}
+    with pytest.raises(EnvCommandError) as error:
+        tmp_venv.run("python", "-", **kwargs)
+    subprocess.check_call.assert_called_once()  # type: ignore[attr-defined]
+    assert "some output" in str(error.value)
+    assert "some error" in str(error.value)
+
+
+def test_check_output_with_called_process_error(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=subprocess.CalledProcessError(
+            42, "some_command", "some output", "some error"
+        ),
+    )
+    with pytest.raises(EnvCommandError) as error:
+        tmp_venv.run("python", "-")
+    subprocess.check_output.assert_called_once()  # type: ignore[attr-defined]
+    assert "some output" in str(error.value)
+    assert "some error" in str(error.value)
+
+
+@pytest.mark.parametrize("out", ["sys.stdout", "sys.stderr"])
+def test_call_does_not_block_on_full_pipe(
+    tmp_path: Path, tmp_venv: VirtualEnv, out: str
+) -> None:
+    """see https://github.com/python-poetry/poetry/issues/7698"""
+    script = tmp_path / "script.py"
+    script.write_text(
+        f"""\
+import sys
+for i in range(10000):
+    print('just print a lot of text to fill the buffer', file={out})
+""",
+        encoding="utf-8",
+    )
+
+    def target(result: list[int]) -> None:
+        tmp_venv.run("python", str(script), call=True)
+        result.append(0)
+
+    results: list[int] = []
+    # use a separate thread, so that the test does not block in case of error
+    thread = Thread(target=target, args=(results,))
+    thread.start()
+    thread.join(1)  # must not block
+    assert results and results[0] == 0
+
+
+def test_run_python_script_called_process_error(
+    tmp_path: Path, tmp_venv: VirtualEnv, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "subprocess.run",
+        side_effect=subprocess.CalledProcessError(
+            42, "some_command", "some output", "some error"
+        ),
+    )
+    with pytest.raises(EnvCommandError) as error:
+        tmp_venv.run_python_script(MINIMAL_SCRIPT)
+    assert "some output" in str(error.value)
+    assert "some error" in str(error.value)
+
+
+def test_run_python_script_only_stdout(tmp_path: Path, tmp_venv: VirtualEnv) -> None:
+    output = tmp_venv.run_python_script(
+        "import sys; print('some warning', file=sys.stderr); print('some output')"
+    )
+    assert "some output" in output
+    assert "some warning" not in output
+
+
+def test_system_env_has_correct_paths() -> None:
+    env = SystemEnv(Path(sys.prefix))
+
+    paths = env.paths
+
+    assert paths.get("purelib") is not None
+    assert paths.get("platlib") is not None
+    assert paths.get("scripts") is not None
+    assert env.site_packages.path == Path(paths["purelib"])
+    assert paths["include"] is not None
+
+
+@pytest.mark.parametrize(
+    "enabled",
+    [True, False],
+)
+def test_system_env_usersite(mocker: MockerFixture, enabled: bool) -> None:
+    mocker.patch("site.check_enableusersite", return_value=enabled)
+    env = SystemEnv(Path(sys.prefix))
+    assert (enabled and env.usersite is not None) or (
+        not enabled and env.usersite is None
+    )
+
+
+def test_venv_has_correct_paths(tmp_venv: VirtualEnv) -> None:
+    paths = tmp_venv.paths
+
+    assert paths.get("purelib") is not None
+    assert paths.get("platlib") is not None
+    assert paths.get("scripts") is not None
+    assert tmp_venv.site_packages.path == Path(paths["purelib"])
+    assert paths["include"] == str(
+        tmp_venv.path.joinpath(
+            f"include/site/python{tmp_venv.version_info[0]}.{tmp_venv.version_info[1]}"
+        )
+    )
+
+
+@pytest.mark.parametrize("with_system_site_packages", [True, False])
+def test_env_system_packages(
+    tmp_path: Path, poetry: Poetry, with_system_site_packages: bool
+) -> None:
+    venv_path = tmp_path / "venv"
+    pyvenv_cfg = venv_path / "pyvenv.cfg"
+
+    EnvManager(poetry).build_venv(
+        path=venv_path, flags={"system-site-packages": with_system_site_packages}
+    )
+    env = VirtualEnv(venv_path)
+
+    assert (
+        f"include-system-site-packages = {str(with_system_site_packages).lower()}"
+        in pyvenv_cfg.read_text(encoding="utf-8")
+    )
+    assert env.includes_system_site_packages is with_system_site_packages
+
+
+def test_generic_env_system_packages(poetry: Poetry) -> None:
+    """https://github.com/python-poetry/poetry/issues/8646"""
+    env = GenericEnv(Path(sys.base_prefix))
+    assert not env.includes_system_site_packages
+
+
+@pytest.mark.parametrize("with_system_site_packages", [True, False])
+def test_env_system_packages_are_relative_to_lib(
+    tmp_path: Path, poetry: Poetry, with_system_site_packages: bool
+) -> None:
+    venv_path = tmp_path / "venv"
+    EnvManager(poetry).build_venv(
+        path=venv_path, flags={"system-site-packages": with_system_site_packages}
+    )
+    env = VirtualEnv(venv_path)
+
+    # These are Poetry's own dependencies.
+    # They should not be relative to the virtualenv's lib directory.
+    for dist in metadata.distributions():
+        assert not env.is_path_relative_to_lib(
+            Path(str(dist._path))  # type: ignore[attr-defined]
+        )
+        # Checking one package is sufficient
+        break
+    else:
+        pytest.fail("No distributions found in Poetry's own environment")
+
+    # These are the virtual environments' base env packages,
+    # in this case the system site packages.
+    for dist in env.parent_env.site_packages.distributions():
+        assert (
+            env.is_path_relative_to_lib(
+                Path(str(dist._path))  # type: ignore[attr-defined]
+            )
+            is with_system_site_packages
+        )
+        # Checking one package is sufficient
+        break
+    else:
+        pytest.fail("No distributions found in the base environment of the virtualenv")
+
+
+@pytest.mark.parametrize(
+    ("flags", "packages"),
+    [
+        ({"no-pip": False}, {"pip"}),
+        ({"no-pip": True}, set()),
+        ({}, set()),
+    ],
+)
+def test_env_no_pip(
+    tmp_path: Path, poetry: Poetry, flags: dict[str, str | bool], packages: set[str]
+) -> None:
+    venv_path = tmp_path / "venv"
+    EnvManager(poetry).build_venv(path=venv_path, flags=flags)
+    env = VirtualEnv(venv_path)
+    installed_repository = InstalledRepository.load(env=env, with_dependencies=True)
+    installed_packages = {
+        package.name
+        for package in installed_repository.packages
+        # workaround for BSD test environments
+        if package.name != "sqlite3"
+    }
+
+    assert installed_packages == packages
+
+
+def test_env_finds_the_correct_executables(tmp_path: Path, manager: EnvManager) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    manager.build_venv(venv_path, with_pip=True)
+    venv = VirtualEnv(venv_path)
+
+    default_executable = expected_executable = f"python{'.exe' if WINDOWS else ''}"
+    default_pip_executable = expected_pip_executable = f"pip{'.exe' if WINDOWS else ''}"
+    major_executable = f"python{sys.version_info[0]}{'.exe' if WINDOWS else ''}"
+    major_pip_executable = f"pip{sys.version_info[0]}{'.exe' if WINDOWS else ''}"
+
+    if (
+        venv._bin_dir.joinpath(default_executable).exists()
+        and venv._bin_dir.joinpath(major_executable).exists()
+    ):
+        venv._bin_dir.joinpath(default_executable).unlink()
+        expected_executable = major_executable
+
+    if (
+        venv._bin_dir.joinpath(default_pip_executable).exists()
+        and venv._bin_dir.joinpath(major_pip_executable).exists()
+    ):
+        venv._bin_dir.joinpath(default_pip_executable).unlink()
+        expected_pip_executable = major_pip_executable
+
+    venv = VirtualEnv(venv_path)
+
+    assert Path(venv.python).name == expected_executable
+    assert Path(venv.pip).name.startswith(expected_pip_executable.split(".")[0])
+
+
+def test_env_finds_the_correct_executables_for_generic_env(
+    tmp_path: Path, manager: EnvManager
+) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    child_venv_path = tmp_path / "Child Virtual Env"
+    manager.build_venv(venv_path, with_pip=True)
+    parent_venv = VirtualEnv(venv_path)
+    manager.build_venv(child_venv_path, executable=parent_venv.python, with_pip=True)
+    venv = GenericEnv(parent_venv.path, child_env=VirtualEnv(child_venv_path))
+
+    expected_executable = (
+        f"python{sys.version_info[0]}.{sys.version_info[1]}{'.exe' if WINDOWS else ''}"
+    )
+    expected_pip_executable = (
+        f"pip{sys.version_info[0]}.{sys.version_info[1]}{'.exe' if WINDOWS else ''}"
+    )
+
+    if WINDOWS:
+        expected_executable = "python.exe"
+        expected_pip_executable = "pip.exe"
+
+    assert Path(venv.python).name == expected_executable
+    assert Path(venv.pip).name == expected_pip_executable
+
+
+def test_env_finds_fallback_executables_for_generic_env(
+    tmp_path: Path, manager: EnvManager
+) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    child_venv_path = tmp_path / "Child Virtual Env"
+    manager.build_venv(venv_path, with_pip=True)
+    parent_venv = VirtualEnv(venv_path)
+    manager.build_venv(child_venv_path, executable=parent_venv.python, with_pip=True)
+    venv = GenericEnv(parent_venv.path, child_env=VirtualEnv(child_venv_path))
+
+    default_executable = f"python{'.exe' if WINDOWS else ''}"
+    major_executable = f"python{sys.version_info[0]}{'.exe' if WINDOWS else ''}"
+    minor_executable = (
+        f"python{sys.version_info[0]}.{sys.version_info[1]}{'.exe' if WINDOWS else ''}"
+    )
+    expected_executable = minor_executable
+    if (
+        venv._bin_dir.joinpath(expected_executable).exists()
+        and venv._bin_dir.joinpath(major_executable).exists()
+    ):
+        venv._bin_dir.joinpath(expected_executable).unlink()
+        expected_executable = major_executable
+
+    if (
+        venv._bin_dir.joinpath(expected_executable).exists()
+        and venv._bin_dir.joinpath(default_executable).exists()
+    ):
+        venv._bin_dir.joinpath(expected_executable).unlink()
+        expected_executable = default_executable
+
+    default_pip_executable = f"pip{'.exe' if WINDOWS else ''}"
+    major_pip_executable = f"pip{sys.version_info[0]}{'.exe' if WINDOWS else ''}"
+    minor_pip_executable = (
+        f"pip{sys.version_info[0]}.{sys.version_info[1]}{'.exe' if WINDOWS else ''}"
+    )
+    expected_pip_executable = minor_pip_executable
+    if (
+        venv._bin_dir.joinpath(expected_pip_executable).exists()
+        and venv._bin_dir.joinpath(major_pip_executable).exists()
+    ):
+        venv._bin_dir.joinpath(expected_pip_executable).unlink()
+        expected_pip_executable = major_pip_executable
+
+    if (
+        venv._bin_dir.joinpath(expected_pip_executable).exists()
+        and venv._bin_dir.joinpath(default_pip_executable).exists()
+    ):
+        venv._bin_dir.joinpath(expected_pip_executable).unlink()
+        expected_pip_executable = default_pip_executable
+
+    if not venv._bin_dir.joinpath(expected_executable).exists():
+        expected_executable = default_executable
+
+    if not venv._bin_dir.joinpath(expected_pip_executable).exists():
+        expected_pip_executable = default_pip_executable
+
+    venv = GenericEnv(parent_venv.path, child_env=VirtualEnv(child_venv_path))
+
+    assert Path(venv.python).name == expected_executable
+    assert Path(venv.pip).name == expected_pip_executable
+
+
+@pytest.fixture
+def extended_without_setup_poetry(
+    fixture_dir: FixtureDirGetter, set_project_context: SetProjectContext
+) -> Iterator[Poetry]:
+    with set_project_context("extended_project_without_setup") as cwd:
+        yield Factory().create_poetry(cwd)
+
+
+def test_build_environment_called_build_script_specified(
+    mocker: MockerFixture,
+    extended_without_setup_poetry: Poetry,
+) -> None:
+    patched_install = mocker.patch("poetry.utils.isolated_build.IsolatedEnv.install")
+
+    with ephemeral_environment() as project_env:
+        import poetry.utils.env
+
+        spy = mocker.spy(poetry.utils.env, "ephemeral_environment")
+
+        with build_environment(extended_without_setup_poetry, project_env):
+            assert patched_install.call_count == 1
+            assert patched_install.call_args == mocker.call(["poetry-core", "cython"])
+
+        assert spy.call_count == 1
+
+
+def test_build_environment_not_called_without_build_script_specified(
+    mocker: MockerFixture, poetry: Poetry, tmp_path: Path
+) -> None:
+    project_env = MockEnv(path=tmp_path / "project")
+    ephemeral_env = MockEnv(path=tmp_path / "ephemeral")
+
+    mocker.patch(
+        "poetry.utils.env.ephemeral_environment"
+    ).return_value.__enter__.return_value = ephemeral_env
+
+    with build_environment(poetry, project_env) as env:
+        assert env == project_env
+        assert not env.executed  # type: ignore[attr-defined]
+
+
+def test_command_from_bin_preserves_relative_path(manager: EnvManager) -> None:
+    # https://github.com/python-poetry/poetry/issues/7959
+    env = manager.get()
+    command = env.get_command_from_bin("./foo.py")
+    assert command == ["./foo.py"]
+
+
+@pytest.fixture
+def system_env_read_only(system_env: SystemEnv, mocker: MockerFixture) -> SystemEnv:
+    original_is_dir_writable = is_dir_writable
+
+    read_only_paths = {system_env.paths[key] for key in SCHEME_NAMES}
+
+    def mock_is_dir_writable(path: Path, create: bool = False) -> bool:
+        if str(path) in read_only_paths:
+            return False
+        return original_is_dir_writable(path, create)
+
+    mocker.patch("poetry.utils.env.base_env.is_dir_writable", new=mock_is_dir_writable)
+
+    return system_env
+
+
+def test_env_scheme_dict_returns_original_when_writable(system_env: SystemEnv) -> None:
+    assert not DeepDiff(system_env.scheme_dict, system_env.paths, ignore_order=True)
+
+
+def test_env_scheme_dict_returns_modified_when_read_only(
+    system_env_read_only: SystemEnv,
+) -> None:
+    scheme_dict = system_env_read_only.scheme_dict
+    assert DeepDiff(scheme_dict, system_env_read_only.paths, ignore_order=True)
+
+    paths = system_env_read_only.paths
+    assert all(
+        Path(scheme_dict[scheme]).exists()
+        and scheme_dict[scheme].startswith(paths["userbase"])
+        for scheme in SCHEME_NAMES
+    )
+
+
+def test_marker_env_is_equal_for_all_envs(tmp_path: Path, manager: EnvManager) -> None:
+    venv_path = tmp_path / "Virtual Env"
+    manager.build_venv(venv_path)
+    venv = VirtualEnv(venv_path)
+    generic_env = GenericEnv(venv.path)
+    system_env = SystemEnv(Path(sys.prefix))
+
+    venv_marker_env = venv.marker_env
+    generic_marker_env = generic_env.marker_env
+    system_marker_env = system_env.marker_env
+
+    assert venv_marker_env == generic_marker_env
+    assert venv_marker_env == system_marker_env
diff --git b/tests/utils/env/test_env_manager.py a/tests/utils/env/test_env_manager.py
new file mode 100644
index 0000000..54dd601
--- /dev/null
+++ a/tests/utils/env/test_env_manager.py
@@ -0,0 +1,1304 @@
+from __future__ import annotations
+
+import logging
+import os
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+import tomlkit
+
+from poetry.core.constraints.version import Version
+
+from poetry.toml.file import TOMLFile
+from poetry.utils.env import GET_BASE_PREFIX
+from poetry.utils.env import GET_PYTHON_VERSION_ONELINER
+from poetry.utils.env import EnvManager
+from poetry.utils.env import IncorrectEnvError
+from poetry.utils.env.env_manager import EnvsFile
+from poetry.utils.env.python.exceptions import InvalidCurrentPythonVersionError
+from poetry.utils.env.python.exceptions import NoCompatiblePythonVersionFoundError
+from poetry.utils.env.python.exceptions import PythonVersionNotFoundError
+from poetry.utils.helpers import remove_directory
+
+
+if TYPE_CHECKING:
+    from collections.abc import Callable
+    from collections.abc import Iterator
+    from unittest.mock import MagicMock
+
+    from pytest import LogCaptureFixture
+    from pytest_mock import MockerFixture
+
+    from poetry.poetry import Poetry
+    from tests.conftest import Config
+    from tests.types import FixtureDirGetter
+    from tests.types import MockedPythonRegister
+    from tests.types import ProjectFactory
+
+VERSION_3_7_1 = Version.parse("3.7.1")
+
+
+def build_venv(path: Path | str, **__: Any) -> None:
+    os.mkdir(str(path))
+
+
+def check_output_wrapper(
+    version: Version = VERSION_3_7_1,
+) -> Callable[[list[str], Any, Any], str]:
+    def check_output(cmd: list[str], *args: Any, **kwargs: Any) -> str:
+        # cmd is a list, like ["python", "-c", "do stuff"]
+        python_cmd = cmd[-1]
+        if "print(json.dumps(env))" in python_cmd:
+            return (
+                f'{{"version_info": [{version.major}, {version.minor},'
+                f" {version.patch}]}}"
+            )
+
+        if "sys.version_info[:3]" in python_cmd:
+            return version.text
+
+        if "sys.version_info[:2]" in python_cmd:
+            return f"{version.major}.{version.minor}"
+
+        if "import sys; print(sys.executable)" in python_cmd:
+            executable = cmd[0]
+            basename = os.path.basename(executable)
+            return f"/usr/bin/{basename}"
+
+        if "print(sys.base_prefix)" in python_cmd:
+            return sys.base_prefix
+
+        assert "import sys; print(sys.prefix)" in python_cmd
+        return "/prefix"
+
+    return check_output
+
+
+@pytest.fixture
+def in_project_venv_dir(poetry: Poetry) -> Iterator[Path]:
+    os.environ.pop("VIRTUAL_ENV", None)
+    venv_dir = poetry.file.path.parent.joinpath(".venv")
+    venv_dir.mkdir()
+    try:
+        yield venv_dir
+    finally:
+        venv_dir.rmdir()
+
+
+@pytest.mark.parametrize(
+    ("section", "version", "expected"),
+    [
+        ("foo", None, "3.10"),
+        ("bar", None, "3.11"),
+        ("baz", None, "3.12"),
+        ("bar", "3.11", "3.11"),
+        ("bar", "3.10", None),
+    ],
+)
+def test_envs_file_remove_section(
+    tmp_path: Path, section: str, version: str | None, expected: str | None
+) -> None:
+    envs_file_path = tmp_path / "envs.toml"
+
+    envs_file = TOMLFile(envs_file_path)
+    doc = tomlkit.document()
+    doc["foo"] = {"minor": "3.10", "patch": "3.10.13"}
+    doc["bar"] = {"minor": "3.11", "patch": "3.11.7"}
+    doc["baz"] = {"minor": "3.12", "patch": "3.12.1"}
+    envs_file.write(doc)
+
+    minor = EnvsFile(envs_file_path).remove_section(section, version)
+
+    assert minor == expected
+
+    envs = TOMLFile(envs_file_path).read()
+    if expected is None:
+        assert section in envs
+    else:
+        assert section not in envs
+    for other_section in {"foo", "bar", "baz"} - {section}:
+        assert other_section in envs
+
+
+def test_activate_in_project_venv_no_explicit_config(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    mocker: MockerFixture,
+    venv_name: str,
+    in_project_venv_dir: Path,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    mocked_python_register("3.7.1")
+    m = mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
+
+    env = manager.activate("python3.7")
+
+    assert env.path == tmp_path / "poetry-fixture-simple" / ".venv"
+    assert env.base == Path(sys.base_prefix)
+
+    m.assert_called_with(
+        tmp_path / "poetry-fixture-simple" / ".venv",
+        executable=Path("/usr/bin/python3.7"),
+        flags={
+            "always-copy": False,
+            "system-site-packages": False,
+            "no-pip": False,
+        },
+        prompt="simple-project-py3.7",
+    )
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    assert not envs_file.exists()
+
+
+def test_activate_activates_non_existing_virtualenv_no_envs_file(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.7.1")
+    m = mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
+
+    env = manager.activate("python3.7")
+
+    m.assert_called_with(
+        tmp_path / f"{venv_name}-py3.7",
+        executable=Path("/usr/bin/python3.7"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.7",
+    )
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.7"
+    assert envs[venv_name]["patch"] == "3.7.1"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.7"
+    assert env.base == Path(sys.base_prefix)
+
+
+def test_activate_fails_when_python_cannot_be_found(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("2.7.1")
+
+    with pytest.raises(PythonVersionNotFoundError) as e:
+        manager.activate("python3.7")
+
+    expected_message = "Could not find the python executable python3.7"
+    assert str(e.value) == expected_message
+
+
+def test_activate_activates_existing_virtualenv_no_envs_file(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.7.1")
+    m = mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
+
+    env = manager.activate("python3.7")
+
+    m.assert_not_called()
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.7"
+    assert envs[venv_name]["patch"] == "3.7.1"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.7"
+    assert env.base == Path(sys.base_prefix)
+
+
+def test_activate_activates_same_virtualenv_with_envs_file(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.1"}
+    envs_file.write(doc)
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.7.1")
+    m = mocker.patch("poetry.utils.env.EnvManager.create_venv")
+
+    env = manager.activate("python3.7")
+
+    m.assert_not_called()
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.7"
+    assert envs[venv_name]["patch"] == "3.7.1"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.7"
+    assert env.base == Path(sys.base_prefix)
+
+
+def test_activate_activates_different_virtualenv_with_envs_file(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.1"}
+    envs_file.write(doc)
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.6.6")
+    mocked_python_register("3.7.1")
+
+    m = mocker.patch("poetry.utils.env.EnvManager.build_venv", side_effect=build_venv)
+
+    env = manager.activate("python3.6")
+
+    m.assert_called_with(
+        tmp_path / f"{venv_name}-py3.6",
+        executable=Path("/usr/bin/python3.6"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.6",
+    )
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.6"
+    assert envs[venv_name]["patch"] == "3.6.6"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.6"
+    assert env.base == Path(sys.base_prefix)
+
+
+def test_activate_activates_recreates_for_different_patch(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.0"}
+    envs_file.write(doc)
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.7.1")
+    build_venv_m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=build_venv
+    )
+    remove_venv_m = mocker.patch(
+        "poetry.utils.env.EnvManager.remove_venv", side_effect=EnvManager.remove_venv
+    )
+
+    env = manager.activate("python3.7")
+
+    build_venv_m.assert_called_with(
+        tmp_path / f"{venv_name}-py3.7",
+        executable=Path("/usr/bin/python3.7"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.7",
+    )
+    remove_venv_m.assert_called_with(tmp_path / f"{venv_name}-py3.7")
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.7"
+    assert envs[venv_name]["patch"] == "3.7.1"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.7"
+    assert env.base == Path(sys.base_prefix)
+    assert (tmp_path / f"{venv_name}-py3.7").exists()
+
+
+def test_activate_does_not_recreate_when_switching_minor(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.0"}
+    envs_file.write(doc)
+
+    os.mkdir(tmp_path / f"{venv_name}-py3.7")
+    os.mkdir(tmp_path / f"{venv_name}-py3.6")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocked_python_register("3.7.1")
+    mocked_python_register("3.6.6")
+
+    build_venv_m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=build_venv
+    )
+    remove_venv_m = mocker.patch(
+        "poetry.utils.env.EnvManager.remove_venv", side_effect=EnvManager.remove_venv
+    )
+
+    env = manager.activate("python3.6")
+
+    build_venv_m.assert_not_called()
+    remove_venv_m.assert_not_called()
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert envs[venv_name]["minor"] == "3.6"
+    assert envs[venv_name]["patch"] == "3.6.6"
+
+    assert env.path == tmp_path / f"{venv_name}-py3.6"
+    assert env.base == Path(sys.base_prefix)
+    assert (tmp_path / f"{venv_name}-py3.6").exists()
+
+
+def test_activate_with_in_project_setting_does_not_fail_if_no_venvs_dir(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    tmp_path: Path,
+    mocker: MockerFixture,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    config.merge(
+        {
+            "virtualenvs": {
+                "path": str(tmp_path / "virtualenvs"),
+                "in-project": True,
+            }
+        }
+    )
+
+    mocked_python_register("3.7.1")
+    m = mocker.patch("poetry.utils.env.EnvManager.build_venv")
+
+    manager.activate("python3.7")
+
+    m.assert_called_with(
+        poetry.file.path.parent / ".venv",
+        executable=Path("/usr/bin/python3.7"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.7",
+    )
+
+    envs_file = TOMLFile(tmp_path / "virtualenvs" / "envs.toml")
+    assert not envs_file.exists()
+
+
+def test_deactivate_non_activated_but_existing(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    venv_name: str,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    python = ".".join(str(c) for c in sys.version_info[:2])
+    (tmp_path / f"{venv_name}-py{python}").mkdir()
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    manager.deactivate()
+    env = manager.get()
+
+    assert env.path == tmp_path / f"{venv_name}-py{python}"
+
+
+def test_deactivate_activated(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    version = Version.from_parts(*sys.version_info[:3])
+    other_version = Version.parse("3.4") if version.major == 2 else version.next_minor()
+    (tmp_path / f"{venv_name}-py{version.major}.{version.minor}").mkdir()
+    (tmp_path / f"{venv_name}-py{other_version.major}.{other_version.minor}").mkdir()
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {
+        "minor": f"{other_version.major}.{other_version.minor}",
+        "patch": other_version.text,
+    }
+    envs_file.write(doc)
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(),
+    )
+
+    manager.deactivate()
+    env = manager.get()
+
+    assert env.path == tmp_path / f"{venv_name}-py{version.major}.{version.minor}"
+
+    envs = envs_file.read()
+    assert len(envs) == 0
+
+
+@pytest.mark.parametrize("in_project", [True, False, None])
+def test_get_venv_with_venv_folder_present(
+    manager: EnvManager,
+    poetry: Poetry,
+    in_project_venv_dir: Path,
+    in_project: bool | None,
+) -> None:
+    poetry.config.config["virtualenvs"]["in-project"] = in_project
+    venv = manager.get()
+    if in_project is False:
+        assert venv.path != in_project_venv_dir
+    else:
+        assert venv.path == in_project_venv_dir
+
+
+def test_get_prefers_explicitly_activated_virtualenvs_over_env_var(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    os.environ["VIRTUAL_ENV"] = "/environment/prefix"
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.7", "patch": "3.7.0"}
+    envs_file.write(doc)
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(),
+    )
+
+    env = manager.get()
+
+    assert env.path == tmp_path / f"{venv_name}-py3.7"
+    assert env.base == Path(sys.base_prefix)
+
+
+def test_list(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    venvs = manager.list()
+
+    assert len(venvs) == 2
+    assert venvs[0].path == tmp_path / f"{venv_name}-py3.6"
+    assert venvs[1].path == tmp_path / f"{venv_name}-py3.7"
+
+
+def test_remove_by_python_version(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    venv = manager.remove("3.6")
+
+    expected_venv_path = tmp_path / f"{venv_name}-py3.6"
+    assert venv.path == expected_venv_path
+    assert not expected_venv_path.exists()
+
+
+def test_remove_by_name(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    venv = manager.remove(f"{venv_name}-py3.6")
+
+    expected_venv_path = tmp_path / f"{venv_name}-py3.6"
+    assert venv.path == expected_venv_path
+    assert not expected_venv_path.exists()
+
+
+def test_remove_by_string_with_python_and_version(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    venv = manager.remove("python3.6")
+
+    expected_venv_path = tmp_path / f"{venv_name}-py3.6"
+    assert venv.path == expected_venv_path
+    assert not expected_venv_path.exists()
+
+
+def test_remove_by_full_path_to_python(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    expected_venv_path = tmp_path / f"{venv_name}-py3.6"
+    python_path = expected_venv_path / "bin" / "python"
+
+    venv = manager.remove(str(python_path))
+
+    assert venv.path == expected_venv_path
+    assert not expected_venv_path.exists()
+
+
+def test_remove_raises_if_acting_on_different_project_by_full_path(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    different_venv_name = "different-project"
+    different_venv_path = tmp_path / f"{different_venv_name}-py3.6"
+    different_venv_bin_path = different_venv_path / "bin"
+    different_venv_bin_path.mkdir(parents=True)
+
+    python_path = different_venv_bin_path / "python"
+    python_path.touch(exist_ok=True)
+
+    # Patch initial call where python env path is extracted
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=lambda *args, **kwargs: str(different_venv_path),
+    )
+
+    with pytest.raises(IncorrectEnvError):
+        manager.remove(str(python_path))
+
+
+def test_remove_raises_if_acting_on_different_project_by_name(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    different_venv_name = (
+        EnvManager.generate_env_name(
+            "different-project",
+            str(poetry.file.path.parent),
+        )
+        + "-py3.6"
+    )
+    different_venv_path = tmp_path / different_venv_name
+    different_venv_bin_path = different_venv_path / "bin"
+    different_venv_bin_path.mkdir(parents=True)
+
+    python_path = different_venv_bin_path / "python"
+    python_path.touch(exist_ok=True)
+
+    with pytest.raises(IncorrectEnvError):
+        manager.remove(different_venv_name)
+
+
+def test_raises_when_passing_old_env_after_dir_rename(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    venv_name: str,
+) -> None:
+    # Make sure that poetry raises when trying to remove old venv after you've renamed
+    # root directory of the project, which will create another venv with new name.
+    # This is not ideal as you still "can't" remove it by name, but it at least doesn't
+    # cause any unwanted side effects
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    previous_venv_name = EnvManager.generate_env_name(
+        poetry.package.name,
+        "previous_dir_name",
+    )
+    venv_path = tmp_path / f"{venv_name}-py3.6"
+    venv_path.mkdir()
+
+    previous_venv_name = f"{previous_venv_name}-py3.6"
+    previous_venv_path = tmp_path / previous_venv_name
+    previous_venv_path.mkdir()
+
+    with pytest.raises(IncorrectEnvError):
+        manager.remove(previous_venv_name)
+
+
+def test_remove_also_deactivates(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    (tmp_path / f"{venv_name}-py3.7").mkdir()
+    (tmp_path / f"{venv_name}-py3.6").mkdir()
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    doc[venv_name] = {"minor": "3.6", "patch": "3.6.6"}
+    envs_file.write(doc)
+
+    venv = manager.remove("python3.6")
+
+    expected_venv_path = tmp_path / f"{venv_name}-py3.6"
+    assert venv.path == expected_venv_path
+    assert not expected_venv_path.exists()
+
+    envs = envs_file.read()
+    assert venv_name not in envs
+
+
+def test_remove_keeps_dir_if_not_deleteable(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+) -> None:
+    # Ensure we empty rather than delete folder if its is an active mount point.
+    # See https://github.com/python-poetry/poetry/pull/2064
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    venv_path = tmp_path / f"{venv_name}-py3.6"
+    venv_path.mkdir()
+
+    folder1_path = venv_path / "folder1"
+    folder1_path.mkdir()
+
+    file1_path = folder1_path / "file1"
+    file1_path.touch(exist_ok=False)
+
+    file2_path = venv_path / "file2"
+    file2_path.touch(exist_ok=False)
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=check_output_wrapper(Version.parse("3.6.6")),
+    )
+
+    def err_on_rm_venv_only(path: Path, *args: Any, **kwargs: Any) -> None:
+        if path.resolve() == venv_path.resolve():
+            raise OSError(16, "Test error")  # ERRNO 16: Device or resource busy
+        else:
+            remove_directory(path)
+
+    m = mocker.patch(
+        "poetry.utils.env.env_manager.remove_directory", side_effect=err_on_rm_venv_only
+    )
+
+    venv = manager.remove(f"{venv_name}-py3.6")
+
+    m.assert_any_call(venv_path)
+
+    assert venv_path == venv.path
+    assert venv_path.exists()
+
+    assert not folder1_path.exists()
+    assert not file1_path.exists()
+    assert not file2_path.exists()
+
+    m.side_effect = remove_directory  # Avoid teardown using `err_on_rm_venv_only`
+
+
+def test_create_venv_tries_to_find_a_compatible_python_executable_using_generic_ones_first(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "^3.6"
+
+    mocked_python_register("2.7.16", make_system=True)
+    mocked_python_register("3.7.16", "python3")
+
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py3.7",
+        executable=Path("/usr/bin/python3"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.7",
+    )
+
+
+def test_create_venv_finds_no_python_executable(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "^999"
+
+    with pytest.raises(NoCompatiblePythonVersionFoundError) as e:
+        manager.create_venv()
+
+    expected_message = (
+        "Poetry was unable to find a compatible version. "
+        "If you have one, you can explicitly use it "
+        'via the "env use" command.'
+    )
+
+    assert str(e.value) == expected_message
+
+
+def test_create_venv_tries_to_find_a_compatible_python_executable_using_specific_ones(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "^3.6"
+
+    mocked_python_register("3.5.3")
+    mocked_python_register("3.9.0")
+
+    mocker.patch(
+        "poetry.utils.env.python.Python.get_system_python",
+        return_value=mocked_python_register("2.7.16", make_system=True),
+    )
+    mocked_python_register("3.5.3")
+    mocked_python_register("3.9.0")
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py3.9",
+        executable=Path("/usr/bin/python3.9"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.9",
+    )
+
+
+def test_create_venv_fails_if_no_compatible_python_version_could_be_found(
+    manager: EnvManager, poetry: Poetry, config: Config, mocker: MockerFixture
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "^4.8"
+
+    mocker.patch(
+        "subprocess.check_output",
+        side_effect=[sys.base_prefix, "/usr/bin/python", "3.9.0"],
+    )
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    with pytest.raises(NoCompatiblePythonVersionFoundError) as e:
+        manager.create_venv()
+
+    expected_message = (
+        "Poetry was unable to find a compatible version. "
+        "If you have one, you can explicitly use it "
+        'via the "env use" command.'
+    )
+
+    assert str(e.value) == expected_message
+    assert m.call_count == 0
+
+
+def test_create_venv_does_not_try_to_find_compatible_versions_with_executable(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "^4.8"
+
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    with pytest.raises(NoCompatiblePythonVersionFoundError) as e:
+        manager.create_venv(python=mocked_python_register("3.8.0"))
+
+    expected_message = (
+        "The specified Python version (3.8.0) is not supported by the project (^4.8).\n"
+        "Please choose a compatible version or loosen the python constraint "
+        "specified in the pyproject.toml file."
+    )
+
+    assert str(e.value) == expected_message
+    assert m.call_count == 0
+
+
+def test_create_venv_uses_patch_version_to_detect_compatibility(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    version = Version.from_parts(*sys.version_info[:3])
+    poetry.package.python_versions = "^" + ".".join(
+        str(c) for c in sys.version_info[:3]
+    )
+
+    assert version.patch is not None
+    python = mocked_python_register(
+        f"{version.major}.{version.minor}.{version.patch + 1}"
+    )
+    mocker.patch(
+        "poetry.utils.env.python.Python.get_system_python",
+        return_value=python,
+    )
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py{version.major}.{version.minor}",
+        executable=python.executable,
+        flags=venv_flags_default,
+        prompt=f"simple-project-py{version.major}.{version.minor}",
+    )
+
+
+def test_create_venv_uses_patch_version_to_detect_compatibility_with_executable(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+    venv_flags_default: dict[str, bool],
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    version = Version.from_parts(*sys.version_info[:3])
+    assert version.minor is not None
+    poetry.package.python_versions = "~3.6.0"
+    venv_name = manager.generate_env_name(
+        "simple-project", str(poetry.file.path.parent)
+    )
+
+    mocked_python_register("3.6.0")
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv(python=mocked_python_register("3.6.0"))
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py3.6",
+        executable=Path("/usr/bin/python3.6"),
+        flags=venv_flags_default,
+        prompt="simple-project-py3.6",
+    )
+
+
+def test_create_venv_fails_if_current_python_version_is_not_supported(
+    manager: EnvManager, poetry: Poetry
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    manager.create_venv()
+
+    current_version = Version.parse(".".join(str(c) for c in sys.version_info[:3]))
+    assert current_version.minor is not None
+    next_version = ".".join(
+        str(c) for c in (current_version.major, current_version.minor + 1, 0)
+    )
+    package_version = "~" + next_version
+    poetry.package.python_versions = package_version
+
+    with pytest.raises(InvalidCurrentPythonVersionError) as e:
+        manager.create_venv()
+
+    expected_message = (
+        f"Current Python version ({current_version}) is not allowed by the project"
+        f' ({package_version}).\nPlease change python executable via the "env use"'
+        " command."
+    )
+
+    assert expected_message == str(e.value)
+
+
+def test_create_venv_project_name_empty_sets_correct_prompt(
+    fixture_dir: FixtureDirGetter,
+    project_factory: ProjectFactory,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = True
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry = project_factory("no", source=fixture_dir("no_name_project"))
+    manager = EnvManager(poetry)
+
+    poetry.package.python_versions = "^3.7"
+    venv_name = manager.generate_env_name(
+        "non-package-mode", str(poetry.file.path.parent)
+    )
+
+    mocked_python_register("2.7.16", make_system=True)
+    mocked_python_register("3.7.1", "python3")
+
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py3.7",
+        executable=Path("/usr/bin/python3"),
+        flags={
+            "always-copy": False,
+            "system-site-packages": False,
+            "no-pip": False,
+        },
+        prompt="non-package-mode-py3.7",
+    )
+
+
+def test_create_venv_accepts_fallback_version_w_nonzero_patchlevel(
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    config_virtualenvs_path: Path,
+    venv_name: str,
+    mocked_python_register: MockedPythonRegister,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    poetry.package.python_versions = "~3.5.1"
+
+    def mock_check_output(cmd: str, *args: Any, **kwargs: Any) -> str:
+        if GET_PYTHON_VERSION_ONELINER in cmd:
+            executable = cmd[0]
+            if "python3.5" in str(executable):
+                return "3.5.12"
+            return "3.7.1"
+
+        if GET_BASE_PREFIX in cmd:
+            return sys.base_prefix
+
+        return "/usr/bin/python3.5"
+
+    mocked_python_register("3.5.12")
+
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called_with(
+        config_virtualenvs_path / f"{venv_name}-py3.5",
+        executable=Path("/usr/bin/python3.5"),
+        flags={
+            "always-copy": False,
+            "system-site-packages": False,
+            "no-pip": False,
+        },
+        prompt="simple-project-py3.5",
+    )
+
+
+@pytest.mark.parametrize("is_inconsistent_entry", [False, True])
+def test_create_venv_does_not_keep_inconsistent_envs_entry(
+    tmp_path: Path,
+    manager: EnvManager,
+    poetry: Poetry,
+    config: Config,
+    mocker: MockerFixture,
+    venv_name: str,
+    is_inconsistent_entry: bool,
+    mocked_python_register: MockedPythonRegister,
+    with_no_active_python: MagicMock,
+) -> None:
+    if "VIRTUAL_ENV" in os.environ:
+        del os.environ["VIRTUAL_ENV"]
+
+    # There is an entry in the envs.toml file but the venv does not exist
+    envs_file = TOMLFile(tmp_path / "envs.toml")
+    doc = tomlkit.document()
+    if is_inconsistent_entry:
+        doc[venv_name] = {"minor": "3.7", "patch": "3.7.0"}
+    doc["other"] = {"minor": "3.7", "patch": "3.7.0"}
+    envs_file.write(doc)
+
+    mocked_python_register("3.7.0")
+
+    config.merge({"virtualenvs": {"path": str(tmp_path)}})
+
+    m = mocker.patch(
+        "poetry.utils.env.EnvManager.build_venv", side_effect=lambda *args, **kwargs: ""
+    )
+
+    manager.create_venv()
+
+    m.assert_called()
+
+    assert envs_file.exists()
+    envs: dict[str, Any] = envs_file.read()
+    assert venv_name not in envs
+    assert envs["other"]["minor"] == "3.7"
+    assert envs["other"]["patch"] == "3.7.0"
+
+
+def test_build_venv_does_not_change_loglevel(
+    tmp_path: Path, manager: EnvManager, caplog: LogCaptureFixture
+) -> None:
+    # see https://github.com/python-poetry/poetry/pull/8760
+    venv_path = tmp_path / "venv"
+    caplog.set_level(logging.DEBUG)
+    manager.build_venv(venv_path)
+    assert logging.root.level == logging.DEBUG
+
+
+@pytest.mark.skipif(sys.platform != "darwin", reason="requires darwin")
+def test_venv_backup_exclusion(tmp_path: Path, manager: EnvManager) -> None:
+    import xattr
+
+    venv_path = tmp_path / "Virtual Env"
+
+    manager.build_venv(venv_path)
+
+    value = (
+        b"bplist00_\x10\x11com.apple.backupd"
+        b"\x08\x00\x00\x00\x00\x00\x00\x01\x01\x00\x00\x00\x00\x00\x00\x00"
+        b"\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x1c"
+    )
+    assert (
+        xattr.getxattr(
+            str(venv_path), "com.apple.metadata:com_apple_backup_excludeItem"
+        )
+        == value
+    )
+
+
+def test_generate_env_name_ignores_case_for_case_insensitive_fs(
+    poetry: Poetry,
+    tmp_path: Path,
+) -> None:
+    venv_name1 = EnvManager.generate_env_name(poetry.package.name, "MyDiR")
+    venv_name2 = EnvManager.generate_env_name(poetry.package.name, "mYdIr")
+    if sys.platform == "win32":
+        assert venv_name1 == venv_name2
+    else:
+        assert venv_name1 != venv_name2
+
+
+def test_generate_env_name_uses_real_path(
+    tmp_path: Path, mocker: MockerFixture
+) -> None:
+    mocker.patch("os.path.realpath", return_value="the_real_dir")
+    venv_name1 = EnvManager.generate_env_name("simple-project", "the_real_dir")
+    venv_name2 = EnvManager.generate_env_name("simple-project", "linked_dir")
+    assert venv_name1 == venv_name2
diff --git b/tests/utils/env/test_env_site_packages.py a/tests/utils/env/test_env_site_packages.py
new file mode 100644
index 0000000..7bf24cc
--- /dev/null
+++ a/tests/utils/env/test_env_site_packages.py
@@ -0,0 +1,49 @@
+from __future__ import annotations
+
+import uuid
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+from poetry.utils.env import SitePackages
+
+
+if TYPE_CHECKING:
+    from pytest_mock import MockerFixture
+
+
+def test_env_site_simple(tmp_path: Path, mocker: MockerFixture) -> None:
+    # emulate permission error when creating directory
+    mocker.patch("pathlib.Path.mkdir", side_effect=OSError())
+    site_packages = SitePackages(Path("/non-existent"), fallbacks=[tmp_path])
+    candidates = site_packages.make_candidates(Path("hello.txt"), writable_only=True)
+    hello = tmp_path / "hello.txt"
+
+    assert len(candidates) == 1
+    assert candidates[0].as_posix() == hello.as_posix()
+
+    content = str(uuid.uuid4())
+    site_packages.write_text(Path("hello.txt"), content, encoding="utf-8")
+
+    assert hello.read_text(encoding="utf-8") == content
+
+    assert not (site_packages.path / "hello.txt").exists()
+
+
+def test_env_site_select_first(tmp_path: Path) -> None:
+    fallback = tmp_path / "fallback"
+    fallback.mkdir(parents=True)
+
+    site_packages = SitePackages(tmp_path, fallbacks=[fallback])
+    candidates = site_packages.make_candidates(Path("hello.txt"), writable_only=True)
+
+    assert len(candidates) == 2
+    assert len(site_packages.find(Path("hello.txt"))) == 0
+
+    content = str(uuid.uuid4())
+    site_packages.write_text(Path("hello.txt"), content, encoding="utf-8")
+
+    assert (site_packages.path / "hello.txt").exists()
+    assert not (fallback / "hello.txt").exists()
+
+    assert len(site_packages.find(Path("hello.txt"))) == 1
diff --git b/tests/utils/env/test_system_env.py a/tests/utils/env/test_system_env.py
new file mode 100644
index 0000000..4e71a2c
--- /dev/null
+++ a/tests/utils/env/test_system_env.py
@@ -0,0 +1,19 @@
+from __future__ import annotations
+
+import sys
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+from poetry.utils.env import SystemEnv
+
+
+if TYPE_CHECKING:
+    from pytest_mock import MockerFixture
+
+
+def test_get_marker_env_untagged_cpython(mocker: MockerFixture) -> None:
+    mocker.patch("platform.python_version", return_value="3.11.9+")
+    env = SystemEnv(Path(sys.prefix))
+    marker_env = env.get_marker_env()
+    assert marker_env["python_full_version"] == "3.11.9"
diff --git b/tests/utils/test_authenticator.py a/tests/utils/test_authenticator.py
new file mode 100644
index 0000000..7644af2
--- /dev/null
+++ a/tests/utils/test_authenticator.py
@@ -0,0 +1,725 @@
+from __future__ import annotations
+
+import base64
+import logging
+import re
+import uuid
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import httpretty
+import pytest
+import requests
+
+from cleo.io.null_io import NullIO
+from keyring.credentials import SimpleCredential
+
+from poetry.console.exceptions import PoetryRuntimeError
+from poetry.utils.authenticator import Authenticator
+from poetry.utils.authenticator import RepositoryCertificateConfig
+from poetry.utils.password_manager import PoetryKeyring
+
+
+if TYPE_CHECKING:
+    from pytest import LogCaptureFixture
+    from pytest import MonkeyPatch
+    from pytest_mock import MockerFixture
+
+    from tests.conftest import Config
+    from tests.conftest import DummyBackend
+
+
+@pytest.fixture()
+def mock_remote(http: type[httpretty.httpretty]) -> None:
+    http.register_uri(
+        http.GET,
+        re.compile("^https?://foo.bar/(.+?)$"),
+    )
+
+
+@pytest.fixture()
+def repo() -> dict[str, dict[str, str]]:
+    return {"foo": {"url": "https://foo.bar/simple/"}}
+
+
+@pytest.fixture
+def mock_config(config: Config, repo: dict[str, dict[str, str]]) -> Config:
+    config.merge(
+        {
+            "repositories": repo,
+            "http-basic": {"foo": {"username": "bar", "password": "baz"}},
+        }
+    )
+
+    return config
+
+
+def test_authenticator_uses_url_provided_credentials(
+    mock_config: Config, mock_remote: None, http: type[httpretty.httpretty]
+) -> None:
+    authenticator = Authenticator(mock_config, NullIO())
+    authenticator.request("get", "https://foo001:bar002@foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"foo001:bar002").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_uses_credentials_from_config_if_not_provided(
+    mock_config: Config, mock_remote: None, http: type[httpretty.httpretty]
+) -> None:
+    authenticator = Authenticator(mock_config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"bar:baz").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_uses_username_only_credentials(
+    mock_config: Config,
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+) -> None:
+    authenticator = Authenticator(mock_config, NullIO())
+    authenticator.request("get", "https://foo001@foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"foo001:").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_ignores_locked_keyring(
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_locked_keyring: None,
+    caplog: LogCaptureFixture,
+    mocker: MockerFixture,
+) -> None:
+    caplog.set_level(logging.DEBUG, logger="poetry.utils.password_manager")
+    spy_get_credential = mocker.spy(PoetryKeyring, "get_credential")
+    spy_get_password = mocker.spy(PoetryKeyring, "get_password")
+    authenticator = Authenticator()
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    assert request.headers["Authorization"] is None
+    assert "Accessing keyring failed during availability check" in caplog.messages
+    assert "Using keyring backend 'conftest LockedBackend'" in caplog.messages
+    assert spy_get_credential.call_count == spy_get_password.call_count == 0
+
+
+def test_authenticator_ignores_failing_keyring(
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_erroneous_keyring: None,
+    caplog: LogCaptureFixture,
+    mocker: MockerFixture,
+) -> None:
+    caplog.set_level(logging.DEBUG, logger="poetry.utils.password_manager")
+    spy_get_credential = mocker.spy(PoetryKeyring, "get_credential")
+    spy_get_password = mocker.spy(PoetryKeyring, "get_password")
+    authenticator = Authenticator()
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    assert request.headers["Authorization"] is None
+
+    assert "Using keyring backend 'conftest ErroneousBackend'" in caplog.messages
+    assert "Accessing keyring failed during availability check" in caplog.messages
+    assert spy_get_credential.call_count == spy_get_password.call_count == 0
+
+
+def test_authenticator_uses_password_only_credentials(
+    mock_config: Config, mock_remote: None, http: type[httpretty.httpretty]
+) -> None:
+    authenticator = Authenticator(mock_config, NullIO())
+    authenticator.request("get", "https://:bar002@foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b":bar002").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_uses_empty_strings_as_default_password(
+    config: Config,
+    mock_remote: None,
+    repo: dict[str, dict[str, str]],
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+) -> None:
+    config.merge(
+        {
+            "repositories": repo,
+            "http-basic": {"foo": {"username": "bar"}},
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"bar:").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_does_not_ignore_empty_strings_as_default_username(
+    config: Config,
+    mock_remote: None,
+    repo: dict[str, dict[str, str]],
+    http: type[httpretty.httpretty],
+) -> None:
+    config.merge(
+        {
+            "repositories": repo,
+            "http-basic": {"foo": {"username": None, "password": "bar"}},
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b":bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_falls_back_to_keyring_url(
+    config: Config,
+    mock_remote: None,
+    repo: dict[str, dict[str, str]],
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    config.merge(
+        {
+            "repositories": repo,
+        }
+    )
+
+    dummy_keyring.set_default_service_credential(
+        "https://foo.bar/simple/",
+        SimpleCredential("foo", "bar"),
+    )
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"foo:bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_falls_back_to_keyring_netloc(
+    config: Config,
+    mock_remote: None,
+    repo: dict[str, dict[str, str]],
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+    poetry_keyring: PoetryKeyring,
+) -> None:
+    config.merge(
+        {
+            "repositories": repo,
+        }
+    )
+
+    dummy_keyring.set_default_service_credential(
+        "foo.bar",
+        SimpleCredential("foo", "bar"),
+    )
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"foo:bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+@pytest.mark.filterwarnings("ignore::pytest.PytestUnhandledThreadExceptionWarning")
+def test_authenticator_request_retries_on_exception(
+    mocker: MockerFixture, config: Config, http: type[httpretty.httpretty]
+) -> None:
+    sleep = mocker.patch("time.sleep")
+    sdist_uri = f"https://foo.bar/files/{uuid.uuid4()!s}/foo-0.1.0.tar.gz"
+    content = str(uuid.uuid4())
+    seen: list[str] = []
+
+    def callback(
+        request: requests.Request, uri: str, response_headers: dict[str, str]
+    ) -> list[int | dict[str, str] | str]:
+        if seen.count(uri) < 2:
+            seen.append(uri)
+            raise requests.exceptions.ConnectionError("Disconnected")
+        return [200, response_headers, content]
+
+    http.register_uri(httpretty.GET, sdist_uri, body=callback)
+
+    authenticator = Authenticator(config, NullIO())
+    response = authenticator.request("get", sdist_uri)
+    assert response.text == content
+    assert sleep.call_count == 2
+
+
+@pytest.mark.filterwarnings("ignore::pytest.PytestUnhandledThreadExceptionWarning")
+def test_authenticator_request_raises_exception_when_attempts_exhausted(
+    mocker: MockerFixture, config: Config, http: type[httpretty.httpretty]
+) -> None:
+    sleep = mocker.patch("time.sleep")
+    sdist_uri = f"https://foo.bar/files/{uuid.uuid4()!s}/foo-0.1.0.tar.gz"
+
+    def callback(*_: Any, **___: Any) -> None:
+        raise requests.exceptions.ConnectionError(str(uuid.uuid4()))
+
+    http.register_uri(httpretty.GET, sdist_uri, body=callback)
+    authenticator = Authenticator(config, NullIO())
+
+    with pytest.raises(PoetryRuntimeError) as e:
+        authenticator.request("get", sdist_uri)
+
+    assert str(e.value) == "All attempts to connect to foo.bar failed."
+    assert sleep.call_count == 5
+
+
+def test_authenticator_request_respects_retry_header(
+    mocker: MockerFixture,
+    config: Config,
+    http: type[httpretty.httpretty],
+) -> None:
+    sleep = mocker.patch("time.sleep")
+    sdist_uri = f"https://foo.bar/files/{uuid.uuid4()!s}/foo-0.1.0.tar.gz"
+    content = str(uuid.uuid4())
+    seen: list[str] = []
+
+    def callback(
+        request: requests.Request, uri: str, response_headers: dict[str, str]
+    ) -> list[int | dict[str, str] | str]:
+        if not seen.count(uri):
+            seen.append(uri)
+            return [429, {"Retry-After": "42"}, "Retry later"]
+
+        return [200, response_headers, content]
+
+    http.register_uri(httpretty.GET, sdist_uri, body=callback)
+    authenticator = Authenticator(config, NullIO())
+
+    response = authenticator.request("get", sdist_uri)
+    assert sleep.call_args[0] == (42.0,)
+    assert response.text == content
+
+
+@pytest.mark.parametrize(
+    ["status", "attempts"],
+    [
+        (400, 0),
+        (401, 0),
+        (403, 0),
+        (404, 0),
+        (429, 5),
+        (500, 5),
+        (501, 5),
+        (502, 5),
+        (503, 5),
+        (504, 5),
+    ],
+)
+def test_authenticator_request_retries_on_status_code(
+    mocker: MockerFixture,
+    config: Config,
+    http: type[httpretty.httpretty],
+    status: int,
+    attempts: int,
+) -> None:
+    sleep = mocker.patch("time.sleep")
+    sdist_uri = f"https://foo.bar/files/{uuid.uuid4()!s}/foo-0.1.0.tar.gz"
+    content = str(uuid.uuid4())
+
+    def callback(
+        request: requests.Request, uri: str, response_headers: dict[str, str]
+    ) -> list[int | dict[str, str] | str]:
+        return [status, response_headers, content]
+
+    http.register_uri(httpretty.GET, sdist_uri, body=callback)
+    authenticator = Authenticator(config, NullIO())
+
+    with pytest.raises(requests.exceptions.HTTPError) as excinfo:
+        authenticator.request("get", sdist_uri)
+
+    assert excinfo.value.response is not None
+    assert excinfo.value.response.status_code == status
+    assert excinfo.value.response.text == content
+
+    assert sleep.call_count == attempts
+
+
+def test_authenticator_uses_env_provided_credentials(
+    config: Config,
+    repo: dict[str, dict[str, str]],
+    environ: None,
+    mock_remote: type[httpretty.httpretty],
+    http: type[httpretty.httpretty],
+    monkeypatch: MonkeyPatch,
+) -> None:
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_USERNAME", "bar")
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_PASSWORD", "baz")
+
+    config.merge({"repositories": repo})
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/files/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"bar:baz").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+@pytest.mark.parametrize(
+    "cert,client_cert",
+    [
+        (None, None),
+        (None, "path/to/provided/client-cert"),
+        ("/path/to/provided/cert", None),
+        ("/path/to/provided/cert", "path/to/provided/client-cert"),
+    ],
+)
+def test_authenticator_uses_certs_from_config_if_not_provided(
+    config: Config,
+    mock_remote: type[httpretty.httpretty],
+    mock_config: Config,
+    http: type[httpretty.httpretty],
+    mocker: MockerFixture,
+    cert: str | None,
+    client_cert: str | None,
+) -> None:
+    configured_cert = "/path/to/cert"
+    configured_client_cert = "/path/to/client-cert"
+
+    mock_config.merge(
+        {
+            "certificates": {
+                "foo": {"cert": configured_cert, "client-cert": configured_client_cert}
+            },
+        }
+    )
+
+    authenticator = Authenticator(mock_config, NullIO())
+    url = "https://foo.bar/files/foo-0.1.0.tar.gz"
+    session = authenticator.get_session(url)
+    session_send = mocker.patch.object(session, "send")
+    authenticator.request(
+        "get",
+        url,
+        verify=cert,
+        cert=client_cert,
+    )
+    kwargs = session_send.call_args[1]
+
+    assert Path(kwargs["verify"]) == Path(cert or configured_cert)
+    assert Path(kwargs["cert"]) == Path(client_cert or configured_client_cert)
+
+
+def test_authenticator_uses_credentials_from_config_matched_by_url_path(
+    config: Config, mock_remote: None, http: type[httpretty.httpretty]
+) -> None:
+    config.merge(
+        {
+            "repositories": {
+                "foo-alpha": {"url": "https://foo.bar/alpha/files/simple/"},
+                "foo-beta": {"url": "https://foo.bar/beta/files/simple/"},
+            },
+            "http-basic": {
+                "foo-alpha": {"username": "bar", "password": "alpha"},
+                "foo-beta": {"username": "baz", "password": "beta"},
+            },
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/alpha/files/simple/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"bar:alpha").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+    # Make request on second repository with the same netloc but different credentials
+    authenticator.request("get", "https://foo.bar/beta/files/simple/foo-0.1.0.tar.gz")
+
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"baz:beta").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_uses_credentials_from_config_with_at_sign_in_path(
+    config: Config, mock_remote: None, http: type[httpretty.httpretty]
+) -> None:
+    config.merge(
+        {
+            "repositories": {
+                "foo": {"url": "https://foo.bar/beta/files/simple/"},
+            },
+            "http-basic": {
+                "foo": {"username": "bar", "password": "baz"},
+            },
+        }
+    )
+    authenticator = Authenticator(config, NullIO())
+    authenticator.request("get", "https://foo.bar/beta/files/simple/f@@-0.1.0.tar.gz")
+
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"bar:baz").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_falls_back_to_keyring_url_matched_by_path(
+    config: Config,
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    config.merge(
+        {
+            "repositories": {
+                "foo-alpha": {"url": "https://foo.bar/alpha/files/simple/"},
+                "foo-beta": {"url": "https://foo.bar/beta/files/simple/"},
+            }
+        }
+    )
+
+    dummy_keyring.set_default_service_credential(
+        "https://foo.bar/alpha/files/simple/",
+        SimpleCredential("foo", "bar"),
+    )
+    dummy_keyring.set_default_service_credential(
+        "https://foo.bar/beta/files/simple/",
+        SimpleCredential("foo", "baz"),
+    )
+
+    authenticator = Authenticator(config, NullIO())
+
+    authenticator.request("get", "https://foo.bar/alpha/files/simple/foo-0.1.0.tar.gz")
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"foo:bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+    authenticator.request("get", "https://foo.bar/beta/files/simple/foo-0.1.0.tar.gz")
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"foo:baz").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_uses_env_provided_credentials_matched_by_url_path(
+    config: Config,
+    environ: None,
+    mock_remote: type[httpretty.httpretty],
+    http: type[httpretty.httpretty],
+    monkeypatch: MonkeyPatch,
+) -> None:
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_ALPHA_USERNAME", "bar")
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_ALPHA_PASSWORD", "alpha")
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_BETA_USERNAME", "baz")
+    monkeypatch.setenv("POETRY_HTTP_BASIC_FOO_BETA_PASSWORD", "beta")
+
+    config.merge(
+        {
+            "repositories": {
+                "foo-alpha": {"url": "https://foo.bar/alpha/files/simple/"},
+                "foo-beta": {"url": "https://foo.bar/beta/files/simple/"},
+            }
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+
+    authenticator.request("get", "https://foo.bar/alpha/files/simple/foo-0.1.0.tar.gz")
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"bar:alpha").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+    authenticator.request("get", "https://foo.bar/beta/files/simple/foo-0.1.0.tar.gz")
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"baz:beta").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_azure_feed_guid_credentials(
+    config: Config,
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    config.merge(
+        {
+            "repositories": {
+                "alpha": {
+                    "url": "https://foo.bar/org-alpha/_packaging/feed/pypi/simple/"
+                },
+                "beta": {
+                    "url": "https://foo.bar/org-beta/_packaging/feed/pypi/simple/"
+                },
+            },
+            "http-basic": {
+                "alpha": {"username": "foo", "password": "bar"},
+                "beta": {"username": "baz", "password": "qux"},
+            },
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+
+    authenticator.request(
+        "get",
+        "https://foo.bar/org-alpha/_packaging/GUID/pypi/simple/a/1.0.0/a-1.0.0.whl",
+    )
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"foo:bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+    authenticator.request(
+        "get",
+        "https://foo.bar/org-beta/_packaging/GUID/pypi/simple/b/1.0.0/a-1.0.0.whl",
+    )
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"baz:qux").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_add_repository(
+    config: Config,
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    config.merge(
+        {
+            "http-basic": {
+                "source": {"username": "foo", "password": "bar"},
+            },
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+
+    authenticator.request(
+        "get",
+        "https://foo.bar/simple/a/1.0.0/a-1.0.0.whl",
+    )
+    request = http.last_request()
+    assert "Authorization" not in request.headers
+
+    authenticator.add_repository("source", "https://foo.bar/simple/")
+
+    authenticator.request(
+        "get",
+        "https://foo.bar/simple/a/1.0.0/a-1.0.0.whl",
+    )
+    request = http.last_request()
+
+    basic_auth = base64.b64encode(b"foo:bar").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_authenticator_git_repositories(
+    config: Config,
+    mock_remote: None,
+    http: type[httpretty.httpretty],
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    config.merge(
+        {
+            "repositories": {
+                "one": {"url": "https://foo.bar/org/one.git"},
+                "two": {"url": "https://foo.bar/org/two.git"},
+            },
+            "http-basic": {
+                "one": {"username": "foo", "password": "bar"},
+                "two": {"username": "baz", "password": "qux"},
+            },
+        }
+    )
+
+    authenticator = Authenticator(config, NullIO())
+
+    one = authenticator.get_credentials_for_git_url("https://foo.bar/org/one.git")
+    assert one.username == "foo"
+    assert one.password == "bar"
+
+    two = authenticator.get_credentials_for_git_url("https://foo.bar/org/two.git")
+    assert two.username == "baz"
+    assert two.password == "qux"
+
+    two_ssh = authenticator.get_credentials_for_git_url("ssh://git@foo.bar/org/two.git")
+    assert not two_ssh.username
+    assert not two_ssh.password
+
+    three = authenticator.get_credentials_for_git_url("https://foo.bar/org/three.git")
+    assert not three.username
+    assert not three.password
+
+
+@pytest.mark.parametrize(
+    ("ca_cert", "client_cert", "result"),
+    [
+        (None, None, RepositoryCertificateConfig()),
+        (
+            "path/to/ca.pem",
+            "path/to/client.pem",
+            RepositoryCertificateConfig(
+                Path("path/to/ca.pem"), Path("path/to/client.pem")
+            ),
+        ),
+        (
+            None,
+            "path/to/client.pem",
+            RepositoryCertificateConfig(None, Path("path/to/client.pem")),
+        ),
+        (
+            "path/to/ca.pem",
+            None,
+            RepositoryCertificateConfig(Path("path/to/ca.pem"), None),
+        ),
+        (True, None, RepositoryCertificateConfig()),
+        (False, None, RepositoryCertificateConfig(verify=False)),
+        (
+            False,
+            "path/to/client.pem",
+            RepositoryCertificateConfig(None, Path("path/to/client.pem"), verify=False),
+        ),
+    ],
+)
+def test_repository_certificate_configuration_create(
+    ca_cert: str | bool | None,
+    client_cert: str | None,
+    result: RepositoryCertificateConfig,
+    config: Config,
+) -> None:
+    cert_config = {}
+
+    if ca_cert is not None:
+        cert_config["cert"] = ca_cert
+
+    if client_cert is not None:
+        cert_config["client-cert"] = client_cert
+
+    config.merge({"certificates": {"foo": cert_config}})
+
+    assert RepositoryCertificateConfig.create("foo", config) == result
diff --git b/tests/utils/test_cache.py a/tests/utils/test_cache.py
new file mode 100644
index 0000000..09c5c98
--- /dev/null
+++ a/tests/utils/test_cache.py
@@ -0,0 +1,369 @@
+from __future__ import annotations
+
+import concurrent.futures
+import shutil
+import traceback
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import TypeVar
+
+import pytest
+
+from packaging.tags import Tag
+from poetry.core.packages.utils.link import Link
+
+from poetry.utils.cache import ArtifactCache
+from poetry.utils.cache import FileCache
+from poetry.utils.env import MockEnv
+
+
+if TYPE_CHECKING:
+    from typing import Any
+
+    from pytest_mock import MockerFixture
+
+    from tests.conftest import Config
+    from tests.types import FixtureDirGetter
+
+
+T = TypeVar("T")
+
+
+@pytest.fixture
+def repository_cache_dir(config: Config) -> Path:
+    return config.repository_cache_directory
+
+
+@pytest.fixture
+def poetry_file_cache(repository_cache_dir: Path) -> FileCache[Any]:
+    return FileCache(repository_cache_dir / "cache")
+
+
+def test_cache_validates(repository_cache_dir: Path) -> None:
+    with pytest.raises(ValueError) as e:
+        FileCache(repository_cache_dir / "cache", hash_type="unknown")
+    assert str(e.value) == "FileCache.hash_type is unknown value: 'unknown'."
+
+
+def test_cache_get_put_has(repository_cache_dir: Path) -> None:
+    cache: FileCache[Any] = FileCache(repository_cache_dir / "cache")
+    cache.put("key1", "value")
+    cache.put("key2", {"a": ["json-encoded", "value"]})
+
+    assert cache.get("key1") == "value"
+    assert cache.get("key2") == {"a": ["json-encoded", "value"]}
+    assert cache.has("key1")
+    assert cache.has("key2")
+    assert not cache.has("key3")
+
+
+def test_cache_forget(repository_cache_dir: Path) -> None:
+    cache: FileCache[Any] = FileCache(repository_cache_dir / "cache")
+    cache.put("key1", "value")
+    cache.put("key2", "value")
+
+    assert cache.has("key1")
+    assert cache.has("key2")
+
+    cache.forget("key1")
+
+    assert not cache.has("key1")
+    assert cache.has("key2")
+
+
+def test_cache_flush(repository_cache_dir: Path) -> None:
+    cache: FileCache[Any] = FileCache(repository_cache_dir / "cache")
+    cache.put("key1", "value")
+    cache.put("key2", "value")
+
+    assert cache.has("key1")
+    assert cache.has("key2")
+
+    cache.flush()
+
+    assert not cache.has("key1")
+    assert not cache.has("key2")
+
+
+def test_cache_remember(repository_cache_dir: Path, mocker: MockerFixture) -> None:
+    cache: FileCache[Any] = FileCache(repository_cache_dir / "cache")
+
+    method = mocker.Mock(return_value="value2")
+    cache.put("key1", "value1")
+    assert cache.remember("key1", method) == "value1"
+    method.assert_not_called()
+
+    assert cache.remember("key2", method) == "value2"
+    method.assert_called()
+
+
+def test_cache_get_limited_minutes(
+    repository_cache_dir: Path, mocker: MockerFixture
+) -> None:
+    cache: FileCache[Any] = FileCache(repository_cache_dir / "cache")
+
+    start_time = 1111111111
+
+    mocker.patch("time.time", return_value=start_time)
+    cache.put("key1", "value", minutes=5)
+    cache.put("key2", "value", minutes=5)
+
+    assert cache.get("key1") is not None
+    assert cache.get("key2") is not None
+
+    mocker.patch("time.time", return_value=start_time + 5 * 60 + 1)
+    # check to make sure that the cache deletes for has() and get()
+    assert not cache.has("key1")
+    assert cache.get("key2") is None
+
+
+def test_missing_cache_file(poetry_file_cache: FileCache[Any]) -> None:
+    poetry_file_cache.put("key1", "value")
+
+    key1_path = (
+        poetry_file_cache.path
+        / "81/74/09/96/87/a2/66/21/8174099687a26621f4e2cdd7cc03b3dacedb3fb962255b1aafd033cabe831530"
+    )
+    assert key1_path.exists()
+    key1_path.unlink()  # corrupt cache by removing a key file
+
+    assert poetry_file_cache.get("key1") is None
+
+
+def test_missing_cache_path(poetry_file_cache: FileCache[Any]) -> None:
+    poetry_file_cache.put("key1", "value")
+
+    key1_partial_path = poetry_file_cache.path / "81/74/09/96/87/a2/"
+    assert key1_partial_path.exists()
+    shutil.rmtree(
+        key1_partial_path
+    )  # corrupt cache by removing a subdirectory containing a key file
+
+    assert poetry_file_cache.get("key1") is None
+
+
+@pytest.mark.parametrize(
+    "corrupt_payload",
+    [
+        "",  # empty file
+        b"\x00",  # null
+        "99999999",  # truncated file
+        '999999a999"value"',  # corrupt lifetime
+        b'9999999999"va\xd8\x00"',  # invalid unicode
+        "fil3systemFa!led",  # garbage file
+    ],
+)
+def test_detect_corrupted_cache_key_file(
+    corrupt_payload: str | bytes, poetry_file_cache: FileCache[Any]
+) -> None:
+    poetry_file_cache.put("key1", "value")
+
+    key1_path = (
+        poetry_file_cache.path
+        / "81/74/09/96/87/a2/66/21/8174099687a26621f4e2cdd7cc03b3dacedb3fb962255b1aafd033cabe831530"
+    )
+    assert key1_path.exists()
+
+    # original content: 9999999999"value"
+
+    if isinstance(corrupt_payload, str):
+        with open(key1_path, "w", encoding="utf-8") as f:
+            f.write(corrupt_payload)  # write corrupt data
+    else:
+        with open(key1_path, "wb") as f:
+            f.write(corrupt_payload)  # write corrupt data
+
+    assert poetry_file_cache.get("key1") is None
+
+
+def test_get_cache_directory_for_link(tmp_path: Path) -> None:
+    cache = ArtifactCache(cache_dir=tmp_path)
+    directory = cache.get_cache_directory_for_link(
+        Link("https://files.pythonhosted.org/poetry-1.1.0.tar.gz")
+    )
+
+    expected = Path(
+        f"{tmp_path.as_posix()}/41/9c/6e/"
+        "ef83f08fcf4dac7cd78d843e7974d601a19c90e4bb90bb76b4a7a61548"
+    )
+
+    assert directory == expected
+
+
+@pytest.mark.parametrize("subdirectory", [None, "subdir"])
+def test_get_cache_directory_for_git(tmp_path: Path, subdirectory: str | None) -> None:
+    cache = ArtifactCache(cache_dir=tmp_path)
+    directory = cache.get_cache_directory_for_git(
+        url="https://github.com/demo/demo.git", ref="123456", subdirectory=subdirectory
+    )
+
+    if subdirectory:
+        expected = Path(
+            f"{tmp_path.as_posix()}/53/08/33/"
+            "7851e5806669aa15ab0c555b13bd5523978057323c6a23a9cee18ec51c"
+        )
+    else:
+        expected = Path(
+            f"{tmp_path.as_posix()}/61/14/30/"
+            "7c57f8fd71e4eee40b18893b9b586cba45177f15e300f4fb8b14ccc933"
+        )
+
+    assert directory == expected
+
+
+def test_get_cached_archives(fixture_dir: FixtureDirGetter) -> None:
+    distributions = fixture_dir("distributions")
+    cache = ArtifactCache(cache_dir=Path())
+
+    archives = cache._get_cached_archives(distributions)
+
+    assert archives
+    assert set(archives) == set(distributions.glob("*.whl")) | set(
+        distributions.glob("*.tar.gz")
+    )
+
+
+@pytest.mark.parametrize(
+    ("link", "strict", "available_packages"),
+    [
+        (
+            "https://files.pythonhosted.org/demo-0.1.0.tar.gz",
+            True,
+            [
+                Path("/cache/demo-0.1.0-py2.py3-none-any"),
+                Path("/cache/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl"),
+                Path("/cache/demo-0.1.0-cp37-cp37-macosx_10_15_x86_64.whl"),
+            ],
+        ),
+        (
+            "https://example.com/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            False,
+            [],
+        ),
+    ],
+)
+def test_get_not_found_cached_archive_for_link(
+    mocker: MockerFixture,
+    link: str,
+    strict: bool,
+    available_packages: list[Path],
+) -> None:
+    env = MockEnv(
+        version_info=(3, 8, 3),
+        marker_env={"interpreter_name": "cpython", "interpreter_version": "3.8.3"},
+        supported_tags=[
+            Tag("cp38", "cp38", "macosx_10_15_x86_64"),
+            Tag("py3", "none", "any"),
+        ],
+    )
+    cache = ArtifactCache(cache_dir=Path())
+
+    mocker.patch.object(
+        cache,
+        "_get_cached_archives",
+        return_value=available_packages,
+    )
+
+    archive = cache.get_cached_archive_for_link(Link(link), strict=strict, env=env)
+
+    assert archive is None
+
+
+@pytest.mark.parametrize(
+    ("link", "cached", "strict"),
+    [
+        (
+            "https://files.pythonhosted.org/demo-0.1.0.tar.gz",
+            "/cache/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            False,
+        ),
+        (
+            "https://example.com/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            "/cache/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            False,
+        ),
+        (
+            "https://files.pythonhosted.org/demo-0.1.0.tar.gz",
+            "/cache/demo-0.1.0.tar.gz",
+            True,
+        ),
+        (
+            "https://example.com/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            "/cache/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl",
+            True,
+        ),
+    ],
+)
+def test_get_found_cached_archive_for_link(
+    mocker: MockerFixture,
+    link: str,
+    cached: str,
+    strict: bool,
+) -> None:
+    env = MockEnv(
+        version_info=(3, 8, 3),
+        marker_env={"interpreter_name": "cpython", "interpreter_version": "3.8.3"},
+        supported_tags=[
+            Tag("cp38", "cp38", "macosx_10_15_x86_64"),
+            Tag("py3", "none", "any"),
+        ],
+    )
+    cache = ArtifactCache(cache_dir=Path())
+
+    mocker.patch.object(
+        cache,
+        "_get_cached_archives",
+        return_value=[
+            Path("/cache/demo-0.1.0-py2.py3-none-any"),
+            Path("/cache/demo-0.1.0.tar.gz"),
+            Path("/cache/demo-0.1.0-cp38-cp38-macosx_10_15_x86_64.whl"),
+            Path("/cache/demo-0.1.0-cp37-cp37-macosx_10_15_x86_64.whl"),
+        ],
+    )
+
+    archive = cache.get_cached_archive_for_link(Link(link), strict=strict, env=env)
+
+    assert Path(cached) == archive
+
+
+def test_get_cached_archive_for_link_no_race_condition(
+    tmp_path: Path, mocker: MockerFixture
+) -> None:
+    cache = ArtifactCache(cache_dir=tmp_path)
+    link = Link("https://files.pythonhosted.org/demo-0.1.0.tar.gz")
+
+    def replace_file(_: str, dest: Path) -> None:
+        dest.unlink(missing_ok=True)
+        # write some data (so it takes a while) to provoke possible race conditions
+        dest.write_text("a" * 2**20, encoding="utf-8")
+
+    download_mock = mocker.Mock(side_effect=replace_file)
+
+    def get_archive(link: Link) -> Path:
+        path: Path = cache.get_cached_archive_for_link(
+            link, strict=True, download_func=download_mock
+        )
+        return path
+
+    with concurrent.futures.ThreadPoolExecutor() as executor:
+        tasks = []
+        for _ in range(4):
+            tasks.append(executor.submit(get_archive, link))
+
+        concurrent.futures.wait(tasks)
+        results = set()
+        for task in tasks:
+            try:
+                results.add(task.result())
+            except Exception:
+                pytest.fail(traceback.format_exc())
+        assert results == {cache.get_cache_directory_for_link(link) / link.filename}
+        download_mock.assert_called_once()
+
+
+def test_get_cached_archive_for_git() -> None:
+    """Smoke test that checks that no assertion is raised."""
+    cache = ArtifactCache(cache_dir=Path())
+    archive = cache.get_cached_archive_for_git("url", "ref", "subdirectory", MockEnv())
+    assert archive is None
diff --git b/tests/utils/test_dependency_specification.py a/tests/utils/test_dependency_specification.py
new file mode 100644
index 0000000..6e13423
--- /dev/null
+++ a/tests/utils/test_dependency_specification.py
@@ -0,0 +1,192 @@
+from __future__ import annotations
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from deepdiff.diff import DeepDiff
+
+from poetry.inspection.info import PackageInfo
+from poetry.utils.dependency_specification import RequirementsParser
+
+
+if TYPE_CHECKING:
+    from collections.abc import Collection
+
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.cache import ArtifactCache
+    from poetry.utils.dependency_specification import DependencySpec
+
+
+@pytest.mark.parametrize(
+    ("requirement", "expected_variants"),
+    [
+        (
+            "git+http://github.com/demo/demo.git",
+            ({"git": "http://github.com/demo/demo.git", "name": "demo"},),
+        ),
+        (
+            "git+https://github.com/demo/demo.git",
+            ({"git": "https://github.com/demo/demo.git", "name": "demo"},),
+        ),
+        (
+            "git+ssh://github.com/demo/demo.git",
+            ({"git": "ssh://github.com/demo/demo.git", "name": "demo"},),
+        ),
+        (
+            "git+https://github.com/demo/demo.git#main",
+            (
+                {
+                    "git": "https://github.com/demo/demo.git",
+                    "name": "demo",
+                    "rev": "main",
+                },
+            ),
+        ),
+        (
+            "git+https://github.com/demo/demo.git@main",
+            (
+                {
+                    "git": "https://github.com/demo/demo.git",
+                    "name": "demo",
+                    "rev": "main",
+                },
+            ),
+        ),
+        (
+            "git+https://github.com/demo/subdirectories.git@main#subdirectory=two",
+            (
+                {
+                    "git": "https://github.com/demo/subdirectories.git",
+                    "name": "two",
+                    "rev": "main",
+                    "subdirectory": "two",
+                },
+            ),
+        ),
+        ("demo", ({"name": "demo"},)),
+        ("demo@1.0.0", ({"name": "demo", "version": "1.0.0"},)),
+        ("demo@^1.0.0", ({"name": "demo", "version": "^1.0.0"},)),
+        ("demo@==1.0.0", ({"name": "demo", "version": "==1.0.0"},)),
+        ("demo@!=1.0.0", ({"name": "demo", "version": "!=1.0.0"},)),
+        ("demo@~1.0.0", ({"name": "demo", "version": "~1.0.0"},)),
+        (
+            "demo[a,b]@1.0.0",
+            ({"name": "demo", "version": "1.0.0", "extras": ["a", "b"]},),
+        ),
+        ("demo[a,b]", ({"name": "demo", "extras": ["a", "b"]},)),
+        ("../demo", ({"name": "demo", "path": "../demo"},)),
+        ("../demo/demo.whl", ({"name": "demo", "path": "../demo/demo.whl"},)),
+        (
+            "https://files.pythonhosted.org/distributions/demo-0.1.0.tar.gz",
+            (
+                {
+                    "name": "demo",
+                    "url": "https://files.pythonhosted.org/distributions/demo-0.1.0.tar.gz",
+                },
+            ),
+        ),
+        # PEP 508 inputs
+        (
+            "poetry-core (>=1.0.7,<1.1.0)",
+            ({"name": "poetry-core", "version": ">=1.0.7,<1.1.0"},),
+        ),
+        (
+            'requests [security,tests] >= 2.8.1, == 2.8.* ; python_version < "2.7"',
+            (  # allow several equivalent versions to make test more robust
+                {
+                    "name": "requests",
+                    "markers": 'python_version < "2.7"',
+                    "version": ">=2.8.1,<2.9",
+                    "extras": ["security", "tests"],
+                },
+                {
+                    "name": "requests",
+                    "markers": 'python_version < "2.7"',
+                    "version": ">=2.8.1,<2.9.0",
+                    "extras": ["security", "tests"],
+                },
+                {
+                    "name": "requests",
+                    "markers": 'python_version < "2.7"',
+                    "version": ">=2.8.1,<2.9.dev0",
+                    "extras": ["security", "tests"],
+                },
+                {
+                    "name": "requests",
+                    "markers": 'python_version < "2.7"',
+                    "version": ">=2.8.1,<2.9.0.dev0",
+                    "extras": ["security", "tests"],
+                },
+                {
+                    "name": "requests",
+                    "markers": 'python_version < "2.7"',
+                    "version": ">=2.8.1,==2.8.*",
+                    "extras": ["security", "tests"],
+                },
+            ),
+        ),
+        ("name (>=3,<4)", ({"name": "name", "version": ">=3,<4"},)),
+        (
+            "name@http://foo.com",
+            ({"name": "name", "url": "http://foo.com"},),
+        ),
+        (
+            "name [fred,bar] @ http://foo.com ; python_version=='2.7'",
+            (
+                {
+                    "name": "name",
+                    "markers": 'python_version == "2.7"',
+                    "url": "http://foo.com",
+                    "extras": ["fred", "bar"],
+                },
+            ),
+        ),
+        (
+            (
+                'cachecontrol[filecache] (>=0.12.9,<0.13.0); python_version >= "3.6"'
+                ' and python_version < "4.0"'
+            ),
+            (
+                {
+                    "version": ">=0.12.9,<0.13.0",
+                    "markers": 'python_version >= "3.6" and python_version < "4.0"',
+                    "extras": ["filecache"],
+                    "name": "cachecontrol",
+                },
+            ),
+        ),
+    ],
+)
+def test_parse_dependency_specification(
+    requirement: str,
+    expected_variants: Collection[DependencySpec],
+    mocker: MockerFixture,
+    artifact_cache: ArtifactCache,
+) -> None:
+    original = Path.exists
+
+    # Parsing file and path dependencies reads metadata from the file or path in
+    # question: for these tests we mock that out.
+    def _mock(self: Path) -> bool:
+        if "/" in requirement and self == Path.cwd().joinpath(requirement):
+            return True
+        return original(self)
+
+    mocker.patch("pathlib.Path.exists", _mock)
+
+    mocker.patch(
+        "poetry.inspection.info.get_pep517_metadata",
+        return_value=PackageInfo(name="demo", version="0.1.2"),
+    )
+
+    assert any(
+        not DeepDiff(
+            RequirementsParser(artifact_cache=artifact_cache).parse(requirement),
+            specification,
+            ignore_order=True,
+        )
+        for specification in expected_variants
+    )
diff --git b/tests/utils/test_extras.py a/tests/utils/test_extras.py
new file mode 100644
index 0000000..43d40d6
--- /dev/null
+++ a/tests/utils/test_extras.py
@@ -0,0 +1,75 @@
+from __future__ import annotations
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.core.packages.package import Package
+
+from poetry.factory import Factory
+from poetry.utils.extras import get_extra_package_names
+
+
+if TYPE_CHECKING:
+    from packaging.utils import NormalizedName
+
+_PACKAGE_FOO = Package("foo", "0.1.0")
+_PACKAGE_SPAM = Package("spam", "0.2.0")
+_PACKAGE_BAR = Package("bar", "0.3.0")
+_PACKAGE_BAR.add_dependency(Factory.create_dependency("foo", "*"))
+
+# recursive dependency
+_PACKAGE_BAZ = Package("baz", "0.4.0")
+_PACKAGE_BAZ.add_dependency(Factory.create_dependency("quix", "*"))
+_PACKAGE_QUIX = Package("quix", "0.5.0")
+_PACKAGE_QUIX.add_dependency(Factory.create_dependency("baz", "*"))
+
+
+@pytest.mark.parametrize(
+    ["packages", "extras", "extra_names", "expected_extra_package_names"],
+    [
+        # Empty edge case
+        ([], {}, [], set()),
+        # Selecting no extras is fine
+        ([_PACKAGE_FOO], {}, [], set()),
+        # An empty extras group should return an empty list
+        ([_PACKAGE_FOO], {"group0": []}, ["group0"], set()),
+        # Selecting an extras group should return the contained packages
+        (
+            [_PACKAGE_FOO, _PACKAGE_SPAM, _PACKAGE_BAR],
+            {"group0": ["foo"]},
+            ["group0"],
+            {"foo"},
+        ),
+        # If a package has dependencies, we should also get their names
+        (
+            [_PACKAGE_FOO, _PACKAGE_SPAM, _PACKAGE_BAR],
+            {"group0": ["bar"], "group1": ["spam"]},
+            ["group0"],
+            {"bar", "foo"},
+        ),
+        # Selecting multiple extras should get us the union of all package names
+        (
+            [_PACKAGE_FOO, _PACKAGE_SPAM, _PACKAGE_BAR],
+            {"group0": ["bar"], "group1": ["spam"]},
+            ["group0", "group1"],
+            {"bar", "foo", "spam"},
+        ),
+        (
+            [_PACKAGE_BAZ, _PACKAGE_QUIX],
+            {"group0": ["baz"], "group1": ["quix"]},
+            ["group0", "group1"],
+            {"baz", "quix"},
+        ),
+    ],
+)
+def test_get_extra_package_names(
+    packages: list[Package],
+    extras: dict[NormalizedName, list[NormalizedName]],
+    extra_names: list[NormalizedName],
+    expected_extra_package_names: set[str],
+) -> None:
+    assert (
+        get_extra_package_names(packages, extras, extra_names)
+        == expected_extra_package_names
+    )
diff --git b/tests/utils/test_helpers.py a/tests/utils/test_helpers.py
new file mode 100644
index 0000000..bec3bcc
--- /dev/null
+++ a/tests/utils/test_helpers.py
@@ -0,0 +1,345 @@
+from __future__ import annotations
+
+import base64
+import re
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+from typing import Any
+
+import pytest
+
+from poetry.core.utils.helpers import parse_requires
+from requests.exceptions import ChunkedEncodingError
+
+from poetry.utils.helpers import Downloader
+from poetry.utils.helpers import HTTPRangeRequestSupportedError
+from poetry.utils.helpers import download_file
+from poetry.utils.helpers import ensure_path
+from poetry.utils.helpers import get_file_hash
+from poetry.utils.helpers import get_highest_priority_hash_type
+
+
+if TYPE_CHECKING:
+    from httpretty import httpretty
+    from httpretty.core import HTTPrettyRequest
+
+    from tests.conftest import Config
+    from tests.types import FixtureDirGetter
+
+
+def test_parse_requires() -> None:
+    requires = """\
+jsonschema>=2.6.0.0,<3.0.0.0
+lockfile>=0.12.0.0,<0.13.0.0
+pip-tools>=1.11.0.0,<2.0.0.0
+pkginfo>=1.4.0.0,<2.0.0.0
+pyrsistent>=0.14.2.0,<0.15.0.0
+toml>=0.9.0.0,<0.10.0.0
+cleo>=0.6.0.0,<0.7.0.0
+cachy>=0.1.1.0,<0.2.0.0
+cachecontrol>=0.12.4.0,<0.13.0.0
+requests>=2.18.0.0,<3.0.0.0
+msgpack-python>=0.5.0.0,<0.6.0.0
+pyparsing>=2.2.0.0,<3.0.0.0
+requests-toolbelt>=0.8.0.0,<0.9.0.0
+
+[:(python_version >= "2.7.0.0" and python_version < "2.8.0.0")\
+ or (python_version >= "3.4.0.0" and python_version < "3.5.0.0")]
+typing>=3.6.0.0,<4.0.0.0
+
+[:python_version >= "2.7.0.0" and python_version < "2.8.0.0"]
+virtualenv>=15.2.0.0,<16.0.0.0
+pathlib2>=2.3.0.0,<3.0.0.0
+
+[:python_version >= "3.4.0.0" and python_version < "3.6.0.0"]
+zipfile36>=0.1.0.0,<0.2.0.0
+
+[dev]
+isort@ git+git://github.com/timothycrosley/isort.git@e63ae06ec7d70b06df9e528357650281a3d3ec22#egg=isort
+"""
+    result = parse_requires(requires)
+    # fmt: off
+    expected = [
+        "jsonschema>=2.6.0.0,<3.0.0.0",
+        "lockfile>=0.12.0.0,<0.13.0.0",
+        "pip-tools>=1.11.0.0,<2.0.0.0",
+        "pkginfo>=1.4.0.0,<2.0.0.0",
+        "pyrsistent>=0.14.2.0,<0.15.0.0",
+        "toml>=0.9.0.0,<0.10.0.0",
+        "cleo>=0.6.0.0,<0.7.0.0",
+        "cachy>=0.1.1.0,<0.2.0.0",
+        "cachecontrol>=0.12.4.0,<0.13.0.0",
+        "requests>=2.18.0.0,<3.0.0.0",
+        "msgpack-python>=0.5.0.0,<0.6.0.0",
+        "pyparsing>=2.2.0.0,<3.0.0.0",
+        "requests-toolbelt>=0.8.0.0,<0.9.0.0",
+        'typing>=3.6.0.0,<4.0.0.0 ; (python_version >= "2.7.0.0" and python_version < "2.8.0.0") or (python_version >= "3.4.0.0" and python_version < "3.5.0.0")',
+        'virtualenv>=15.2.0.0,<16.0.0.0 ; python_version >= "2.7.0.0" and python_version < "2.8.0.0"',
+        'pathlib2>=2.3.0.0,<3.0.0.0 ; python_version >= "2.7.0.0" and python_version < "2.8.0.0"',
+        'zipfile36>=0.1.0.0,<0.2.0.0 ; python_version >= "3.4.0.0" and python_version < "3.6.0.0"',
+        'isort@ git+git://github.com/timothycrosley/isort.git@e63ae06ec7d70b06df9e528357650281a3d3ec22#egg=isort ; extra == "dev"',
+    ]
+    # fmt: on
+    assert result == expected
+
+
+def test_default_hash(fixture_dir: FixtureDirGetter) -> None:
+    sha_256 = "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+    assert get_file_hash(fixture_dir("distributions") / "demo-0.1.0.tar.gz") == sha_256
+
+
+@pytest.mark.parametrize(
+    "hash_name,expected",
+    [
+        ("sha224", "d26bd24163fe91c16b4b0162e773514beab77b76114d9faf6a31e350"),
+        (
+            "sha3_512",
+            "196f4af9099185054ed72ca1d4c57707da5d724df0af7c3dfcc0fd018b0e0533908e790a291600c7d196fe4411b4f5f6db45213fe6e5cd5512bf18b2e9eff728",
+        ),
+        (
+            "blake2s",
+            "6dd9007d36c106defcf362cc637abeca41e8e93999928c8fcfaba515ed33bc93",
+        ),
+        (
+            "sha3_384",
+            "787264d7885a0c305d2ee4daecfff435d11818399ef96cacef7e7c6bb638ce475f630d39fdd2800ca187dcd0071dc410",
+        ),
+        (
+            "blake2b",
+            "077a34e8252c8f6776bddd0d34f321cc52762cb4c11a1c7aa9b6168023f1722caf53c9f029074a6eb990a8de341d415dd986293bc2a2fccddad428be5605696e",
+        ),
+        (
+            "sha256",
+            "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad",
+        ),
+        (
+            "sha512",
+            "766ecf369b6bdf801f6f7bbfe23923cc9793d633a55619472cd3d5763f9154711fbf57c8b6ca74e4a82fa9bd8380af831e7b8668e68e362669fc60b1d81d79ad",
+        ),
+        (
+            "sha384",
+            "c638f32460f318035e4600284ba64fb531630740aebd33885946e527002d742787ff09eb65fd81bc34ce5ff5ef11cfe8",
+        ),
+        ("sha3_224", "72980fc7bdf8c4d34268dc469442b09e1ccd2a8ff390954fc4d55a5a"),
+        ("sha1", "91b585bd38f72d7ceedb07d03f94911b772fdc4c"),
+        (
+            "sha3_256",
+            "7da5c08b416e6bcb339d6bedc0fe077c6e69af00607251ef4424c356ea061fcb",
+        ),
+    ],
+)
+def test_guaranteed_hash(
+    hash_name: str, expected: str, fixture_dir: FixtureDirGetter
+) -> None:
+    file_path = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    assert get_file_hash(file_path, hash_name) == expected
+
+
+def test_download_file(
+    http: type[httpretty], fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    file_path = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    url = "https://foo.com/demo-0.1.0.tar.gz"
+    http.register_uri(http.GET, url, body=file_path.read_bytes())
+    dest = tmp_path / "demo-0.1.0.tar.gz"
+
+    download_file(url, dest)
+
+    expect_sha_256 = "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+    assert get_file_hash(dest) == expect_sha_256
+    assert http.last_request().headers["Accept-Encoding"] == "Identity"
+
+
+def test_download_file_recover_from_error(
+    http: type[httpretty], fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    file_path = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    file_body = file_path.read_bytes()
+    file_length = len(file_body)
+    url = "https://foo.com/demo-0.1.0.tar.gz"
+
+    def handle_request(
+        request: HTTPrettyRequest, uri: str, response_headers: dict[str, Any]
+    ) -> tuple[int, dict[str, Any], bytes]:
+        if request.headers.get("Range") is None:
+            response_headers["Content-Length"] = str(file_length)
+            response_headers["Accept-Ranges"] = "bytes"
+            return 200, response_headers, file_body[: file_length // 2]
+        else:
+            start = int(
+                request.headers.get("Range", "bytes=0-").split("=")[1].split("-")[0]
+            )
+            return 206, response_headers, file_body[start:]
+
+    http.register_uri(http.GET, url, body=handle_request)
+    dest = tmp_path / "demo-0.1.0.tar.gz"
+
+    download_file(url, dest, chunk_size=file_length // 2, max_retries=1)
+
+    expect_sha_256 = "9fa123ad707a5c6c944743bf3e11a0e80d86cb518d3cf25320866ca3ef43e2ad"
+    assert get_file_hash(dest) == expect_sha_256
+    assert http.last_request().headers["Accept-Encoding"] == "Identity"
+    assert http.last_request().headers["Range"] == f"bytes={file_length // 2}-"
+
+
+def test_download_file_fail_when_no_range(
+    http: type[httpretty], fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    file_path = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    file_body = file_path.read_bytes()
+    file_length = len(file_body)
+    url = "https://foo.com/demo-0.1.0.tar.gz"
+
+    def handle_request(
+        request: HTTPrettyRequest, uri: str, response_headers: dict[str, Any]
+    ) -> tuple[int, dict[str, Any], bytes]:
+        response_headers["Content-Length"] = str(file_length)
+        return 200, response_headers, file_body[: file_length // 2]
+
+    http.register_uri(http.GET, url, body=handle_request)
+    dest = tmp_path / "demo-0.1.0.tar.gz"
+    with pytest.raises(ChunkedEncodingError):
+        download_file(url, dest, chunk_size=file_length // 2, max_retries=1)
+
+
+def test_download_file_fail_when_first_chunk_failed(
+    http: type[httpretty], fixture_dir: FixtureDirGetter, tmp_path: Path
+) -> None:
+    file_path = fixture_dir("distributions") / "demo-0.1.0.tar.gz"
+    file_body = file_path.read_bytes()
+    file_length = len(file_body)
+    url = "https://foo.com/demo-0.1.0.tar.gz"
+
+    def handle_request(
+        request: HTTPrettyRequest, uri: str, response_headers: dict[str, Any]
+    ) -> tuple[int, dict[str, Any], bytes]:
+        response_headers["Content-Length"] = str(file_length)
+        response_headers["Accept-Ranges"] = "bytes"
+        return 200, response_headers, file_body[: file_length // 2]
+
+    http.register_uri(http.GET, url, body=handle_request)
+    dest = tmp_path / "demo-0.1.0.tar.gz"
+    with pytest.raises(ChunkedEncodingError):
+        download_file(url, dest, chunk_size=file_length, max_retries=1)
+
+
+@pytest.mark.parametrize(
+    "hash_types,expected",
+    [
+        (("sha512", "sha3_512", "md5"), "sha3_512"),
+        ("md5", "md5"),
+        (("blah", "blah_blah"), None),
+        ((), None),
+    ],
+)
+def test_highest_priority_hash_type(hash_types: set[str], expected: str | None) -> None:
+    assert get_highest_priority_hash_type(hash_types, "Blah") == expected
+
+
+@pytest.mark.parametrize("accepts_ranges", [False, True])
+@pytest.mark.parametrize("raise_accepts_ranges", [False, True])
+def test_download_file_raise_accepts_ranges(
+    http: type[httpretty],
+    fixture_dir: FixtureDirGetter,
+    tmp_path: Path,
+    accepts_ranges: bool,
+    raise_accepts_ranges: bool,
+) -> None:
+    filename = "demo-0.1.0-py2.py3-none-any.whl"
+
+    def handle_request(
+        request: HTTPrettyRequest, uri: str, response_headers: dict[str, Any]
+    ) -> tuple[int, dict[str, Any], bytes]:
+        file_path = fixture_dir("distributions") / filename
+        if accepts_ranges:
+            response_headers["Accept-Ranges"] = "bytes"
+        return 200, response_headers, file_path.read_bytes()
+
+    url = f"https://foo.com/{filename}"
+    http.register_uri(http.GET, url, body=handle_request)
+    dest = tmp_path / filename
+
+    if accepts_ranges and raise_accepts_ranges:
+        with pytest.raises(HTTPRangeRequestSupportedError):
+            download_file(url, dest, raise_accepts_ranges=raise_accepts_ranges)
+        assert not dest.exists()
+    else:
+        download_file(url, dest, raise_accepts_ranges=raise_accepts_ranges)
+        assert dest.is_file()
+
+
+def test_downloader_uses_authenticator_by_default(
+    config: Config,
+    http: type[httpretty],
+    tmp_working_directory: Path,
+) -> None:
+    import poetry.utils.authenticator
+
+    # force set default authenticator to None so that it is recreated using patched config
+    poetry.utils.authenticator._authenticator = None
+
+    config.merge(
+        {
+            "repositories": {"foo": {"url": "https://foo.bar/files/"}},
+            "http-basic": {"foo": {"username": "bar", "password": "baz"}},
+        }
+    )
+
+    http.register_uri(
+        http.GET,
+        re.compile("^https?://foo.bar/(.+?)$"),
+    )
+
+    Downloader(
+        "https://foo.bar/files/foo-0.1.0.tar.gz",
+        tmp_working_directory / "foo-0.1.0.tar.gz",
+    )
+
+    request = http.last_request()
+    basic_auth = base64.b64encode(b"bar:baz").decode()
+    assert request.headers["Authorization"] == f"Basic {basic_auth}"
+
+
+def test_ensure_path_converts_string(tmp_path: Path) -> None:
+    assert tmp_path.exists()
+    assert ensure_path(path=tmp_path.as_posix(), is_directory=True) == tmp_path
+
+
+def test_ensure_path_does_not_convert_path(tmp_path: Path) -> None:
+    assert tmp_path.exists()
+    assert Path(tmp_path.as_posix()) is not tmp_path
+
+    result = ensure_path(path=tmp_path, is_directory=True)
+
+    assert result == tmp_path
+    assert result is tmp_path
+
+
+def test_ensure_path_is_directory_parameter(tmp_path: Path) -> None:
+    with pytest.raises(ValueError):
+        ensure_path(path=tmp_path, is_directory=False)
+
+    assert ensure_path(path=tmp_path, is_directory=True) is tmp_path
+
+
+def test_ensure_path_file(tmp_path: Path) -> None:
+    path = tmp_path.joinpath("some_file.txt")
+    assert not path.exists()
+
+    with pytest.raises(ValueError):
+        ensure_path(path=path, is_directory=False)
+
+    path.write_text("foobar", encoding="utf-8")
+    assert ensure_path(path=path, is_directory=False) is path
+
+
+def test_ensure_path_directory(tmp_path: Path) -> None:
+    path = tmp_path.joinpath("foobar")
+    assert not path.exists()
+
+    with pytest.raises(ValueError):
+        ensure_path(path=path, is_directory=True)
+
+    path.mkdir()
+    assert ensure_path(path=path, is_directory=True) is path
diff --git b/tests/utils/test_isolated_build.py a/tests/utils/test_isolated_build.py
new file mode 100644
index 0000000..b8d72ca
--- /dev/null
+++ a/tests/utils/test_isolated_build.py
@@ -0,0 +1,130 @@
+from __future__ import annotations
+
+import shutil
+import sys
+import uuid
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.factory import Factory
+from poetry.puzzle.exceptions import SolverProblemError
+from poetry.puzzle.provider import IncompatibleConstraintsError
+from poetry.repositories import RepositoryPool
+from poetry.repositories.installed_repository import InstalledRepository
+from poetry.utils.env import ephemeral_environment
+from poetry.utils.isolated_build import IsolatedBuildInstallError
+from poetry.utils.isolated_build import IsolatedEnv
+from poetry.utils.isolated_build import isolated_builder
+from tests.helpers import get_dependency
+
+
+if TYPE_CHECKING:
+    from collections.abc import Collection
+
+    from pytest_mock import MockerFixture
+
+    from poetry.repositories.pypi_repository import PyPiRepository
+    from tests.types import FixtureDirGetter
+
+
+@pytest.fixture()
+def pool(pypi_repository: PyPiRepository) -> RepositoryPool:
+    pool = RepositoryPool()
+
+    pool.add_repository(pypi_repository)
+
+    return pool
+
+
+@pytest.fixture(autouse=True)
+def setup(mocker: MockerFixture, pool: RepositoryPool) -> None:
+    mocker.patch.object(Factory, "create_pool", return_value=pool)
+
+
+def test_isolated_env_install_success(pool: RepositoryPool) -> None:
+    with ephemeral_environment(Path(sys.executable)) as venv:
+        env = IsolatedEnv(venv, pool)
+        assert not InstalledRepository.load(venv).find_packages(
+            get_dependency("poetry-core")
+        )
+
+        env.install({"poetry-core"})
+        assert InstalledRepository.load(venv).find_packages(
+            get_dependency("poetry-core")
+        )
+
+
+def test_isolated_env_install_discards_requirements_not_needed_by_env(
+    pool: RepositoryPool,
+) -> None:
+    with ephemeral_environment(Path(sys.executable)) as venv:
+        env = IsolatedEnv(venv, pool)
+        assert not InstalledRepository.load(venv).find_packages(
+            get_dependency("poetry-core")
+        )
+
+        venv_python_version = venv.get_marker_env().get("python_version")
+        package_one = uuid.uuid4().hex
+        package_two = uuid.uuid4().hex
+
+        env.install(
+            {
+                f"poetry-core; python_version=='{venv_python_version}'",
+                f"{package_one}>=1.0.0; python_version=='0.0'",
+                f"{package_two}>=2.0.0; platform_system=='Mirrors'",
+            }
+        )
+        assert InstalledRepository.load(venv).find_packages(
+            get_dependency("poetry-core")
+        )
+        assert not InstalledRepository.load(venv).find_packages(
+            get_dependency(package_one)
+        )
+
+        assert not InstalledRepository.load(venv).find_packages(
+            get_dependency(package_two)
+        )
+
+
+@pytest.mark.parametrize(
+    ("requirements", "exception"),
+    [
+        ({"poetry-core==1.5.0", "poetry-core==1.6.0"}, IncompatibleConstraintsError),
+        ({"black==19.10b0", "attrs==17.4.0"}, SolverProblemError),
+    ],
+)
+def test_isolated_env_install_error(
+    requirements: Collection[str], exception: type[Exception], pool: RepositoryPool
+) -> None:
+    with ephemeral_environment(Path(sys.executable)) as venv:
+        env = IsolatedEnv(venv, pool)
+        with pytest.raises(exception):
+            env.install(requirements)
+
+
+def test_isolated_env_install_failure(
+    pool: RepositoryPool, mocker: MockerFixture
+) -> None:
+    mocker.patch("poetry.installation.installer.Installer.run", return_value=1)
+    with ephemeral_environment(Path(sys.executable)) as venv:
+        env = IsolatedEnv(venv, pool)
+        with pytest.raises(IsolatedBuildInstallError) as e:
+            env.install({"a", "b>1"})
+        assert e.value.requirements == {"a", "b>1"}
+
+
+def test_isolated_builder_outside_poetry_project_context(
+    tmp_working_directory: Path, fixture_dir: FixtureDirGetter
+) -> None:
+    source = tmp_working_directory / "source"
+    shutil.copytree(fixture_dir("project_with_setup"), source)
+    destination = tmp_working_directory / "dist"
+
+    try:
+        with isolated_builder(source, "wheel") as builder:
+            builder.metadata_path(destination)
+    except RuntimeError:
+        pytest.fail("Isolated builder did not fallback to default repository pool")
diff --git b/tests/utils/test_log_utils.py a/tests/utils/test_log_utils.py
new file mode 100644
index 0000000..eb7c567
--- /dev/null
+++ a/tests/utils/test_log_utils.py
@@ -0,0 +1,16 @@
+from __future__ import annotations
+
+from poetry.core.packages.package import Package
+
+from poetry.utils.env.mock_env import MockEnv
+from poetry.utils.log_utils import format_build_wheel_log
+
+
+def test_format_build_wheel_log() -> None:
+    env = MockEnv(version_info=(3, 13, 1), platform="win32", platform_machine="AMD64")
+    package = Package(name="demo", version="1.2.3")
+    result = format_build_wheel_log(package, env)
+    expected = (
+        " <info>Building a wheel file for demo for Python 3.13.1 on win32-AMD64</info>"
+    )
+    assert result == expected
diff --git b/tests/utils/test_password_manager.py a/tests/utils/test_password_manager.py
new file mode 100644
index 0000000..329e358
--- /dev/null
+++ a/tests/utils/test_password_manager.py
@@ -0,0 +1,408 @@
+from __future__ import annotations
+
+import logging
+import os
+
+from typing import TYPE_CHECKING
+from unittest.mock import MagicMock
+
+import pytest
+
+from poetry.utils.password_manager import HTTPAuthCredential
+from poetry.utils.password_manager import PasswordManager
+from poetry.utils.password_manager import PoetryKeyring
+from poetry.utils.password_manager import PoetryKeyringError
+
+
+if TYPE_CHECKING:
+    from pytest import LogCaptureFixture
+    from pytest_mock import MockerFixture
+
+    from tests.conftest import Config
+    from tests.conftest import DummyBackend
+
+
+def test_set_http_password(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    manager.set_http_password("foo", "bar", "baz")
+
+    assert dummy_keyring.get_password("poetry-repository-foo", "bar") == "baz"
+
+    auth = config.get("http-basic.foo")
+    assert auth["username"] == "bar"
+    assert "password" not in auth
+
+
+@pytest.mark.parametrize(
+    ("username", "password", "is_valid"),
+    [
+        ("bar", "baz", True),
+        ("", "baz", True),
+        ("bar", "", True),
+        ("", "", False),
+    ],
+)
+def test_get_http_auth(
+    username: str,
+    password: str,
+    is_valid: bool,
+    config: Config,
+    with_simple_keyring: None,
+    poetry_keyring: PoetryKeyring,
+) -> None:
+    poetry_keyring.set_password("foo", username, password)
+
+    config.auth_config_source.add_property("http-basic.foo", {"username": username})
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    auth = manager.get_http_auth("foo")
+
+    if is_valid:
+        assert auth is not None
+        assert auth.username == (username or None)
+        assert auth.password == (password or None)
+    else:
+        assert auth.username is auth.password is None
+
+
+def test_delete_http_password(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    dummy_keyring.set_password("poetry-repository-foo", "bar", "baz")
+    config.auth_config_source.add_property("http-basic.foo", {"username": "bar"})
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    manager.delete_http_password("foo")
+
+    assert dummy_keyring.get_password("poetry-repository-foo", "bar") is None
+    assert config.get("http-basic.foo") is None
+
+
+def test_set_pypi_token(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    manager.set_pypi_token("foo", "baz")
+
+    assert config.get("pypi-token.foo") is None
+
+    assert dummy_keyring.get_password("poetry-repository-foo", "__token__") == "baz"
+
+
+def test_get_pypi_token(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    dummy_keyring.set_password("poetry-repository-foo", "__token__", "baz")
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    assert manager.get_pypi_token("foo") == "baz"
+
+
+def test_delete_pypi_token(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    dummy_keyring.set_password("poetry-repository-foo", "__token__", "baz")
+    manager = PasswordManager(config)
+
+    assert PoetryKeyring.is_available()
+    manager.delete_pypi_token("foo")
+
+    assert dummy_keyring.get_password("poetry-repository-foo", "__token__") is None
+
+
+def test_set_http_password_with_unavailable_backend(
+    config: Config, with_fail_keyring: None
+) -> None:
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    manager.set_http_password("foo", "bar", "baz")
+
+    auth = config.get("http-basic.foo")
+    assert auth["username"] == "bar"
+    assert auth["password"] == "baz"
+
+
+@pytest.mark.parametrize(
+    ("username", "password", "is_valid"),
+    [
+        ("bar", "baz", True),
+        ("", "baz", True),
+        ("bar", "", True),
+        ("", "", False),
+    ],
+)
+def test_get_http_auth_with_unavailable_backend(
+    username: str,
+    password: str,
+    is_valid: bool,
+    config: Config,
+    with_fail_keyring: None,
+) -> None:
+    config.auth_config_source.add_property(
+        "http-basic.foo", {"username": username, "password": password}
+    )
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    auth = manager.get_http_auth("foo")
+
+    if is_valid:
+        assert auth is not None
+        assert auth.username == (username or None)
+        assert auth.password == (password or None)
+    else:
+        assert auth.username is auth.password is None
+
+
+def test_delete_http_password_with_unavailable_backend(
+    config: Config, with_fail_keyring: None
+) -> None:
+    config.auth_config_source.add_property(
+        "http-basic.foo", {"username": "bar", "password": "baz"}
+    )
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    manager.delete_http_password("foo")
+
+    assert config.get("http-basic.foo") is None
+
+
+def test_set_pypi_token_with_unavailable_backend(
+    config: Config, with_fail_keyring: None
+) -> None:
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    manager.set_pypi_token("foo", "baz")
+
+    assert config.get("pypi-token.foo") == "baz"
+
+
+def test_get_pypi_token_with_unavailable_backend(
+    config: Config, with_fail_keyring: None
+) -> None:
+    config.auth_config_source.add_property("pypi-token.foo", "baz")
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    assert manager.get_pypi_token("foo") == "baz"
+
+
+def test_delete_pypi_token_with_unavailable_backend(
+    config: Config, with_fail_keyring: None
+) -> None:
+    config.auth_config_source.add_property("pypi-token.foo", "baz")
+    manager = PasswordManager(config)
+
+    assert not PoetryKeyring.is_available()
+    manager.delete_pypi_token("foo")
+
+    assert config.get("pypi-token.foo") is None
+
+
+def test_keyring_raises_errors_on_keyring_errors(
+    mocker: MockerFixture, with_fail_keyring: None
+) -> None:
+    mocker.patch("poetry.utils.password_manager.PoetryKeyring.is_available")
+
+    key_ring = PoetryKeyring("poetry")
+    with pytest.raises(PoetryKeyringError):
+        key_ring.set_password("foo", "bar", "baz")
+
+    with pytest.raises(PoetryKeyringError):
+        key_ring.get_password("foo", "bar")
+
+    with pytest.raises(PoetryKeyringError):
+        key_ring.delete_password("foo", "bar")
+
+
+def test_keyring_returns_none_on_locked_keyring(
+    with_locked_keyring: None,
+    caplog: LogCaptureFixture,
+) -> None:
+    caplog.set_level(logging.DEBUG, logger="poetry.utils.password_manager")
+    key_ring = PoetryKeyring("poetry")
+
+    cred = key_ring.get_credential("foo")
+
+    assert cred.password is None
+    assert "Keyring foo is locked" in caplog.messages
+
+
+def test_keyring_returns_none_on_erroneous_keyring(
+    with_erroneous_keyring: None,
+    caplog: LogCaptureFixture,
+) -> None:
+    caplog.set_level(logging.DEBUG, logger="poetry.utils.password_manager")
+    key_ring = PoetryKeyring("poetry")
+
+    cred = key_ring.get_credential("foo")
+
+    assert cred.password is None
+    assert "Accessing keyring foo failed" in caplog.messages
+
+
+def test_keyring_with_chainer_backend_and_fail_keyring_should_be_unavailable(
+    with_chained_fail_keyring: None,
+) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_keyring_with_chainer_backend_and_null_keyring_should_be_unavailable(
+    with_chained_null_keyring: None,
+) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_null_keyring_should_be_unavailable(
+    with_null_keyring: None,
+) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_fail_keyring_should_be_unavailable(
+    with_fail_keyring: None,
+) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_locked_keyring_should_not_be_available(with_locked_keyring: None) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_erroneous_keyring_should_not_be_available(
+    with_erroneous_keyring: None,
+) -> None:
+    key_ring = PoetryKeyring("poetry")
+
+    assert not key_ring.is_available()
+
+
+def test_get_http_auth_from_environment_variables(
+    environ: None, config: Config
+) -> None:
+    os.environ["POETRY_HTTP_BASIC_FOO_USERNAME"] = "bar"
+    os.environ["POETRY_HTTP_BASIC_FOO_PASSWORD"] = "baz"
+
+    manager = PasswordManager(config)
+
+    auth = manager.get_http_auth("foo")
+    assert auth == HTTPAuthCredential(username="bar", password="baz")
+
+
+def test_get_http_auth_does_not_call_keyring_when_credentials_in_environment_variables(
+    environ: None, config: Config
+) -> None:
+    os.environ["POETRY_HTTP_BASIC_FOO_USERNAME"] = "bar"
+    os.environ["POETRY_HTTP_BASIC_FOO_PASSWORD"] = "baz"
+
+    manager = PasswordManager(config)
+    manager.keyring = MagicMock()
+
+    auth = manager.get_http_auth("foo")
+    assert auth == HTTPAuthCredential(username="bar", password="baz")
+    manager.keyring.get_password.assert_not_called()
+
+
+def test_get_http_auth_does_not_call_keyring_when_password_in_environment_variables(
+    environ: None, config: Config
+) -> None:
+    config.merge(
+        {
+            "http-basic": {"foo": {"username": "bar"}},
+        }
+    )
+    os.environ["POETRY_HTTP_BASIC_FOO_PASSWORD"] = "baz"
+
+    manager = PasswordManager(config)
+    manager.keyring = MagicMock()
+
+    auth = manager.get_http_auth("foo")
+    assert auth == HTTPAuthCredential(username="bar", password="baz")
+    manager.keyring.get_password.assert_not_called()
+
+
+def test_get_pypi_token_with_env_var_positive(
+    mocker: MockerFixture,
+    config: Config,
+    with_simple_keyring: None,
+    dummy_keyring: DummyBackend,
+) -> None:
+    sample_token = "sampletoken-1234"
+    repo_name = "foo"
+    manager = PasswordManager(config)
+    mocker.patch.dict(
+        os.environ,
+        {f"POETRY_PYPI_TOKEN_{repo_name.upper()}": sample_token},
+    )
+
+    assert manager.get_pypi_token(repo_name) == sample_token
+
+
+def test_get_pypi_token_with_env_var_not_available(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    repo_name = "foo"
+    manager = PasswordManager(config)
+
+    result_token = manager.get_pypi_token(repo_name)
+
+    assert result_token is None
+
+
+def test_disabled_keyring_never_called(
+    config: Config, with_simple_keyring: None, dummy_keyring: DummyBackend
+) -> None:
+    config.config["keyring"]["enabled"] = False
+    config.config["http-basic"] = {"onlyuser": {"username": "user"}}
+
+    manager = PasswordManager(config)
+    num_public_functions = len([f for f in dir(manager) if not f.startswith("_")])
+    if num_public_functions != 10:
+        pytest.fail(
+            f"A function was added to or removed from the {PasswordManager.__name__} "
+            "class without reflecting this change in this test."
+        )
+
+    with pytest.raises(PoetryKeyringError) as e:
+        _ = manager.keyring
+
+    assert str(e.value) == "Access to keyring was requested, but it is not available"
+
+    # We made sure that accessing a disabled keyring raises an exception.
+    # Now we call the PasswordManager functions that do access the keyring to
+    # make sure that they never do so when the keyring is disabled.
+    manager.set_pypi_token(repo_name="exists", token="token")
+    manager.get_pypi_token(repo_name="exists")
+    manager.get_pypi_token(repo_name="doesn't exist")
+    manager.delete_pypi_token(repo_name="exists")
+    manager.delete_pypi_token(repo_name="doesn't exist")
+    manager.set_http_password(repo_name="exists", username="user", password="password")
+    manager.get_http_auth(repo_name="exists")
+    manager.get_http_auth(repo_name="doesn't exist")
+    manager.get_http_auth(repo_name="onlyuser")
+    manager.delete_http_password(repo_name="exits")
+    manager.delete_http_password(repo_name="doesn't exist")
+    manager.delete_http_password(repo_name="onlyuser")
+    manager.get_credential("a", "b", "c", username="user")
diff --git b/tests/utils/test_patterns.py a/tests/utils/test_patterns.py
new file mode 100644
index 0000000..daa8a48
--- /dev/null
+++ a/tests/utils/test_patterns.py
@@ -0,0 +1,85 @@
+from __future__ import annotations
+
+import pytest
+
+from poetry.utils import patterns
+
+
+@pytest.mark.parametrize(
+    ["filename", "expected"],
+    [
+        (
+            "markdown_captions-2-py3-none-any.whl",
+            {
+                "namever": "markdown_captions-2",
+                "name": "markdown_captions",
+                "ver": "2",
+                "build": None,
+                "pyver": "py3",
+                "abi": "none",
+                "plat": "any",
+            },
+        ),
+        (
+            "SQLAlchemy-1.3.20-cp27-cp27mu-manylinux2010_x86_64.whl",
+            {
+                "namever": "SQLAlchemy-1.3.20",
+                "name": "SQLAlchemy",
+                "ver": "1.3.20",
+                "build": None,
+                "pyver": "cp27",
+                "abi": "cp27mu",
+                "plat": "manylinux2010_x86_64",
+            },
+        ),
+        (
+            "isort-metadata-4.3.4-py2-none-any.whl",
+            {
+                "namever": "isort-metadata-4.3.4",
+                "name": "isort-metadata",
+                "ver": "4.3.4",
+                "build": None,
+                "pyver": "py2",
+                "abi": "none",
+                "plat": "any",
+            },
+        ),
+    ],
+)
+def test_wheel_file_re(filename: str, expected: dict[str, str | None]) -> None:
+    match = patterns.wheel_file_re.match(filename)
+    assert match is not None
+    groups = match.groupdict()
+
+    assert groups == expected
+
+
+@pytest.mark.parametrize(
+    ["filename", "expected"],
+    [
+        (
+            "poetry_core-1.5.0.tar.gz",
+            {
+                "namever": "poetry_core-1.5.0",
+                "name": "poetry_core",
+                "ver": "1.5.0",
+                "format": "tar.gz",
+            },
+        ),
+        (
+            "flask-restful-swagger-2-0.35.tar.gz",
+            {
+                "namever": "flask-restful-swagger-2-0.35",
+                "name": "flask-restful-swagger-2",
+                "ver": "0.35",
+                "format": "tar.gz",
+            },
+        ),
+    ],
+)
+def test_sdist_file_re(filename: str, expected: dict[str, str | None]) -> None:
+    match = patterns.sdist_file_re.match(filename)
+    assert match is not None
+    groups = match.groupdict()
+
+    assert groups == expected
diff --git b/tests/utils/test_pip.py a/tests/utils/test_pip.py
new file mode 100644
index 0000000..fdbf914
--- /dev/null
+++ a/tests/utils/test_pip.py
@@ -0,0 +1,40 @@
+from __future__ import annotations
+
+import subprocess
+
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils.pip import pip_install
+
+
+if TYPE_CHECKING:
+    from pathlib import Path
+
+    from pytest_mock import MockerFixture
+
+    from poetry.utils.env import VirtualEnv
+    from tests.types import FixtureDirGetter
+
+
+def test_pip_install_successful(
+    tmp_path: Path, tmp_venv: VirtualEnv, fixture_dir: FixtureDirGetter
+) -> None:
+    file_path = fixture_dir("distributions/demo-0.1.0-py2.py3-none-any.whl")
+    result = pip_install(file_path, tmp_venv)
+
+    assert "Successfully installed demo-0.1.0" in result
+
+
+def test_pip_install_with_keyboard_interrupt(
+    tmp_path: Path,
+    tmp_venv: VirtualEnv,
+    fixture_dir: FixtureDirGetter,
+    mocker: MockerFixture,
+) -> None:
+    file_path = fixture_dir("distributions/demo-0.1.0-py2.py3-none-any.whl")
+    mocker.patch("subprocess.run", side_effect=KeyboardInterrupt())
+    with pytest.raises(KeyboardInterrupt):
+        pip_install(file_path, tmp_venv)
+    subprocess.run.assert_called_once()  # type: ignore[attr-defined]
diff --git b/tests/utils/test_python_manager.py a/tests/utils/test_python_manager.py
new file mode 100644
index 0000000..d21f8a0
--- /dev/null
+++ a/tests/utils/test_python_manager.py
@@ -0,0 +1,144 @@
+from __future__ import annotations
+
+import os
+import sys
+import textwrap
+
+from pathlib import Path
+from typing import TYPE_CHECKING
+
+import findpython
+import packaging.version
+import pytest
+
+from poetry.core.constraints.version import Version
+
+from poetry.utils.env.python import Python
+
+
+if TYPE_CHECKING:
+    from unittest.mock import MagicMock
+
+    from pytest_mock import MockerFixture
+
+    from poetry.config.config import Config
+    from tests.types import MockedPythonRegister
+    from tests.types import ProjectFactory
+
+
+@pytest.fixture(scope="session")
+def python_version() -> Version:
+    version = sys.version.split(" ", 1)[0]
+    if version[-1] == "+":
+        version = version[:-1]
+    return Version.parse(version)
+
+
+def test_python_get_version_on_the_fly() -> None:
+    python = Python.get_system_python()
+
+    assert python.version == Version.parse(
+        ".".join([str(s) for s in sys.version_info[:3]])
+    )
+    assert python.patch_version == Version.parse(
+        ".".join([str(s) for s in sys.version_info[:3]])
+    )
+    assert python.minor_version == Version.parse(
+        ".".join([str(s) for s in sys.version_info[:2]])
+    )
+
+
+def test_python_get_system_python() -> None:
+    python = Python.get_system_python()
+
+    assert python.executable.resolve() == findpython.find().executable.resolve()
+    assert python.version == Version.parse(
+        ".".join(str(v) for v in sys.version_info[:3])
+    )
+
+
+def test_python_get_preferred_default(config: Config, python_version: Version) -> None:
+    python = Python.get_preferred_python(config)
+
+    assert python.executable.resolve() == Path(sys.executable).resolve()
+    assert python.version == python_version
+
+
+def test_get_preferred_python_use_poetry_python_disabled(
+    config: Config, mocker: MockerFixture
+) -> None:
+    mocker.patch(
+        "poetry.utils.env.python.Python.get_active_python",
+        return_value=Python(
+            python=findpython.PythonVersion(
+                executable=Path("/usr/bin/python3.7"),
+                _version=packaging.version.Version("3.7.1"),
+                _interpreter=Path("/usr/bin/python3.7"),
+            )
+        ),
+    )
+
+    config.config["virtualenvs"]["use-poetry-python"] = False
+    python = Python.get_preferred_python(config)
+
+    assert python.executable.as_posix().startswith("/usr/bin/python")
+    assert python.version == Version.parse("3.7.1")
+
+
+def test_get_preferred_python_use_poetry_python_disabled_fallback(
+    config: Config, with_no_active_python: MagicMock
+) -> None:
+    config.config["virtualenvs"]["use-poetry-python"] = False
+    python = Python.get_preferred_python(config)
+
+    assert with_no_active_python.call_count == 1
+    assert python.executable.resolve() == Path(sys.executable).resolve()
+
+
+def test_fallback_on_detect_active_python(with_no_active_python: MagicMock) -> None:
+    active_python = Python.get_active_python()
+    assert active_python is None
+    assert with_no_active_python.call_count == 1
+
+
+@pytest.mark.skipif(sys.platform != "win32", reason="Windows only")
+def test_detect_active_python_with_bat(
+    tmp_path: Path, without_mocked_findpython: None, python_version: Version
+) -> None:
+    """On Windows pyenv uses batch files for python management."""
+    python_wrapper = tmp_path / "python.bat"
+
+    encoding = "locale" if sys.version_info >= (3, 10) else None
+    with python_wrapper.open("w", encoding=encoding) as f:
+        f.write(
+            textwrap.dedent(f"""
+            @echo off
+            SET PYTHON_EXE="{sys.executable}"
+            %PYTHON_EXE% %*
+        """)
+        )
+    os.environ["PATH"] = str(python_wrapper.parent) + os.pathsep + os.environ["PATH"]
+
+    python = Python.get_active_python()
+    assert python is not None
+
+    # TODO: Asses if Poetry needs to discover real path in these cases as
+    # this is not a symlink and won't be handled by findpython
+    assert python.executable.as_posix() == Path(sys.executable).as_posix()
+    assert python.version == python_version
+
+
+def test_python_find_compatible(
+    project_factory: ProjectFactory, mocked_python_register: MockedPythonRegister
+) -> None:
+    # Note: This test may fail on Windows systems using Python from the Microsoft Store,
+    # as the executable is named `py.exe`, which is not currently recognized by
+    # Python.get_compatible_python. This issue will be resolved in #2117.
+    # However, this does not cause problems in our case because Poetry's own
+    # Python interpreter is used before attempting to find another compatible version.
+    fixture = Path(__file__).parent.parent / "fixtures" / "simple_project"
+    poetry = project_factory("simple-project", source=fixture)
+    mocked_python_register("3.12")
+    python = Python.get_compatible_python(poetry)
+
+    assert Version.from_parts(3, 4) <= python.version <= Version.from_parts(4, 0)
diff --git b/tests/utils/test_threading.py a/tests/utils/test_threading.py
new file mode 100644
index 0000000..35ff35a
--- /dev/null
+++ a/tests/utils/test_threading.py
@@ -0,0 +1,145 @@
+from __future__ import annotations
+
+import functools
+import logging
+import os
+import sys
+import time
+
+from concurrent.futures import wait
+from concurrent.futures.thread import ThreadPoolExecutor
+from typing import TYPE_CHECKING
+
+import pytest
+
+from poetry.utils.threading import AtomicCachedProperty
+from poetry.utils.threading import atomic_cached_property
+
+
+if TYPE_CHECKING:
+    from collections.abc import Generator
+
+    from pytest import LogCaptureFixture
+    from pytest_mock import MockerFixture
+
+
+WORKER_COUNT = (os.cpu_count() or 1) + 4
+EXPECTED_VALUE = sum(range(1_00_000))
+IS_PY_312 = (sys.version_info.major, sys.version_info.minor) >= (3, 12)
+
+
+class Example:
+    def __init__(self, value: int = 0, name: str = "default") -> None:
+        self.value = value
+        self._name = name
+
+    @classmethod
+    def compute_value(cls, name: str, ts: float) -> int:
+        logging.getLogger().info(
+            "Example compute_value called with name=%s time=%f", name, ts
+        )
+        return sum(range(1_00_000))
+
+    def _compute_value(self) -> int:
+        # we block the thread here to ensure contention
+        time.sleep(0.05)
+        return self.compute_value(self._name, time.time())
+
+    @functools.cached_property
+    def value_functools_cached_property(self) -> int:
+        return self._compute_value() + self.value
+
+    @property
+    @functools.cache  # noqa: B019
+    def value_functools_cache(self) -> int:
+        return self._compute_value() + self.value
+
+    @atomic_cached_property
+    def value_atomic_cached_property(self) -> int:
+        return self._compute_value() + self.value
+
+
+@pytest.fixture(autouse=True)
+def capture_logging(caplog: LogCaptureFixture) -> Generator[None]:
+    with caplog.at_level(logging.DEBUG):
+        yield
+
+
+def test_threading_property_types() -> None:
+    assert isinstance(Example.value_atomic_cached_property, AtomicCachedProperty)
+    assert isinstance(
+        Example.value_functools_cached_property, functools.cached_property
+    )
+    assert isinstance(Example.value_functools_cache, property)
+
+
+def test_threading_single_thread_safe() -> None:
+    instance = Example()
+    assert (
+        instance.value_functools_cached_property
+        == instance.value_atomic_cached_property
+        == EXPECTED_VALUE
+    )
+
+
+def run_in_threads(instance: Example, property_name: str) -> None:
+    results = []
+
+    def access_property() -> None:
+        results.append(instance.__getattribute__(property_name))
+
+    executor = ThreadPoolExecutor(max_workers=WORKER_COUNT)
+    futures = [executor.submit(access_property) for _ in range(WORKER_COUNT)]
+
+    wait(futures)
+    assert len(results) == WORKER_COUNT
+    assert all(result == (EXPECTED_VALUE + instance.value) for result in results)
+
+
+@pytest.mark.parametrize(
+    ["property_name", "expected_call_count"],
+    [
+        ("value_atomic_cached_property", 1),
+        # prior to Python 3.12, cached_property did have a thread lock
+        ("value_functools_cached_property", WORKER_COUNT if IS_PY_312 else 1),
+        ("value_functools_cache", WORKER_COUNT),
+    ],
+)
+def test_threading_property_caching(
+    property_name: str,
+    expected_call_count: int,
+    mocker: MockerFixture,
+    caplog: LogCaptureFixture,
+) -> None:
+    compute_value_spy = mocker.spy(Example, "compute_value")
+    run_in_threads(Example(), property_name)
+    assert compute_value_spy.call_count == len(caplog.messages) == expected_call_count
+
+
+@pytest.mark.parametrize(
+    ["property_name", "expected_call_count"],
+    [
+        ("value_atomic_cached_property", 2),
+        # prior to Python 3.12, cached_property did have a thread lock
+        ("value_functools_cached_property", (WORKER_COUNT if IS_PY_312 else 1) * 2),
+        ("value_functools_cache", WORKER_COUNT * 2),
+    ],
+)
+def test_threading_atomic_cached_property_different_instances(
+    property_name: str,
+    expected_call_count: int,
+    mocker: MockerFixture,
+    caplog: LogCaptureFixture,
+) -> None:
+    compute_value_spy = mocker.spy(Example, "compute_value")
+
+    instance1 = Example(10, "one")
+    instance2 = Example(20, "two")
+
+    run_in_threads(instance1, property_name)
+    run_in_threads(instance2, property_name)
+
+    assert compute_value_spy.call_count == len(caplog.messages) == expected_call_count
+
+    assert instance1.__getattribute__(property_name) == EXPECTED_VALUE + 10
+    assert instance2.__getattribute__(property_name) == EXPECTED_VALUE + 20
