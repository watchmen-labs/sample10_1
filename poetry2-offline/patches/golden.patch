diff --git a/src/poetry/factory.py b/src/poetry/factory.py
index 820fdd8..ce8a051 100644
--- a/src/poetry/factory.py
+++ b/src/poetry/factory.py
@@ -3,10 +3,7 @@ from __future__ import annotations
 import contextlib
 import logging
 import re
-
-from typing import TYPE_CHECKING
-from typing import Any
-from typing import cast
+from typing import TYPE_CHECKING, Any, cast
 
 from cleo.io.null_io import NullIO
 from packaging.utils import canonicalize_name
@@ -25,52 +22,134 @@ from poetry.plugins.plugin_manager import PluginManager
 from poetry.poetry import Poetry
 from poetry.toml.file import TOMLFile
 
-
 if TYPE_CHECKING:
     from collections.abc import Iterable
     from pathlib import Path
 
     from cleo.io.io import IO
     from poetry.core.packages.package import Package
+    from poetry.core.packages.project_package import ProjectPackage
     from tomlkit.toml_document import TOMLDocument
 
     from poetry.repositories import RepositoryPool
     from poetry.repositories.http_repository import HTTPRepository
     from poetry.utils.dependency_specification import DependencySpec
 
+
 logger = logging.getLogger(__name__)
 
 
 class Factory(BaseFactory):
     """
     Factory class to create various elements needed by Poetry.
+
+    This subclass wires together the highΓÇælevel :class:`poetry.poetry.Poetry`
+    object used by the CLI with the lowerΓÇælevel core factory, configuration,
+    repository pool and plugin system.
     """
 
     def create_poetry(
         self,
-        cwd: "Path | None" = None,
+        cwd: Path | None = None,
         with_groups: bool = True,
-        io: "IO | None" = None,
+        io: IO | None = None,
         disable_plugins: bool = False,
         disable_cache: bool = False,
-    ):
-        pass
+    ) -> Poetry:
+        """
+        Create the high-level :class:`Poetry` object for the current project.
+
+        Steps:
+
+        * Let :class:`poetry.core.factory.Factory` parse and validate
+          ``pyproject.toml``.
+        * Enforce an optional ``requires-poetry`` version constraint.
+        * Initialize the locker with full pyproject data.
+        * Merge global and local (`poetry.toml`) configuration.
+        * Configure the repository pool (PyPI + custom sources).
+        * Setup and activate the plugin manager (unless disabled).
+        """
+        if io is None:
+            io = NullIO()
 
-    @classmethod
-    def create_pool(
-        cls,
-        config,
-        sources = (),
-        io = None,
-        disable_cache: bool = False,
-    ):
-        pass
+        # Core factory locates and validates pyproject.toml
+        base_poetry = super().create_poetry(cwd=cwd, with_groups=with_groups)
+
+        # Project-level Poetry version constraint (requires-poetry)
+        if version_str := base_poetry.local_config.get("requires-poetry"):
+            version_constraint = parse_constraint(version_str)
+            version = Version.parse(__version__)
+            if not version_constraint.allows(version):
+                raise PoetryError(
+                    f"This project requires Poetry {version_constraint}, "
+                    f"but you are using Poetry {version}"
+                )
+
+        poetry_file = base_poetry.pyproject_path
+
+        # Locker must see the full document (project + tool.poetry + anything else)
+        locker = Locker(
+            poetry_file.parent / "poetry.lock",
+            base_poetry.pyproject.data,
+        )
+
+        # Global config (~/.config/pypoetry/config.toml, etc.)
+        config = Config.create()
+
+        # Local config (./poetry.toml)
+        local_config_file = TOMLFile(poetry_file.parent / "poetry.toml")
+        if local_config_file.exists():
+            if io.is_debug():
+                io.write_line(f"Loading configuration file {local_config_file.path}")
+
+            config.merge(local_config_file.read())
+
+        # Merge pyproject sources into config.repositories without clobbering
+        repositories: dict[str, dict[str, str]] = {}
+        existing_repositories = config.get("repositories", {})
+        for source in base_poetry.local_config.get("source", []):
+            name = source.get("name")
+            url = source.get("url")
+            if name and url and name not in existing_repositories:
+                repositories[name] = {"url": url}
+
+        if repositories:
+            config.merge({"repositories": repositories})
+
+        poetry = Poetry(
+            poetry_file,
+            base_poetry.local_config,
+            base_poetry.package,
+            locker,
+            config,
+            disable_cache,
+        )
+
+        poetry.set_pool(
+            self.create_pool(
+                config=config,
+                sources=poetry.local_config.get("source", []),
+                io=io,
+                disable_cache=disable_cache,
+            )
+        )
+
+        
+        plugin_manager = PluginManager(Plugin.group)
+        plugin_manager.load_plugins()
+        poetry.set_plugin_manager(plugin_manager)
+        plugin_manager.activate(poetry, io)
+
+        return poetry
 
     @classmethod
-    def create_package_source(
-        cls, source, config, disable_cache: bool = False
-    ):
-        pass
+    def get_package(cls, name: str, version: str) -> ProjectPackage:
+        """
+        Create the in-memory representation of the current project package.
+        """
+        from poetry.core.packages.project_package import ProjectPackage
+
+        return ProjectPackage(name, version)
 
     @classmethod
     def create_pool(
@@ -116,12 +195,15 @@ class Factory(BaseFactory):
             else:
                 pool.add_repository(
                     cls.create_package_source(
-                        {"name": "pypi"}, config, disable_cache=disable_cache
+                        {"name": "pypi"},
+                        config=config,
+                        disable_cache=disable_cache,
                     ),
                     priority=Priority.PRIMARY,
                 )
 
         if not pool.repositories:
+            # All sources are explicit -> nothing to search by default.
             raise PoetryError(
                 "At least one source must not be configured as 'explicit'."
             )
@@ -139,12 +221,13 @@ class Factory(BaseFactory):
 
         try:
             name = source["name"]
-        except KeyError:
-            raise InvalidSourceError("Missing [name] in source.")
+        except KeyError as exc:
+            raise InvalidSourceError("Missing [name] in source.") from exc
 
         pool_size = config.installer_max_workers
 
         if name.lower() == "pypi":
+            # PyPI is special-cased and cannot be re-pointed to a different URL.
             if "url" in source:
                 raise InvalidSourceError(
                     "The PyPI repository cannot be configured with a custom url."
@@ -157,11 +240,12 @@ class Factory(BaseFactory):
 
         try:
             url = source["url"]
-        except KeyError:
-            raise InvalidSourceError(f"Missing [url] in source {name!r}.")
+        except KeyError as exc:
+            raise InvalidSourceError(f"Missing [url] in source {name!r}.") from exc
 
         repository_class = LegacyRepository
 
+        # A single HTML page with links instead of a full PEP 503 simple index.
         if re.match(r".*\.(htm|html)$", url):
             repository_class = SinglePageRepository
 
@@ -174,10 +258,18 @@ class Factory(BaseFactory):
         )
 
     @classmethod
-    def create_legacy_pyproject_from_package(cls, package: Package) -> TOMLDocument:
+    def create_legacy_pyproject_from_package(
+        cls, package: Package
+    ) -> TOMLDocument:
+        """
+        Build a ``pyproject.toml`` representation for a legacy project package
+        (tool.poetry-style metadata).
+        """
         import tomlkit
 
-        from poetry.utils.dependency_specification import dependency_to_specification
+        from poetry.utils.dependency_specification import (
+            dependency_to_specification,
+        )
 
         pyproject: dict[str, Any] = tomlkit.document()
 
@@ -210,35 +302,35 @@ class Factory(BaseFactory):
         if package.keywords:
             content["keywords"] = package.keywords
 
-        readmes = []
-
+        readmes: list[str] = []
         for readme in package.readmes:
             readme_posix_path = readme.as_posix()
 
             with contextlib.suppress(ValueError):
                 if package.root_dir:
-                    readme_posix_path = readme.relative_to(package.root_dir).as_posix()
+                    readme_posix_path = readme.relative_to(
+                        package.root_dir
+                    ).as_posix()
 
             readmes.append(readme_posix_path)
 
         if readmes:
             content["readme"] = readmes
 
-        optional_dependencies = set()
+        optional_dependencies: set[str] = set()
         extras_section = None
 
         if package.extras:
             extras_section = tomlkit.table()
 
-            for extra in package.extras:
-                _dependencies = []
-                for dependency in package.extras[extra]:
-                    _dependencies.append(dependency.name)
+            for extra, dependencies in package.extras.items():
+                dependency_names: list[str] = []
+                for dependency in dependencies:
+                    dependency_names.append(dependency.name)
                     optional_dependencies.add(dependency.name)
 
-                extras_section[extra] = _dependencies
+                extras_section[extra] = dependency_names
 
-        optional_dependencies = set(optional_dependencies)
         dependency_section = content["dependencies"] = tomlkit.table()
         dependency_section["python"] = package.python_versions
 
@@ -279,15 +371,28 @@ class Factory(BaseFactory):
 
         return pyproject
 
+    # Compatibility alias for older code paths
+    @classmethod
+    def create_pyproject_from_package(cls, package: Package) -> TOMLDocument:
+        return cls.create_legacy_pyproject_from_package(package)
+
     @classmethod
     def validate(
         cls, toml_data: dict[str, Any], strict: bool = False
     ) -> dict[str, list[str]]:
+        """
+        Validate the full pyproject document.
+
+        Delegates schema checks to the core factory, then adds extra Poetry
+        semantics such as ΓÇ£project must not depend on itselfΓÇ¥.
+        """
         results = super().validate(toml_data, strict)
+
         poetry_config = toml_data["tool"]["poetry"]
 
+        # Normalise error paths to match what users see in pyproject.toml
         results["errors"].extend(
-            [e.replace("data.", "tool.poetry.") for e in validate_object(poetry_config)]
+            e.replace("data.", "tool.poetry.") for e in validate_object(poetry_config)
         )
 
         # A project should not depend on itself.
@@ -298,12 +403,16 @@ class Factory(BaseFactory):
         for group in groups:
             dependencies.update(group.get("dependencies", {}).keys())
 
-        dependencies = {canonicalize_name(d) for d in dependencies}
+        normalized_dependencies = {
+            canonicalize_name(name) for name in dependencies
+        }
 
         project_name = toml_data.get("project", {}).get("name") or poetry_config.get(
             "name"
         )
-        if project_name is not None and canonicalize_name(project_name) in dependencies:
+        if project_name is not None and canonicalize_name(project_name) in (
+            normalized_dependencies
+        ):
             results["errors"].append(
                 f"Project name ({project_name}) is same as one of its dependencies"
             )
diff --git a/src/poetry/locations.py b/src/poetry/locations.py
index 6f5a103..87ff1a9 100644
--- a/src/poetry/locations.py
+++ b/src/poetry/locations.py
@@ -1,5 +1,25 @@
-_APP_NAME = None
-DEFAULT_CACHE_DIR = None
-CONFIG_DIR = None
-def data_dir():
-    pass
+from __future__ import annotations
+
+import os
+
+from pathlib import Path
+
+from platformdirs import user_cache_path
+from platformdirs import user_config_path
+from platformdirs import user_data_path
+
+
+_APP_NAME = "pypoetry"
+
+DEFAULT_CACHE_DIR = user_cache_path(_APP_NAME, appauthor=False)
+CONFIG_DIR = Path(
+    os.getenv("POETRY_CONFIG_DIR")
+    or user_config_path(_APP_NAME, appauthor=False, roaming=True)
+)
+
+
+def data_dir() -> Path:
+    if poetry_home := os.getenv("POETRY_HOME"):
+        return Path(poetry_home).expanduser()
+
+    return user_data_path(_APP_NAME, appauthor=False, roaming=True)
