diff --git b/tests/test_basic.py a/tests/test_basic.py
new file mode 100644
index 0000000..c372a91
--- /dev/null
+++ a/tests/test_basic.py
@@ -0,0 +1,1944 @@
+import gc
+import re
+import typing as t
+import uuid
+import warnings
+import weakref
+from contextlib import nullcontext
+from datetime import datetime
+from datetime import timezone
+from platform import python_implementation
+
+import pytest
+import werkzeug.serving
+from markupsafe import Markup
+from werkzeug.exceptions import BadRequest
+from werkzeug.exceptions import Forbidden
+from werkzeug.exceptions import NotFound
+from werkzeug.http import parse_date
+from werkzeug.routing import BuildError
+from werkzeug.routing import RequestRedirect
+
+import flask
+
+require_cpython_gc = pytest.mark.skipif(
+    python_implementation() != "CPython",
+    reason="Requires CPython GC behavior",
+)
+
+
+def test_options_work(app, client):
+    @app.route("/", methods=["GET", "POST"])
+    def index():
+        return "Hello World"
+
+    rv = client.open("/", method="OPTIONS")
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]
+    assert rv.data == b""
+
+
+def test_options_on_multiple_rules(app, client):
+    @app.route("/", methods=["GET", "POST"])
+    def index():
+        return "Hello World"
+
+    @app.route("/", methods=["PUT"])
+    def index_put():
+        return "Aha!"
+
+    rv = client.open("/", method="OPTIONS")
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST", "PUT"]
+
+
+@pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
+def test_method_route(app, client, method):
+    method_route = getattr(app, method)
+    client_method = getattr(client, method)
+
+    @method_route("/")
+    def hello():
+        return "Hello"
+
+    assert client_method("/").data == b"Hello"
+
+
+def test_method_route_no_methods(app):
+    with pytest.raises(TypeError):
+        app.get("/", methods=["GET", "POST"])
+
+
+def test_provide_automatic_options_attr():
+    app = flask.Flask(__name__)
+
+    def index():
+        return "Hello World!"
+
+    index.provide_automatic_options = False
+    app.route("/")(index)
+    rv = app.test_client().open("/", method="OPTIONS")
+    assert rv.status_code == 405
+
+    app = flask.Flask(__name__)
+
+    def index2():
+        return "Hello World!"
+
+    index2.provide_automatic_options = True
+    app.route("/", methods=["OPTIONS"])(index2)
+    rv = app.test_client().open("/", method="OPTIONS")
+    assert sorted(rv.allow) == ["OPTIONS"]
+
+
+def test_provide_automatic_options_kwarg(app, client):
+    def index():
+        return flask.request.method
+
+    def more():
+        return flask.request.method
+
+    app.add_url_rule("/", view_func=index, provide_automatic_options=False)
+    app.add_url_rule(
+        "/more",
+        view_func=more,
+        methods=["GET", "POST"],
+        provide_automatic_options=False,
+    )
+    assert client.get("/").data == b"GET"
+
+    rv = client.post("/")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD"]
+
+    rv = client.open("/", method="OPTIONS")
+    assert rv.status_code == 405
+
+    rv = client.head("/")
+    assert rv.status_code == 200
+    assert not rv.data  # head truncates
+    assert client.post("/more").data == b"POST"
+    assert client.get("/more").data == b"GET"
+
+    rv = client.delete("/more")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD", "POST"]
+
+    rv = client.open("/more", method="OPTIONS")
+    assert rv.status_code == 405
+
+
+def test_request_dispatching(app, client):
+    @app.route("/")
+    def index():
+        return flask.request.method
+
+    @app.route("/more", methods=["GET", "POST"])
+    def more():
+        return flask.request.method
+
+    assert client.get("/").data == b"GET"
+    rv = client.post("/")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS"]
+    rv = client.head("/")
+    assert rv.status_code == 200
+    assert not rv.data  # head truncates
+    assert client.post("/more").data == b"POST"
+    assert client.get("/more").data == b"GET"
+    rv = client.delete("/more")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]
+
+
+def test_disallow_string_for_allowed_methods(app):
+    with pytest.raises(TypeError):
+        app.add_url_rule("/", methods="GET POST", endpoint="test")
+
+
+def test_url_mapping(app, client):
+    random_uuid4 = "7eb41166-9ebf-4d26-b771-ea3f54f8b383"
+
+    def index():
+        return flask.request.method
+
+    def more():
+        return flask.request.method
+
+    def options():
+        return random_uuid4
+
+    app.add_url_rule("/", "index", index)
+    app.add_url_rule("/more", "more", more, methods=["GET", "POST"])
+
+    # Issue 1288: Test that automatic options are not added
+    #             when non-uppercase 'options' in methods
+    app.add_url_rule("/options", "options", options, methods=["options"])
+
+    assert client.get("/").data == b"GET"
+    rv = client.post("/")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS"]
+    rv = client.head("/")
+    assert rv.status_code == 200
+    assert not rv.data  # head truncates
+    assert client.post("/more").data == b"POST"
+    assert client.get("/more").data == b"GET"
+    rv = client.delete("/more")
+    assert rv.status_code == 405
+    assert sorted(rv.allow) == ["GET", "HEAD", "OPTIONS", "POST"]
+    rv = client.open("/options", method="OPTIONS")
+    assert rv.status_code == 200
+    assert random_uuid4 in rv.data.decode("utf-8")
+
+
+def test_werkzeug_routing(app, client):
+    from werkzeug.routing import Rule
+    from werkzeug.routing import Submount
+
+    app.url_map.add(
+        Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
+    )
+
+    def bar():
+        return "bar"
+
+    def index():
+        return "index"
+
+    app.view_functions["bar"] = bar
+    app.view_functions["index"] = index
+
+    assert client.get("/foo/").data == b"index"
+    assert client.get("/foo/bar").data == b"bar"
+
+
+def test_endpoint_decorator(app, client):
+    from werkzeug.routing import Rule
+    from werkzeug.routing import Submount
+
+    app.url_map.add(
+        Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
+    )
+
+    @app.endpoint("bar")
+    def bar():
+        return "bar"
+
+    @app.endpoint("index")
+    def index():
+        return "index"
+
+    assert client.get("/foo/").data == b"index"
+    assert client.get("/foo/bar").data == b"bar"
+
+
+def test_session(app, client):
+    @app.route("/set", methods=["POST"])
+    def set():
+        assert not flask.session.accessed
+        assert not flask.session.modified
+        flask.session["value"] = flask.request.form["value"]
+        assert flask.session.accessed
+        assert flask.session.modified
+        return "value set"
+
+    @app.route("/get")
+    def get():
+        assert not flask.session.accessed
+        assert not flask.session.modified
+        v = flask.session.get("value", "None")
+        assert flask.session.accessed
+        assert not flask.session.modified
+        return v
+
+    assert client.post("/set", data={"value": "42"}).data == b"value set"
+    assert client.get("/get").data == b"42"
+
+
+def test_session_path(app, client):
+    app.config.update(APPLICATION_ROOT="/foo")
+
+    @app.route("/")
+    def index():
+        flask.session["testing"] = 42
+        return "Hello World"
+
+    rv = client.get("/", "http://example.com:8080/foo")
+    assert "path=/foo" in rv.headers["set-cookie"].lower()
+
+
+def test_session_using_application_root(app, client):
+    class PrefixPathMiddleware:
+        def __init__(self, app, prefix):
+            self.app = app
+            self.prefix = prefix
+
+        def __call__(self, environ, start_response):
+            environ["SCRIPT_NAME"] = self.prefix
+            return self.app(environ, start_response)
+
+    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, "/bar")
+    app.config.update(APPLICATION_ROOT="/bar")
+
+    @app.route("/")
+    def index():
+        flask.session["testing"] = 42
+        return "Hello World"
+
+    rv = client.get("/", "http://example.com:8080/")
+    assert "path=/bar" in rv.headers["set-cookie"].lower()
+
+
+def test_session_using_session_settings(app, client):
+    app.config.update(
+        SERVER_NAME="www.example.com:8080",
+        APPLICATION_ROOT="/test",
+        SESSION_COOKIE_DOMAIN=".example.com",
+        SESSION_COOKIE_HTTPONLY=False,
+        SESSION_COOKIE_SECURE=True,
+        SESSION_COOKIE_PARTITIONED=True,
+        SESSION_COOKIE_SAMESITE="Lax",
+        SESSION_COOKIE_PATH="/",
+    )
+
+    @app.route("/")
+    def index():
+        flask.session["testing"] = 42
+        return "Hello World"
+
+    @app.route("/clear")
+    def clear():
+        flask.session.pop("testing", None)
+        return "Goodbye World"
+
+    rv = client.get("/", "http://www.example.com:8080/test/")
+    cookie = rv.headers["set-cookie"].lower()
+    # or condition for Werkzeug < 2.3
+    assert "domain=example.com" in cookie or "domain=.example.com" in cookie
+    assert "path=/" in cookie
+    assert "secure" in cookie
+    assert "httponly" not in cookie
+    assert "samesite" in cookie
+    assert "partitioned" in cookie
+
+    rv = client.get("/clear", "http://www.example.com:8080/test/")
+    cookie = rv.headers["set-cookie"].lower()
+    assert "session=;" in cookie
+    # or condition for Werkzeug < 2.3
+    assert "domain=example.com" in cookie or "domain=.example.com" in cookie
+    assert "path=/" in cookie
+    assert "secure" in cookie
+    assert "samesite" in cookie
+    assert "partitioned" in cookie
+
+
+def test_session_using_samesite_attribute(app, client):
+    @app.route("/")
+    def index():
+        flask.session["testing"] = 42
+        return "Hello World"
+
+    app.config.update(SESSION_COOKIE_SAMESITE="invalid")
+
+    with pytest.raises(ValueError):
+        client.get("/")
+
+    app.config.update(SESSION_COOKIE_SAMESITE=None)
+    rv = client.get("/")
+    cookie = rv.headers["set-cookie"].lower()
+    assert "samesite" not in cookie
+
+    app.config.update(SESSION_COOKIE_SAMESITE="Strict")
+    rv = client.get("/")
+    cookie = rv.headers["set-cookie"].lower()
+    assert "samesite=strict" in cookie
+
+    app.config.update(SESSION_COOKIE_SAMESITE="Lax")
+    rv = client.get("/")
+    cookie = rv.headers["set-cookie"].lower()
+    assert "samesite=lax" in cookie
+
+
+def test_missing_session(app):
+    app.secret_key = None
+
+    def expect_exception(f, *args, **kwargs):
+        e = pytest.raises(RuntimeError, f, *args, **kwargs)
+        assert e.value.args and "session is unavailable" in e.value.args[0]
+
+    with app.test_request_context():
+        assert flask.session.get("missing_key") is None
+        expect_exception(flask.session.__setitem__, "foo", 42)
+        expect_exception(flask.session.pop, "foo")
+
+
+def test_session_secret_key_fallbacks(app, client) -> None:
+    @app.post("/")
+    def set_session() -> str:
+        flask.session["a"] = 1
+        return ""
+
+    @app.get("/")
+    def get_session() -> dict[str, t.Any]:
+        return dict(flask.session)
+
+    # Set session with initial secret key, and two valid expiring keys
+    app.secret_key, app.config["SECRET_KEY_FALLBACKS"] = (
+        "0 key",
+        ["-1 key", "-2 key"],
+    )
+    client.post()
+    assert client.get().json == {"a": 1}
+    # Change secret key, session can't be loaded and appears empty
+    app.secret_key = "? key"
+    assert client.get().json == {}
+    # Rotate the valid keys, session can be loaded
+    app.secret_key, app.config["SECRET_KEY_FALLBACKS"] = (
+        "+1 key",
+        ["0 key", "-1 key"],
+    )
+    assert client.get().json == {"a": 1}
+
+
+def test_session_expiration(app, client):
+    permanent = True
+
+    @app.route("/")
+    def index():
+        flask.session["test"] = 42
+        flask.session.permanent = permanent
+        return ""
+
+    @app.route("/test")
+    def test():
+        return str(flask.session.permanent)
+
+    rv = client.get("/")
+    assert "set-cookie" in rv.headers
+    match = re.search(r"(?i)\bexpires=([^;]+)", rv.headers["set-cookie"])
+    expires = parse_date(match.group())
+    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime
+    assert expires.year == expected.year
+    assert expires.month == expected.month
+    assert expires.day == expected.day
+
+    rv = client.get("/test")
+    assert rv.data == b"True"
+
+    permanent = False
+    rv = client.get("/")
+    assert "set-cookie" in rv.headers
+    match = re.search(r"\bexpires=([^;]+)", rv.headers["set-cookie"])
+    assert match is None
+
+
+def test_session_stored_last(app, client):
+    @app.after_request
+    def modify_session(response):
+        flask.session["foo"] = 42
+        return response
+
+    @app.route("/")
+    def dump_session_contents():
+        return repr(flask.session.get("foo"))
+
+    assert client.get("/").data == b"None"
+    assert client.get("/").data == b"42"
+
+
+def test_session_special_types(app, client):
+    now = datetime.now(timezone.utc).replace(microsecond=0)
+    the_uuid = uuid.uuid4()
+
+    @app.route("/")
+    def dump_session_contents():
+        flask.session["t"] = (1, 2, 3)
+        flask.session["b"] = b"\xff"
+        flask.session["m"] = Markup("<html>")
+        flask.session["u"] = the_uuid
+        flask.session["d"] = now
+        flask.session["t_tag"] = {" t": "not-a-tuple"}
+        flask.session["di_t_tag"] = {" t__": "not-a-tuple"}
+        flask.session["di_tag"] = {" di": "not-a-dict"}
+        return "", 204
+
+    with client:
+        client.get("/")
+        s = flask.session
+        assert s["t"] == (1, 2, 3)
+        assert type(s["b"]) is bytes  # noqa: E721
+        assert s["b"] == b"\xff"
+        assert type(s["m"]) is Markup  # noqa: E721
+        assert s["m"] == Markup("<html>")
+        assert s["u"] == the_uuid
+        assert s["d"] == now
+        assert s["t_tag"] == {" t": "not-a-tuple"}
+        assert s["di_t_tag"] == {" t__": "not-a-tuple"}
+        assert s["di_tag"] == {" di": "not-a-dict"}
+
+
+def test_session_cookie_setting(app):
+    is_permanent = True
+
+    @app.route("/bump")
+    def bump():
+        rv = flask.session["foo"] = flask.session.get("foo", 0) + 1
+        flask.session.permanent = is_permanent
+        return str(rv)
+
+    @app.route("/read")
+    def read():
+        return str(flask.session.get("foo", 0))
+
+    def run_test(expect_header):
+        with app.test_client() as c:
+            assert c.get("/bump").data == b"1"
+            assert c.get("/bump").data == b"2"
+            assert c.get("/bump").data == b"3"
+
+            rv = c.get("/read")
+            set_cookie = rv.headers.get("set-cookie")
+            assert (set_cookie is not None) == expect_header
+            assert rv.data == b"3"
+
+    is_permanent = True
+    app.config["SESSION_REFRESH_EACH_REQUEST"] = True
+    run_test(expect_header=True)
+
+    is_permanent = True
+    app.config["SESSION_REFRESH_EACH_REQUEST"] = False
+    run_test(expect_header=False)
+
+    is_permanent = False
+    app.config["SESSION_REFRESH_EACH_REQUEST"] = True
+    run_test(expect_header=False)
+
+    is_permanent = False
+    app.config["SESSION_REFRESH_EACH_REQUEST"] = False
+    run_test(expect_header=False)
+
+
+def test_session_vary_cookie(app, client):
+    @app.route("/set")
+    def set_session():
+        flask.session["test"] = "test"
+        return ""
+
+    @app.route("/get")
+    def get():
+        return flask.session.get("test")
+
+    @app.route("/getitem")
+    def getitem():
+        return flask.session["test"]
+
+    @app.route("/setdefault")
+    def setdefault():
+        return flask.session.setdefault("test", "default")
+
+    @app.route("/clear")
+    def clear():
+        flask.session.clear()
+        return ""
+
+    @app.route("/vary-cookie-header-set")
+    def vary_cookie_header_set():
+        response = flask.Response()
+        response.vary.add("Cookie")
+        flask.session["test"] = "test"
+        return response
+
+    @app.route("/vary-header-set")
+    def vary_header_set():
+        response = flask.Response()
+        response.vary.update(("Accept-Encoding", "Accept-Language"))
+        flask.session["test"] = "test"
+        return response
+
+    @app.route("/no-vary-header")
+    def no_vary_header():
+        return ""
+
+    def expect(path, header_value="Cookie"):
+        rv = client.get(path)
+
+        if header_value:
+            # The 'Vary' key should exist in the headers only once.
+            assert len(rv.headers.get_all("Vary")) == 1
+            assert rv.headers["Vary"] == header_value
+        else:
+            assert "Vary" not in rv.headers
+
+    expect("/set")
+    expect("/get")
+    expect("/getitem")
+    expect("/setdefault")
+    expect("/clear")
+    expect("/vary-cookie-header-set")
+    expect("/vary-header-set", "Accept-Encoding, Accept-Language, Cookie")
+    expect("/no-vary-header", None)
+
+
+def test_session_refresh_vary(app, client):
+    @app.get("/login")
+    def login():
+        flask.session["user_id"] = 1
+        flask.session.permanent = True
+        return ""
+
+    @app.get("/ignored")
+    def ignored():
+        return ""
+
+    rv = client.get("/login")
+    assert rv.headers["Vary"] == "Cookie"
+    rv = client.get("/ignored")
+    assert rv.headers["Vary"] == "Cookie"
+
+
+def test_flashes(app, req_ctx):
+    assert not flask.session.modified
+    flask.flash("Zap")
+    flask.session.modified = False
+    flask.flash("Zip")
+    assert flask.session.modified
+    assert list(flask.get_flashed_messages()) == ["Zap", "Zip"]
+
+
+def test_extended_flashing(app):
+    # Be sure app.testing=True below, else tests can fail silently.
+    #
+    # Specifically, if app.testing is not set to True, the AssertionErrors
+    # in the view functions will cause a 500 response to the test client
+    # instead of propagating exceptions.
+
+    @app.route("/")
+    def index():
+        flask.flash("Hello World")
+        flask.flash("Hello World", "error")
+        flask.flash(Markup("<em>Testing</em>"), "warning")
+        return ""
+
+    @app.route("/test/")
+    def test():
+        messages = flask.get_flashed_messages()
+        assert list(messages) == [
+            "Hello World",
+            "Hello World",
+            Markup("<em>Testing</em>"),
+        ]
+        return ""
+
+    @app.route("/test_with_categories/")
+    def test_with_categories():
+        messages = flask.get_flashed_messages(with_categories=True)
+        assert len(messages) == 3
+        assert list(messages) == [
+            ("message", "Hello World"),
+            ("error", "Hello World"),
+            ("warning", Markup("<em>Testing</em>")),
+        ]
+        return ""
+
+    @app.route("/test_filter/")
+    def test_filter():
+        messages = flask.get_flashed_messages(
+            category_filter=["message"], with_categories=True
+        )
+        assert list(messages) == [("message", "Hello World")]
+        return ""
+
+    @app.route("/test_filters/")
+    def test_filters():
+        messages = flask.get_flashed_messages(
+            category_filter=["message", "warning"], with_categories=True
+        )
+        assert list(messages) == [
+            ("message", "Hello World"),
+            ("warning", Markup("<em>Testing</em>")),
+        ]
+        return ""
+
+    @app.route("/test_filters_without_returning_categories/")
+    def test_filters2():
+        messages = flask.get_flashed_messages(category_filter=["message", "warning"])
+        assert len(messages) == 2
+        assert messages[0] == "Hello World"
+        assert messages[1] == Markup("<em>Testing</em>")
+        return ""
+
+    # Create new test client on each test to clean flashed messages.
+
+    client = app.test_client()
+    client.get("/")
+    client.get("/test_with_categories/")
+
+    client = app.test_client()
+    client.get("/")
+    client.get("/test_filter/")
+
+    client = app.test_client()
+    client.get("/")
+    client.get("/test_filters/")
+
+    client = app.test_client()
+    client.get("/")
+    client.get("/test_filters_without_returning_categories/")
+
+
+def test_request_processing(app, client):
+    evts = []
+
+    @app.before_request
+    def before_request():
+        evts.append("before")
+
+    @app.after_request
+    def after_request(response):
+        response.data += b"|after"
+        evts.append("after")
+        return response
+
+    @app.route("/")
+    def index():
+        assert "before" in evts
+        assert "after" not in evts
+        return "request"
+
+    assert "after" not in evts
+    rv = client.get("/").data
+    assert "after" in evts
+    assert rv == b"request|after"
+
+
+def test_request_preprocessing_early_return(app, client):
+    evts = []
+
+    @app.before_request
+    def before_request1():
+        evts.append(1)
+
+    @app.before_request
+    def before_request2():
+        evts.append(2)
+        return "hello"
+
+    @app.before_request
+    def before_request3():
+        evts.append(3)
+        return "bye"
+
+    @app.route("/")
+    def index():
+        evts.append("index")
+        return "damnit"
+
+    rv = client.get("/").data.strip()
+    assert rv == b"hello"
+    assert evts == [1, 2]
+
+
+def test_after_request_processing(app, client):
+    @app.route("/")
+    def index():
+        @flask.after_this_request
+        def foo(response):
+            response.headers["X-Foo"] = "a header"
+            return response
+
+        return "Test"
+
+    resp = client.get("/")
+    assert resp.status_code == 200
+    assert resp.headers["X-Foo"] == "a header"
+
+
+def test_teardown_request_handler(app, client):
+    called = []
+
+    @app.teardown_request
+    def teardown_request(exc):
+        called.append(True)
+        return "Ignored"
+
+    @app.route("/")
+    def root():
+        return "Response"
+
+    rv = client.get("/")
+    assert rv.status_code == 200
+    assert b"Response" in rv.data
+    assert len(called) == 1
+
+
+def test_teardown_request_handler_debug_mode(app, client):
+    called = []
+
+    @app.teardown_request
+    def teardown_request(exc):
+        called.append(True)
+        return "Ignored"
+
+    @app.route("/")
+    def root():
+        return "Response"
+
+    rv = client.get("/")
+    assert rv.status_code == 200
+    assert b"Response" in rv.data
+    assert len(called) == 1
+
+
+def test_teardown_request_handler_error(app, client):
+    called = []
+    app.testing = False
+
+    @app.teardown_request
+    def teardown_request1(exc):
+        assert type(exc) is ZeroDivisionError
+        called.append(True)
+        # This raises a new error and blows away sys.exc_info(), so we can
+        # test that all teardown_requests get passed the same original
+        # exception.
+        try:
+            raise TypeError()
+        except Exception:
+            pass
+
+    @app.teardown_request
+    def teardown_request2(exc):
+        assert type(exc) is ZeroDivisionError
+        called.append(True)
+        # This raises a new error and blows away sys.exc_info(), so we can
+        # test that all teardown_requests get passed the same original
+        # exception.
+        try:
+            raise TypeError()
+        except Exception:
+            pass
+
+    @app.route("/")
+    def fails():
+        raise ZeroDivisionError
+
+    rv = client.get("/")
+    assert rv.status_code == 500
+    assert b"Internal Server Error" in rv.data
+    assert len(called) == 2
+
+
+def test_before_after_request_order(app, client):
+    called = []
+
+    @app.before_request
+    def before1():
+        called.append(1)
+
+    @app.before_request
+    def before2():
+        called.append(2)
+
+    @app.after_request
+    def after1(response):
+        called.append(4)
+        return response
+
+    @app.after_request
+    def after2(response):
+        called.append(3)
+        return response
+
+    @app.teardown_request
+    def finish1(exc):
+        called.append(6)
+
+    @app.teardown_request
+    def finish2(exc):
+        called.append(5)
+
+    @app.route("/")
+    def index():
+        return "42"
+
+    rv = client.get("/")
+    assert rv.data == b"42"
+    assert called == [1, 2, 3, 4, 5, 6]
+
+
+def test_error_handling(app, client):
+    app.testing = False
+
+    @app.errorhandler(404)
+    def not_found(e):
+        return "not found", 404
+
+    @app.errorhandler(500)
+    def internal_server_error(e):
+        return "internal server error", 500
+
+    @app.errorhandler(Forbidden)
+    def forbidden(e):
+        return "forbidden", 403
+
+    @app.route("/")
+    def index():
+        flask.abort(404)
+
+    @app.route("/error")
+    def error():
+        raise ZeroDivisionError
+
+    @app.route("/forbidden")
+    def error2():
+        flask.abort(403)
+
+    rv = client.get("/")
+    assert rv.status_code == 404
+    assert rv.data == b"not found"
+    rv = client.get("/error")
+    assert rv.status_code == 500
+    assert b"internal server error" == rv.data
+    rv = client.get("/forbidden")
+    assert rv.status_code == 403
+    assert b"forbidden" == rv.data
+
+
+def test_error_handling_processing(app, client):
+    app.testing = False
+
+    @app.errorhandler(500)
+    def internal_server_error(e):
+        return "internal server error", 500
+
+    @app.route("/")
+    def broken_func():
+        raise ZeroDivisionError
+
+    @app.after_request
+    def after_request(resp):
+        resp.mimetype = "text/x-special"
+        return resp
+
+    resp = client.get("/")
+    assert resp.mimetype == "text/x-special"
+    assert resp.data == b"internal server error"
+
+
+def test_baseexception_error_handling(app, client):
+    app.testing = False
+
+    @app.route("/")
+    def broken_func():
+        raise KeyboardInterrupt()
+
+    with pytest.raises(KeyboardInterrupt):
+        client.get("/")
+
+
+def test_before_request_and_routing_errors(app, client):
+    @app.before_request
+    def attach_something():
+        flask.g.something = "value"
+
+    @app.errorhandler(404)
+    def return_something(error):
+        return flask.g.something, 404
+
+    rv = client.get("/")
+    assert rv.status_code == 404
+    assert rv.data == b"value"
+
+
+def test_user_error_handling(app, client):
+    class MyException(Exception):
+        pass
+
+    @app.errorhandler(MyException)
+    def handle_my_exception(e):
+        assert isinstance(e, MyException)
+        return "42"
+
+    @app.route("/")
+    def index():
+        raise MyException()
+
+    assert client.get("/").data == b"42"
+
+
+def test_http_error_subclass_handling(app, client):
+    class ForbiddenSubclass(Forbidden):
+        pass
+
+    @app.errorhandler(ForbiddenSubclass)
+    def handle_forbidden_subclass(e):
+        assert isinstance(e, ForbiddenSubclass)
+        return "banana"
+
+    @app.errorhandler(403)
+    def handle_403(e):
+        assert not isinstance(e, ForbiddenSubclass)
+        assert isinstance(e, Forbidden)
+        return "apple"
+
+    @app.route("/1")
+    def index1():
+        raise ForbiddenSubclass()
+
+    @app.route("/2")
+    def index2():
+        flask.abort(403)
+
+    @app.route("/3")
+    def index3():
+        raise Forbidden()
+
+    assert client.get("/1").data == b"banana"
+    assert client.get("/2").data == b"apple"
+    assert client.get("/3").data == b"apple"
+
+
+def test_errorhandler_precedence(app, client):
+    class E1(Exception):
+        pass
+
+    class E2(Exception):
+        pass
+
+    class E3(E1, E2):
+        pass
+
+    @app.errorhandler(E2)
+    def handle_e2(e):
+        return "E2"
+
+    @app.errorhandler(Exception)
+    def handle_exception(e):
+        return "Exception"
+
+    @app.route("/E1")
+    def raise_e1():
+        raise E1
+
+    @app.route("/E3")
+    def raise_e3():
+        raise E3
+
+    rv = client.get("/E1")
+    assert rv.data == b"Exception"
+
+    rv = client.get("/E3")
+    assert rv.data == b"E2"
+
+
+@pytest.mark.parametrize(
+    ("debug", "trap", "expect_key", "expect_abort"),
+    [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
+)
+def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
+    app.config["DEBUG"] = debug
+    app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
+
+    @app.route("/key")
+    def fail():
+        flask.request.form["missing_key"]
+
+    @app.route("/abort")
+    def allow_abort():
+        flask.abort(400)
+
+    if expect_key:
+        rv = client.get("/key")
+        assert rv.status_code == 400
+        assert b"missing_key" not in rv.data
+    else:
+        with pytest.raises(KeyError) as exc_info:
+            client.get("/key")
+
+        assert exc_info.errisinstance(BadRequest)
+        assert "missing_key" in exc_info.value.get_description()
+
+    if expect_abort:
+        rv = client.get("/abort")
+        assert rv.status_code == 400
+    else:
+        with pytest.raises(BadRequest):
+            client.get("/abort")
+
+
+def test_trapping_of_all_http_exceptions(app, client):
+    app.config["TRAP_HTTP_EXCEPTIONS"] = True
+
+    @app.route("/fail")
+    def fail():
+        flask.abort(404)
+
+    with pytest.raises(NotFound):
+        client.get("/fail")
+
+
+def test_error_handler_after_processor_error(app, client):
+    app.testing = False
+
+    @app.before_request
+    def before_request():
+        if _trigger == "before":
+            raise ZeroDivisionError
+
+    @app.after_request
+    def after_request(response):
+        if _trigger == "after":
+            raise ZeroDivisionError
+
+        return response
+
+    @app.route("/")
+    def index():
+        return "Foo"
+
+    @app.errorhandler(500)
+    def internal_server_error(e):
+        return "Hello Server Error", 500
+
+    for _trigger in "before", "after":
+        rv = client.get("/")
+        assert rv.status_code == 500
+        assert rv.data == b"Hello Server Error"
+
+
+def test_enctype_debug_helper(app, client):
+    from flask.debughelpers import DebugFilesKeyError
+
+    app.debug = True
+
+    @app.route("/fail", methods=["POST"])
+    def index():
+        return flask.request.files["foo"].filename
+
+    with pytest.raises(DebugFilesKeyError) as e:
+        client.post("/fail", data={"foo": "index.txt"})
+    assert "no file contents were transmitted" in str(e.value)
+    assert "This was submitted: 'index.txt'" in str(e.value)
+
+
+def test_response_types(app, client):
+    @app.route("/text")
+    def from_text():
+        return "H├ñllo W├╢rld"
+
+    @app.route("/bytes")
+    def from_bytes():
+        return "H├ñllo W├╢rld".encode()
+
+    @app.route("/full_tuple")
+    def from_full_tuple():
+        return (
+            "Meh",
+            400,
+            {"X-Foo": "Testing", "Content-Type": "text/plain; charset=utf-8"},
+        )
+
+    @app.route("/text_headers")
+    def from_text_headers():
+        return "Hello", {"X-Foo": "Test", "Content-Type": "text/plain; charset=utf-8"}
+
+    @app.route("/text_status")
+    def from_text_status():
+        return "Hi, status!", 400
+
+    @app.route("/response_headers")
+    def from_response_headers():
+        return (
+            flask.Response(
+                "Hello world", 404, {"Content-Type": "text/html", "X-Foo": "Baz"}
+            ),
+            {"Content-Type": "text/plain", "X-Foo": "Bar", "X-Bar": "Foo"},
+        )
+
+    @app.route("/response_status")
+    def from_response_status():
+        return app.response_class("Hello world", 400), 500
+
+    @app.route("/wsgi")
+    def from_wsgi():
+        return NotFound()
+
+    @app.route("/dict")
+    def from_dict():
+        return {"foo": "bar"}, 201
+
+    @app.route("/list")
+    def from_list():
+        return ["foo", "bar"], 201
+
+    assert client.get("/text").data == "H├ñllo W├╢rld".encode()
+    assert client.get("/bytes").data == "H├ñllo W├╢rld".encode()
+
+    rv = client.get("/full_tuple")
+    assert rv.data == b"Meh"
+    assert rv.headers["X-Foo"] == "Testing"
+    assert rv.status_code == 400
+    assert rv.mimetype == "text/plain"
+
+    rv = client.get("/text_headers")
+    assert rv.data == b"Hello"
+    assert rv.headers["X-Foo"] == "Test"
+    assert rv.status_code == 200
+    assert rv.mimetype == "text/plain"
+
+    rv = client.get("/text_status")
+    assert rv.data == b"Hi, status!"
+    assert rv.status_code == 400
+    assert rv.mimetype == "text/html"
+
+    rv = client.get("/response_headers")
+    assert rv.data == b"Hello world"
+    assert rv.content_type == "text/plain"
+    assert rv.headers.getlist("X-Foo") == ["Bar"]
+    assert rv.headers["X-Bar"] == "Foo"
+    assert rv.status_code == 404
+
+    rv = client.get("/response_status")
+    assert rv.data == b"Hello world"
+    assert rv.status_code == 500
+
+    rv = client.get("/wsgi")
+    assert b"Not Found" in rv.data
+    assert rv.status_code == 404
+
+    rv = client.get("/dict")
+    assert rv.json == {"foo": "bar"}
+    assert rv.status_code == 201
+
+    rv = client.get("/list")
+    assert rv.json == ["foo", "bar"]
+    assert rv.status_code == 201
+
+
+def test_response_type_errors():
+    app = flask.Flask(__name__)
+    app.testing = True
+
+    @app.route("/none")
+    def from_none():
+        pass
+
+    @app.route("/small_tuple")
+    def from_small_tuple():
+        return ("Hello",)
+
+    @app.route("/large_tuple")
+    def from_large_tuple():
+        return "Hello", 234, {"X-Foo": "Bar"}, "???"
+
+    @app.route("/bad_type")
+    def from_bad_type():
+        return True
+
+    @app.route("/bad_wsgi")
+    def from_bad_wsgi():
+        return lambda: None
+
+    c = app.test_client()
+
+    with pytest.raises(TypeError) as e:
+        c.get("/none")
+
+    assert "returned None" in str(e.value)
+    assert "from_none" in str(e.value)
+
+    with pytest.raises(TypeError) as e:
+        c.get("/small_tuple")
+
+    assert "tuple must have the form" in str(e.value)
+
+    with pytest.raises(TypeError):
+        c.get("/large_tuple")
+
+    with pytest.raises(TypeError) as e:
+        c.get("/bad_type")
+
+    assert "it was a bool" in str(e.value)
+
+    with pytest.raises(TypeError):
+        c.get("/bad_wsgi")
+
+
+def test_make_response(app, req_ctx):
+    rv = flask.make_response()
+    assert rv.status_code == 200
+    assert rv.data == b""
+    assert rv.mimetype == "text/html"
+
+    rv = flask.make_response("Awesome")
+    assert rv.status_code == 200
+    assert rv.data == b"Awesome"
+    assert rv.mimetype == "text/html"
+
+    rv = flask.make_response("W00t", 404)
+    assert rv.status_code == 404
+    assert rv.data == b"W00t"
+    assert rv.mimetype == "text/html"
+
+    rv = flask.make_response(c for c in "Hello")
+    assert rv.status_code == 200
+    assert rv.data == b"Hello"
+    assert rv.mimetype == "text/html"
+
+
+def test_make_response_with_response_instance(app, req_ctx):
+    rv = flask.make_response(flask.jsonify({"msg": "W00t"}), 400)
+    assert rv.status_code == 400
+    assert rv.data == b'{"msg":"W00t"}\n'
+    assert rv.mimetype == "application/json"
+
+    rv = flask.make_response(flask.Response(""), 400)
+    assert rv.status_code == 400
+    assert rv.data == b""
+    assert rv.mimetype == "text/html"
+
+    rv = flask.make_response(
+        flask.Response("", headers={"Content-Type": "text/html"}),
+        400,
+        [("X-Foo", "bar")],
+    )
+    assert rv.status_code == 400
+    assert rv.headers["Content-Type"] == "text/html"
+    assert rv.headers["X-Foo"] == "bar"
+
+
+@pytest.mark.parametrize("compact", [True, False])
+def test_jsonify_no_prettyprint(app, compact):
+    app.json.compact = compact
+    rv = app.json.response({"msg": {"submsg": "W00t"}, "msg2": "foobar"})
+    data = rv.data.strip()
+    assert (b" " not in data) is compact
+    assert (b"\n" not in data) is compact
+
+
+def test_jsonify_mimetype(app, req_ctx):
+    app.json.mimetype = "application/vnd.api+json"
+    msg = {"msg": {"submsg": "W00t"}}
+    rv = flask.make_response(flask.jsonify(msg), 200)
+    assert rv.mimetype == "application/vnd.api+json"
+
+
+def test_json_dump_dataclass(app, req_ctx):
+    from dataclasses import make_dataclass
+
+    Data = make_dataclass("Data", [("name", str)])
+    value = app.json.dumps(Data("Flask"))
+    value = app.json.loads(value)
+    assert value == {"name": "Flask"}
+
+
+def test_jsonify_args_and_kwargs_check(app, req_ctx):
+    with pytest.raises(TypeError) as e:
+        flask.jsonify("fake args", kwargs="fake")
+    assert "args or kwargs" in str(e.value)
+
+
+def test_url_generation(app, req_ctx):
+    @app.route("/hello/<name>", methods=["POST"])
+    def hello():
+        pass
+
+    assert flask.url_for("hello", name="test x") == "/hello/test%20x"
+    assert (
+        flask.url_for("hello", name="test x", _external=True)
+        == "http://localhost/hello/test%20x"
+    )
+
+
+def test_build_error_handler(app):
+    # Test base case, a URL which results in a BuildError.
+    with app.test_request_context():
+        pytest.raises(BuildError, flask.url_for, "spam")
+
+    # Verify the error is re-raised if not the current exception.
+    try:
+        with app.test_request_context():
+            flask.url_for("spam")
+    except BuildError as err:
+        error = err
+    try:
+        raise RuntimeError("Test case where BuildError is not current.")
+    except RuntimeError:
+        pytest.raises(BuildError, app.handle_url_build_error, error, "spam", {})
+
+    # Test a custom handler.
+    def handler(error, endpoint, values):
+        # Just a test.
+        return "/test_handler/"
+
+    app.url_build_error_handlers.append(handler)
+    with app.test_request_context():
+        assert flask.url_for("spam") == "/test_handler/"
+
+
+def test_build_error_handler_reraise(app):
+    # Test a custom handler which reraises the BuildError
+    def handler_raises_build_error(error, endpoint, values):
+        raise error
+
+    app.url_build_error_handlers.append(handler_raises_build_error)
+
+    with app.test_request_context():
+        pytest.raises(BuildError, flask.url_for, "not.existing")
+
+
+def test_url_for_passes_special_values_to_build_error_handler(app):
+    @app.url_build_error_handlers.append
+    def handler(error, endpoint, values):
+        assert values == {
+            "_external": False,
+            "_anchor": None,
+            "_method": None,
+            "_scheme": None,
+        }
+        return "handled"
+
+    with app.test_request_context():
+        flask.url_for("/")
+
+
+def test_static_files(app, client):
+    rv = client.get("/static/index.html")
+    assert rv.status_code == 200
+    assert rv.data.strip() == b"<h1>Hello World!</h1>"
+    with app.test_request_context():
+        assert flask.url_for("static", filename="index.html") == "/static/index.html"
+    rv.close()
+
+
+def test_static_url_path():
+    app = flask.Flask(__name__, static_url_path="/foo")
+    app.testing = True
+    rv = app.test_client().get("/foo/index.html")
+    assert rv.status_code == 200
+    rv.close()
+
+    with app.test_request_context():
+        assert flask.url_for("static", filename="index.html") == "/foo/index.html"
+
+
+def test_static_url_path_with_ending_slash():
+    app = flask.Flask(__name__, static_url_path="/foo/")
+    app.testing = True
+    rv = app.test_client().get("/foo/index.html")
+    assert rv.status_code == 200
+    rv.close()
+
+    with app.test_request_context():
+        assert flask.url_for("static", filename="index.html") == "/foo/index.html"
+
+
+def test_static_url_empty_path(app):
+    app = flask.Flask(__name__, static_folder="", static_url_path="")
+    rv = app.test_client().open("/static/index.html", method="GET")
+    assert rv.status_code == 200
+    rv.close()
+
+
+def test_static_url_empty_path_default(app):
+    app = flask.Flask(__name__, static_folder="")
+    rv = app.test_client().open("/static/index.html", method="GET")
+    assert rv.status_code == 200
+    rv.close()
+
+
+def test_static_folder_with_pathlib_path(app):
+    from pathlib import Path
+
+    app = flask.Flask(__name__, static_folder=Path("static"))
+    rv = app.test_client().open("/static/index.html", method="GET")
+    assert rv.status_code == 200
+    rv.close()
+
+
+def test_static_folder_with_ending_slash():
+    app = flask.Flask(__name__, static_folder="static/")
+
+    @app.route("/<path:path>")
+    def catch_all(path):
+        return path
+
+    rv = app.test_client().get("/catch/all")
+    assert rv.data == b"catch/all"
+
+
+def test_static_route_with_host_matching():
+    app = flask.Flask(__name__, host_matching=True, static_host="example.com")
+    c = app.test_client()
+    rv = c.get("http://example.com/static/index.html")
+    assert rv.status_code == 200
+    rv.close()
+    with app.test_request_context():
+        rv = flask.url_for("static", filename="index.html", _external=True)
+        assert rv == "http://example.com/static/index.html"
+    # Providing static_host without host_matching=True should error.
+    with pytest.raises(AssertionError):
+        flask.Flask(__name__, static_host="example.com")
+    # Providing host_matching=True with static_folder
+    # but without static_host should error.
+    with pytest.raises(AssertionError):
+        flask.Flask(__name__, host_matching=True)
+    # Providing host_matching=True without static_host
+    # but with static_folder=None should not error.
+    flask.Flask(__name__, host_matching=True, static_folder=None)
+
+
+def test_request_locals():
+    assert repr(flask.g) == "<LocalProxy unbound>"
+    assert not flask.g
+
+
+@pytest.mark.parametrize(
+    ("subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"),
+    [
+        (False, False, "default", "default", "default"),
+        (True, False, "default", "abc", "<invalid>"),
+        (False, True, "default", "abc", "default"),
+    ],
+)
+def test_server_name_matching(
+    subdomain_matching: bool,
+    host_matching: bool,
+    expect_base: str,
+    expect_abc: str,
+    expect_xyz: str,
+) -> None:
+    app = flask.Flask(
+        __name__,
+        subdomain_matching=subdomain_matching,
+        host_matching=host_matching,
+        static_host="example.test" if host_matching else None,
+    )
+    app.config["SERVER_NAME"] = "example.test"
+
+    @app.route("/", defaults={"name": "default"}, host="<name>")
+    @app.route("/", subdomain="<name>", host="<name>.example.test")
+    def index(name: str) -> str:
+        return name
+
+    client = app.test_client()
+
+    r = client.get(base_url="http://example.test")
+    assert r.text == expect_base
+
+    r = client.get(base_url="http://abc.example.test")
+    assert r.text == expect_abc
+
+    with pytest.warns() if subdomain_matching else nullcontext():
+        r = client.get(base_url="http://xyz.other.test")
+
+    assert r.text == expect_xyz
+
+
+def test_server_name_subdomain():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    client = app.test_client()
+
+    @app.route("/")
+    def index():
+        return "default"
+
+    @app.route("/", subdomain="foo")
+    def subdomain():
+        return "subdomain"
+
+    app.config["SERVER_NAME"] = "dev.local:5000"
+    rv = client.get("/")
+    assert rv.data == b"default"
+
+    rv = client.get("/", "http://dev.local:5000")
+    assert rv.data == b"default"
+
+    rv = client.get("/", "https://dev.local:5000")
+    assert rv.data == b"default"
+
+    app.config["SERVER_NAME"] = "dev.local:443"
+    rv = client.get("/", "https://dev.local")
+
+    # Werkzeug 1.0 fixes matching https scheme with 443 port
+    if rv.status_code != 404:
+        assert rv.data == b"default"
+
+    app.config["SERVER_NAME"] = "dev.local"
+    rv = client.get("/", "https://dev.local")
+    assert rv.data == b"default"
+
+    # suppress Werkzeug 0.15 warning about name mismatch
+    with warnings.catch_warnings():
+        warnings.filterwarnings(
+            "ignore", "Current server name", UserWarning, "flask.app"
+        )
+        rv = client.get("/", "http://foo.localhost")
+        assert rv.status_code == 404
+
+    rv = client.get("/", "http://foo.dev.local")
+    assert rv.data == b"subdomain"
+
+
+@pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
+def test_exception_propagation(app, client, key):
+    app.testing = False
+
+    @app.route("/")
+    def index():
+        raise ZeroDivisionError
+
+    if key is not None:
+        app.config[key] = True
+
+        with pytest.raises(ZeroDivisionError):
+            client.get("/")
+    else:
+        assert client.get("/").status_code == 500
+
+
+@pytest.mark.parametrize("debug", [True, False])
+@pytest.mark.parametrize("use_debugger", [True, False])
+@pytest.mark.parametrize("use_reloader", [True, False])
+@pytest.mark.parametrize("propagate_exceptions", [None, True, False])
+def test_werkzeug_passthrough_errors(
+    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app
+):
+    rv = {}
+
+    # Mocks werkzeug.serving.run_simple method
+    def run_simple_mock(*args, **kwargs):
+        rv["passthrough_errors"] = kwargs.get("passthrough_errors")
+
+    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
+    app.config["PROPAGATE_EXCEPTIONS"] = propagate_exceptions
+    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)
+
+
+def test_url_processors(app, client):
+    @app.url_defaults
+    def add_language_code(endpoint, values):
+        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(
+            endpoint, "lang_code"
+        ):
+            values.setdefault("lang_code", flask.g.lang_code)
+
+    @app.url_value_preprocessor
+    def pull_lang_code(endpoint, values):
+        flask.g.lang_code = values.pop("lang_code", None)
+
+    @app.route("/<lang_code>/")
+    def index():
+        return flask.url_for("about")
+
+    @app.route("/<lang_code>/about")
+    def about():
+        return flask.url_for("something_else")
+
+    @app.route("/foo")
+    def something_else():
+        return flask.url_for("about", lang_code="en")
+
+    assert client.get("/de/").data == b"/de/about"
+    assert client.get("/de/about").data == b"/foo"
+    assert client.get("/foo").data == b"/en/about"
+
+
+def test_inject_blueprint_url_defaults(app):
+    bp = flask.Blueprint("foo", __name__, template_folder="template")
+
+    @bp.url_defaults
+    def bp_defaults(endpoint, values):
+        values["page"] = "login"
+
+    @bp.route("/<page>")
+    def view(page):
+        pass
+
+    app.register_blueprint(bp)
+
+    values = dict()
+    app.inject_url_defaults("foo.view", values)
+    expected = dict(page="login")
+    assert values == expected
+
+    with app.test_request_context("/somepage"):
+        url = flask.url_for("foo.view")
+    expected = "/login"
+    assert url == expected
+
+
+def test_nonascii_pathinfo(app, client):
+    @app.route("/╨║╨╕╤Ç╤é╨╡╤ü╤é")
+    def index():
+        return "Hello World!"
+
+    rv = client.get("/╨║╨╕╤Ç╤é╨╡╤ü╤é")
+    assert rv.data == b"Hello World!"
+
+
+def test_no_setup_after_first_request(app, client):
+    app.debug = True
+
+    @app.route("/")
+    def index():
+        return "Awesome"
+
+    assert client.get("/").data == b"Awesome"
+
+    with pytest.raises(AssertionError) as exc_info:
+        app.add_url_rule("/foo", endpoint="late")
+
+    assert "setup method 'add_url_rule'" in str(exc_info.value)
+
+
+def test_routing_redirect_debugging(monkeypatch, app, client):
+    app.config["DEBUG"] = True
+
+    @app.route("/user/", methods=["GET", "POST"])
+    def user():
+        return flask.request.form["status"]
+
+    # default redirect code preserves form data
+    rv = client.post("/user", data={"status": "success"}, follow_redirects=True)
+    assert rv.data == b"success"
+
+    # 301 and 302 raise error
+    monkeypatch.setattr(RequestRedirect, "code", 301)
+
+    with client, pytest.raises(AssertionError) as exc_info:
+        client.post("/user", data={"status": "error"}, follow_redirects=True)
+
+    assert "canonical URL 'http://localhost/user/'" in str(exc_info.value)
+
+
+def test_route_decorator_custom_endpoint(app, client):
+    app.debug = True
+
+    @app.route("/foo/")
+    def foo():
+        return flask.request.endpoint
+
+    @app.route("/bar/", endpoint="bar")
+    def for_bar():
+        return flask.request.endpoint
+
+    @app.route("/bar/123", endpoint="123")
+    def for_bar_foo():
+        return flask.request.endpoint
+
+    with app.test_request_context():
+        assert flask.url_for("foo") == "/foo/"
+        assert flask.url_for("bar") == "/bar/"
+        assert flask.url_for("123") == "/bar/123"
+
+    assert client.get("/foo/").data == b"foo"
+    assert client.get("/bar/").data == b"bar"
+    assert client.get("/bar/123").data == b"123"
+
+
+def test_get_method_on_g(app_ctx):
+    assert flask.g.get("x") is None
+    assert flask.g.get("x", 11) == 11
+    flask.g.x = 42
+    assert flask.g.get("x") == 42
+    assert flask.g.x == 42
+
+
+def test_g_iteration_protocol(app_ctx):
+    flask.g.foo = 23
+    flask.g.bar = 42
+    assert "foo" in flask.g
+    assert "foos" not in flask.g
+    assert sorted(flask.g) == ["bar", "foo"]
+
+
+def test_subdomain_basic_support():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    app.config["SERVER_NAME"] = "localhost.localdomain"
+    client = app.test_client()
+
+    @app.route("/")
+    def normal_index():
+        return "normal index"
+
+    @app.route("/", subdomain="test")
+    def test_index():
+        return "test index"
+
+    rv = client.get("/", "http://localhost.localdomain/")
+    assert rv.data == b"normal index"
+
+    rv = client.get("/", "http://test.localhost.localdomain/")
+    assert rv.data == b"test index"
+
+
+def test_subdomain_matching():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    client = app.test_client()
+    app.config["SERVER_NAME"] = "localhost.localdomain"
+
+    @app.route("/", subdomain="<user>")
+    def index(user):
+        return f"index for {user}"
+
+    rv = client.get("/", "http://mitsuhiko.localhost.localdomain/")
+    assert rv.data == b"index for mitsuhiko"
+
+
+def test_subdomain_matching_with_ports():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    app.config["SERVER_NAME"] = "localhost.localdomain:3000"
+    client = app.test_client()
+
+    @app.route("/", subdomain="<user>")
+    def index(user):
+        return f"index for {user}"
+
+    rv = client.get("/", "http://mitsuhiko.localhost.localdomain:3000/")
+    assert rv.data == b"index for mitsuhiko"
+
+
+@pytest.mark.parametrize("matching", (False, True))
+def test_subdomain_matching_other_name(matching):
+    app = flask.Flask(__name__, subdomain_matching=matching)
+    app.config["SERVER_NAME"] = "localhost.localdomain:3000"
+    client = app.test_client()
+
+    @app.route("/")
+    def index():
+        return "", 204
+
+    # suppress Werkzeug 0.15 warning about name mismatch
+    with warnings.catch_warnings():
+        warnings.filterwarnings(
+            "ignore", "Current server name", UserWarning, "flask.app"
+        )
+        # ip address can't match name
+        rv = client.get("/", "http://127.0.0.1:3000/")
+        assert rv.status_code == 404 if matching else 204
+
+    # allow all subdomains if matching is disabled
+    rv = client.get("/", "http://www.localhost.localdomain:3000/")
+    assert rv.status_code == 404 if matching else 204
+
+
+def test_multi_route_rules(app, client):
+    @app.route("/")
+    @app.route("/<test>/")
+    def index(test="a"):
+        return test
+
+    rv = client.open("/")
+    assert rv.data == b"a"
+    rv = client.open("/b/")
+    assert rv.data == b"b"
+
+
+def test_multi_route_class_views(app, client):
+    class View:
+        def __init__(self, app):
+            app.add_url_rule("/", "index", self.index)
+            app.add_url_rule("/<test>/", "index", self.index)
+
+        def index(self, test="a"):
+            return test
+
+    _ = View(app)
+    rv = client.open("/")
+    assert rv.data == b"a"
+    rv = client.open("/b/")
+    assert rv.data == b"b"
+
+
+def test_run_defaults(monkeypatch, app):
+    rv = {}
+
+    # Mocks werkzeug.serving.run_simple method
+    def run_simple_mock(*args, **kwargs):
+        rv["result"] = "running..."
+
+    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
+    app.run()
+    assert rv["result"] == "running..."
+
+
+def test_run_server_port(monkeypatch, app):
+    rv = {}
+
+    # Mocks werkzeug.serving.run_simple method
+    def run_simple_mock(hostname, port, application, *args, **kwargs):
+        rv["result"] = f"running on {hostname}:{port} ..."
+
+    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
+    hostname, port = "localhost", 8000
+    app.run(hostname, port, debug=True)
+    assert rv["result"] == f"running on {hostname}:{port} ..."
+
+
+@pytest.mark.parametrize(
+    "host,port,server_name,expect_host,expect_port",
+    (
+        (None, None, "pocoo.org:8080", "pocoo.org", 8080),
+        ("localhost", None, "pocoo.org:8080", "localhost", 8080),
+        (None, 80, "pocoo.org:8080", "pocoo.org", 80),
+        ("localhost", 80, "pocoo.org:8080", "localhost", 80),
+        ("localhost", 0, "localhost:8080", "localhost", 0),
+        (None, None, "localhost:8080", "localhost", 8080),
+        (None, None, "localhost:0", "localhost", 0),
+    ),
+)
+def test_run_from_config(
+    monkeypatch, host, port, server_name, expect_host, expect_port, app
+):
+    def run_simple_mock(hostname, port, *args, **kwargs):
+        assert hostname == expect_host
+        assert port == expect_port
+
+    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple_mock)
+    app.config["SERVER_NAME"] = server_name
+    app.run(host, port)
+
+
+def test_max_cookie_size(app, client, recwarn):
+    app.config["MAX_COOKIE_SIZE"] = 100
+
+    # outside app context, default to Werkzeug static value,
+    # which is also the default config
+    response = flask.Response()
+    default = flask.Flask.default_config["MAX_COOKIE_SIZE"]
+    assert response.max_cookie_size == default
+
+    # inside app context, use app config
+    with app.app_context():
+        assert flask.Response().max_cookie_size == 100
+
+    @app.route("/")
+    def index():
+        r = flask.Response("", status=204)
+        r.set_cookie("foo", "bar" * 100)
+        return r
+
+    client.get("/")
+    assert len(recwarn) == 1
+    w = recwarn.pop()
+    assert "cookie is too large" in str(w.message)
+
+    app.config["MAX_COOKIE_SIZE"] = 0
+
+    client.get("/")
+    assert len(recwarn) == 0
+
+
+@require_cpython_gc
+def test_app_freed_on_zero_refcount():
+    # A Flask instance should not create a reference cycle that prevents CPython
+    # from freeing it when all external references to it are released (see #3761).
+    gc.disable()
+    try:
+        app = flask.Flask(__name__)
+        assert app.view_functions["static"]
+        weak = weakref.ref(app)
+        assert weak() is not None
+        del app
+        assert weak() is None
+    finally:
+        gc.enable()
diff --git b/tests/test_cli.py a/tests/test_cli.py
new file mode 100644
index 0000000..06af360
--- /dev/null
+++ a/tests/test_cli.py
@@ -0,0 +1,686 @@
+# This file was part of Flask-CLI and was modified under the terms of
+# its Revised BSD License. Copyright ┬⌐ 2015 CERN.
+import importlib.metadata
+import os
+import platform
+import ssl
+import sys
+import types
+from functools import partial
+from pathlib import Path
+
+import click
+import pytest
+from _pytest.monkeypatch import notset
+from click.testing import CliRunner
+
+from flask import Blueprint
+from flask import current_app
+from flask import Flask
+from flask.cli import AppGroup
+from flask.cli import find_best_app
+from flask.cli import FlaskGroup
+from flask.cli import get_version
+from flask.cli import load_dotenv
+from flask.cli import locate_app
+from flask.cli import NoAppException
+from flask.cli import prepare_import
+from flask.cli import run_command
+from flask.cli import ScriptInfo
+from flask.cli import with_appcontext
+
+cwd = Path.cwd()
+test_path = (Path(__file__) / ".." / "test_apps").resolve()
+
+
+@pytest.fixture
+def runner():
+    return CliRunner()
+
+
+def test_cli_name(test_apps):
+    """Make sure the CLI object's name is the app's name and not the app itself"""
+    from cliapp.app import testapp
+
+    assert testapp.cli.name == testapp.name
+
+
+def test_find_best_app(test_apps):
+    class Module:
+        app = Flask("appname")
+
+    assert find_best_app(Module) == Module.app
+
+    class Module:
+        application = Flask("appname")
+
+    assert find_best_app(Module) == Module.application
+
+    class Module:
+        myapp = Flask("appname")
+
+    assert find_best_app(Module) == Module.myapp
+
+    class Module:
+        @staticmethod
+        def create_app():
+            return Flask("appname")
+
+    app = find_best_app(Module)
+    assert isinstance(app, Flask)
+    assert app.name == "appname"
+
+    class Module:
+        @staticmethod
+        def create_app(**kwargs):
+            return Flask("appname")
+
+    app = find_best_app(Module)
+    assert isinstance(app, Flask)
+    assert app.name == "appname"
+
+    class Module:
+        @staticmethod
+        def make_app():
+            return Flask("appname")
+
+    app = find_best_app(Module)
+    assert isinstance(app, Flask)
+    assert app.name == "appname"
+
+    class Module:
+        myapp = Flask("appname1")
+
+        @staticmethod
+        def create_app():
+            return Flask("appname2")
+
+    assert find_best_app(Module) == Module.myapp
+
+    class Module:
+        myapp = Flask("appname1")
+
+        @staticmethod
+        def create_app():
+            return Flask("appname2")
+
+    assert find_best_app(Module) == Module.myapp
+
+    class Module:
+        pass
+
+    pytest.raises(NoAppException, find_best_app, Module)
+
+    class Module:
+        myapp1 = Flask("appname1")
+        myapp2 = Flask("appname2")
+
+    pytest.raises(NoAppException, find_best_app, Module)
+
+    class Module:
+        @staticmethod
+        def create_app(foo, bar):
+            return Flask("appname2")
+
+    pytest.raises(NoAppException, find_best_app, Module)
+
+    class Module:
+        @staticmethod
+        def create_app():
+            raise TypeError("bad bad factory!")
+
+    pytest.raises(TypeError, find_best_app, Module)
+
+
+@pytest.mark.parametrize(
+    "value,path,result",
+    (
+        ("test", cwd, "test"),
+        ("test.py", cwd, "test"),
+        ("a/test", cwd / "a", "test"),
+        ("test/__init__.py", cwd, "test"),
+        ("test/__init__", cwd, "test"),
+        # nested package
+        (
+            test_path / "cliapp" / "inner1" / "__init__",
+            test_path,
+            "cliapp.inner1",
+        ),
+        (
+            test_path / "cliapp" / "inner1" / "inner2",
+            test_path,
+            "cliapp.inner1.inner2",
+        ),
+        # dotted name
+        ("test.a.b", cwd, "test.a.b"),
+        (test_path / "cliapp.app", test_path, "cliapp.app"),
+        # not a Python file, will be caught during import
+        (test_path / "cliapp" / "message.txt", test_path, "cliapp.message.txt"),
+    ),
+)
+def test_prepare_import(request, value, path, result):
+    """Expect the correct path to be set and the correct import and app names
+    to be returned.
+
+    :func:`prepare_exec_for_file` has a side effect where the parent directory
+    of the given import is added to :data:`sys.path`. This is reset after the
+    test runs.
+    """
+    original_path = sys.path[:]
+
+    def reset_path():
+        sys.path[:] = original_path
+
+    request.addfinalizer(reset_path)
+
+    assert prepare_import(value) == result
+    assert sys.path[0] == str(path)
+
+
+@pytest.mark.parametrize(
+    "iname,aname,result",
+    (
+        ("cliapp.app", None, "testapp"),
+        ("cliapp.app", "testapp", "testapp"),
+        ("cliapp.factory", None, "app"),
+        ("cliapp.factory", "create_app", "app"),
+        ("cliapp.factory", "create_app()", "app"),
+        ("cliapp.factory", 'create_app2("foo", "bar")', "app2_foo_bar"),
+        # trailing comma space
+        ("cliapp.factory", 'create_app2("foo", "bar", )', "app2_foo_bar"),
+        # strip whitespace
+        ("cliapp.factory", " create_app () ", "app"),
+    ),
+)
+def test_locate_app(test_apps, iname, aname, result):
+    assert locate_app(iname, aname).name == result
+
+
+@pytest.mark.parametrize(
+    "iname,aname",
+    (
+        ("notanapp.py", None),
+        ("cliapp/app", None),
+        ("cliapp.app", "notanapp"),
+        # not enough arguments
+        ("cliapp.factory", 'create_app2("foo")'),
+        # invalid identifier
+        ("cliapp.factory", "create_app("),
+        # no app returned
+        ("cliapp.factory", "no_app"),
+        # nested import error
+        ("cliapp.importerrorapp", None),
+        # not a Python file
+        ("cliapp.message.txt", None),
+    ),
+)
+def test_locate_app_raises(test_apps, iname, aname):
+    with pytest.raises(NoAppException):
+        locate_app(iname, aname)
+
+
+def test_locate_app_suppress_raise(test_apps):
+    app = locate_app("notanapp.py", None, raise_if_not_found=False)
+    assert app is None
+
+    # only direct import error is suppressed
+    with pytest.raises(NoAppException):
+        locate_app("cliapp.importerrorapp", None, raise_if_not_found=False)
+
+
+def test_scriptinfo(test_apps, monkeypatch):
+    obj = ScriptInfo(app_import_path="cliapp.app:testapp")
+    app = obj.load_app()
+    assert app.name == "testapp"
+    assert obj.load_app() is app
+
+    # import app with module's absolute path
+    cli_app_path = str(test_path / "cliapp" / "app.py")
+
+    obj = ScriptInfo(app_import_path=cli_app_path)
+    app = obj.load_app()
+    assert app.name == "testapp"
+    assert obj.load_app() is app
+    obj = ScriptInfo(app_import_path=f"{cli_app_path}:testapp")
+    app = obj.load_app()
+    assert app.name == "testapp"
+    assert obj.load_app() is app
+
+    def create_app():
+        return Flask("createapp")
+
+    obj = ScriptInfo(create_app=create_app)
+    app = obj.load_app()
+    assert app.name == "createapp"
+    assert obj.load_app() is app
+
+    obj = ScriptInfo()
+    pytest.raises(NoAppException, obj.load_app)
+
+    # import app from wsgi.py in current directory
+    monkeypatch.chdir(test_path / "helloworld")
+    obj = ScriptInfo()
+    app = obj.load_app()
+    assert app.name == "hello"
+
+    # import app from app.py in current directory
+    monkeypatch.chdir(test_path / "cliapp")
+    obj = ScriptInfo()
+    app = obj.load_app()
+    assert app.name == "testapp"
+
+
+def test_app_cli_has_app_context(app, runner):
+    def _param_cb(ctx, param, value):
+        # current_app should be available in parameter callbacks
+        return bool(current_app)
+
+    @app.cli.command()
+    @click.argument("value", callback=_param_cb)
+    def check(value):
+        app = click.get_current_context().obj.load_app()
+        # the loaded app should be the same as current_app
+        same_app = current_app._get_current_object() is app
+        return same_app, value
+
+    cli = FlaskGroup(create_app=lambda: app)
+    result = runner.invoke(cli, ["check", "x"], standalone_mode=False)
+    assert result.return_value == (True, True)
+
+
+def test_with_appcontext(runner):
+    @click.command()
+    @with_appcontext
+    def testcmd():
+        click.echo(current_app.name)
+
+    obj = ScriptInfo(create_app=lambda: Flask("testapp"))
+
+    result = runner.invoke(testcmd, obj=obj)
+    assert result.exit_code == 0
+    assert result.output == "testapp\n"
+
+
+def test_appgroup_app_context(runner):
+    @click.group(cls=AppGroup)
+    def cli():
+        pass
+
+    @cli.command()
+    def test():
+        click.echo(current_app.name)
+
+    @cli.group()
+    def subgroup():
+        pass
+
+    @subgroup.command()
+    def test2():
+        click.echo(current_app.name)
+
+    obj = ScriptInfo(create_app=lambda: Flask("testappgroup"))
+
+    result = runner.invoke(cli, ["test"], obj=obj)
+    assert result.exit_code == 0
+    assert result.output == "testappgroup\n"
+
+    result = runner.invoke(cli, ["subgroup", "test2"], obj=obj)
+    assert result.exit_code == 0
+    assert result.output == "testappgroup\n"
+
+
+def test_flaskgroup_app_context(runner):
+    def create_app():
+        return Flask("flaskgroup")
+
+    @click.group(cls=FlaskGroup, create_app=create_app)
+    def cli(**params):
+        pass
+
+    @cli.command()
+    def test():
+        click.echo(current_app.name)
+
+    result = runner.invoke(cli, ["test"])
+    assert result.exit_code == 0
+    assert result.output == "flaskgroup\n"
+
+
+@pytest.mark.parametrize("set_debug_flag", (True, False))
+def test_flaskgroup_debug(runner, set_debug_flag):
+    def create_app():
+        app = Flask("flaskgroup")
+        app.debug = True
+        return app
+
+    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)
+    def cli(**params):
+        pass
+
+    @cli.command()
+    def test():
+        click.echo(str(current_app.debug))
+
+    result = runner.invoke(cli, ["test"])
+    assert result.exit_code == 0
+    assert result.output == f"{not set_debug_flag}\n"
+
+
+def test_flaskgroup_nested(app, runner):
+    cli = click.Group("cli")
+    flask_group = FlaskGroup(name="flask", create_app=lambda: app)
+    cli.add_command(flask_group)
+
+    @flask_group.command()
+    def show():
+        click.echo(current_app.name)
+
+    result = runner.invoke(cli, ["flask", "show"])
+    assert result.output == "flask_test\n"
+
+
+def test_no_command_echo_loading_error():
+    from flask.cli import cli
+
+    try:
+        runner = CliRunner(mix_stderr=False)
+    except (DeprecationWarning, TypeError):
+        # Click >= 8.2
+        runner = CliRunner()
+
+    result = runner.invoke(cli, ["missing"])
+    assert result.exit_code == 2
+    assert "FLASK_APP" in result.stderr
+    assert "Usage:" in result.stderr
+
+
+def test_help_echo_loading_error():
+    from flask.cli import cli
+
+    try:
+        runner = CliRunner(mix_stderr=False)
+    except (DeprecationWarning, TypeError):
+        # Click >= 8.2
+        runner = CliRunner()
+
+    result = runner.invoke(cli, ["--help"])
+    assert result.exit_code == 0
+    assert "FLASK_APP" in result.stderr
+    assert "Usage:" in result.stdout
+
+
+def test_help_echo_exception():
+    def create_app():
+        raise Exception("oh no")
+
+    cli = FlaskGroup(create_app=create_app)
+
+    try:
+        runner = CliRunner(mix_stderr=False)
+    except (DeprecationWarning, TypeError):
+        # Click >= 8.2
+        runner = CliRunner()
+
+    result = runner.invoke(cli, ["--help"])
+    assert result.exit_code == 0
+    assert "Exception: oh no" in result.stderr
+    assert "Usage:" in result.stdout
+
+
+class TestRoutes:
+    @pytest.fixture
+    def app(self):
+        app = Flask(__name__)
+        app.add_url_rule(
+            "/get_post/<int:x>/<int:y>",
+            methods=["GET", "POST"],
+            endpoint="yyy_get_post",
+        )
+        app.add_url_rule("/zzz_post", methods=["POST"], endpoint="aaa_post")
+        return app
+
+    @pytest.fixture
+    def invoke(self, app, runner):
+        cli = FlaskGroup(create_app=lambda: app)
+        return partial(runner.invoke, cli)
+
+    def expect_order(self, order, output):
+        # skip the header and match the start of each row
+        for expect, line in zip(order, output.splitlines()[2:]):
+            # do this instead of startswith for nicer pytest output
+            assert line[: len(expect)] == expect
+
+    def test_simple(self, invoke):
+        result = invoke(["routes"])
+        assert result.exit_code == 0
+        self.expect_order(["aaa_post", "static", "yyy_get_post"], result.output)
+
+    def test_sort(self, app, invoke):
+        default_output = invoke(["routes"]).output
+        endpoint_output = invoke(["routes", "-s", "endpoint"]).output
+        assert default_output == endpoint_output
+        self.expect_order(
+            ["static", "yyy_get_post", "aaa_post"],
+            invoke(["routes", "-s", "methods"]).output,
+        )
+        self.expect_order(
+            ["yyy_get_post", "static", "aaa_post"],
+            invoke(["routes", "-s", "rule"]).output,
+        )
+        match_order = [r.endpoint for r in app.url_map.iter_rules()]
+        self.expect_order(match_order, invoke(["routes", "-s", "match"]).output)
+
+    def test_all_methods(self, invoke):
+        output = invoke(["routes"]).output
+        assert "GET, HEAD, OPTIONS, POST" not in output
+        output = invoke(["routes", "--all-methods"]).output
+        assert "GET, HEAD, OPTIONS, POST" in output
+
+    def test_no_routes(self, runner):
+        app = Flask(__name__, static_folder=None)
+        cli = FlaskGroup(create_app=lambda: app)
+        result = runner.invoke(cli, ["routes"])
+        assert result.exit_code == 0
+        assert "No routes were registered." in result.output
+
+    def test_subdomain(self, runner):
+        app = Flask(__name__, static_folder=None)
+        app.add_url_rule("/a", subdomain="a", endpoint="a")
+        app.add_url_rule("/b", subdomain="b", endpoint="b")
+        cli = FlaskGroup(create_app=lambda: app)
+        result = runner.invoke(cli, ["routes"])
+        assert result.exit_code == 0
+        assert "Subdomain" in result.output
+
+    def test_host(self, runner):
+        app = Flask(__name__, static_folder=None, host_matching=True)
+        app.add_url_rule("/a", host="a", endpoint="a")
+        app.add_url_rule("/b", host="b", endpoint="b")
+        cli = FlaskGroup(create_app=lambda: app)
+        result = runner.invoke(cli, ["routes"])
+        assert result.exit_code == 0
+        assert "Host" in result.output
+
+
+def dotenv_not_available():
+    try:
+        import dotenv  # noqa: F401
+    except ImportError:
+        return True
+
+    return False
+
+
+need_dotenv = pytest.mark.skipif(
+    dotenv_not_available(), reason="dotenv is not installed"
+)
+
+
+@need_dotenv
+def test_load_dotenv(monkeypatch):
+    # can't use monkeypatch.delitem since the keys don't exist yet
+    for item in ("FOO", "BAR", "SPAM", "HAM"):
+        monkeypatch._setitem.append((os.environ, item, notset))
+
+    monkeypatch.setenv("EGGS", "3")
+    monkeypatch.chdir(test_path)
+    assert load_dotenv()
+    assert Path.cwd() == test_path
+    # .flaskenv doesn't overwrite .env
+    assert os.environ["FOO"] == "env"
+    # set only in .flaskenv
+    assert os.environ["BAR"] == "bar"
+    # set only in .env
+    assert os.environ["SPAM"] == "1"
+    # set manually, files don't overwrite
+    assert os.environ["EGGS"] == "3"
+    # test env file encoding
+    assert os.environ["HAM"] == "τü½Φà┐"
+    # Non existent file should not load
+    assert not load_dotenv("non-existent-file", load_defaults=False)
+
+
+@need_dotenv
+def test_dotenv_path(monkeypatch):
+    for item in ("FOO", "BAR", "EGGS"):
+        monkeypatch._setitem.append((os.environ, item, notset))
+
+    load_dotenv(test_path / ".flaskenv")
+    assert Path.cwd() == cwd
+    assert "FOO" in os.environ
+
+
+def test_dotenv_optional(monkeypatch):
+    monkeypatch.setitem(sys.modules, "dotenv", None)
+    monkeypatch.chdir(test_path)
+    load_dotenv()
+    assert "FOO" not in os.environ
+
+
+@need_dotenv
+def test_disable_dotenv_from_env(monkeypatch, runner):
+    monkeypatch.chdir(test_path)
+    monkeypatch.setitem(os.environ, "FLASK_SKIP_DOTENV", "1")
+    runner.invoke(FlaskGroup())
+    assert "FOO" not in os.environ
+
+
+def test_run_cert_path():
+    # no key
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", __file__])
+
+    # no cert
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--key", __file__])
+
+    # cert specified first
+    ctx = run_command.make_context("run", ["--cert", __file__, "--key", __file__])
+    assert ctx.params["cert"] == (__file__, __file__)
+
+    # key specified first
+    ctx = run_command.make_context("run", ["--key", __file__, "--cert", __file__])
+    assert ctx.params["cert"] == (__file__, __file__)
+
+
+def test_run_cert_adhoc(monkeypatch):
+    monkeypatch.setitem(sys.modules, "cryptography", None)
+
+    # cryptography not installed
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "adhoc"])
+
+    # cryptography installed
+    monkeypatch.setitem(sys.modules, "cryptography", types.ModuleType("cryptography"))
+    ctx = run_command.make_context("run", ["--cert", "adhoc"])
+    assert ctx.params["cert"] == "adhoc"
+
+    # no key with adhoc
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "adhoc", "--key", __file__])
+
+
+def test_run_cert_import(monkeypatch):
+    monkeypatch.setitem(sys.modules, "not_here", None)
+
+    # ImportError
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "not_here"])
+
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "flask"])
+
+    # SSLContext
+    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
+
+    monkeypatch.setitem(sys.modules, "ssl_context", ssl_context)
+    ctx = run_command.make_context("run", ["--cert", "ssl_context"])
+    assert ctx.params["cert"] is ssl_context
+
+    # no --key with SSLContext
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "ssl_context", "--key", __file__])
+
+
+def test_run_cert_no_ssl(monkeypatch):
+    monkeypatch.setitem(sys.modules, "ssl", None)
+
+    with pytest.raises(click.BadParameter):
+        run_command.make_context("run", ["--cert", "not_here"])
+
+
+def test_cli_blueprints(app):
+    """Test blueprint commands register correctly to the application"""
+    custom = Blueprint("custom", __name__, cli_group="customized")
+    nested = Blueprint("nested", __name__)
+    merged = Blueprint("merged", __name__, cli_group=None)
+    late = Blueprint("late", __name__)
+
+    @custom.cli.command("custom")
+    def custom_command():
+        click.echo("custom_result")
+
+    @nested.cli.command("nested")
+    def nested_command():
+        click.echo("nested_result")
+
+    @merged.cli.command("merged")
+    def merged_command():
+        click.echo("merged_result")
+
+    @late.cli.command("late")
+    def late_command():
+        click.echo("late_result")
+
+    app.register_blueprint(custom)
+    app.register_blueprint(nested)
+    app.register_blueprint(merged)
+    app.register_blueprint(late, cli_group="late_registration")
+
+    app_runner = app.test_cli_runner()
+
+    result = app_runner.invoke(args=["customized", "custom"])
+    assert "custom_result" in result.output
+
+    result = app_runner.invoke(args=["nested", "nested"])
+    assert "nested_result" in result.output
+
+    result = app_runner.invoke(args=["merged"])
+    assert "merged_result" in result.output
+
+    result = app_runner.invoke(args=["late_registration", "late"])
+    assert "late_result" in result.output
+
+
+def test_cli_empty(app):
+    """If a Blueprint's CLI group is empty, do not register it."""
+    bp = Blueprint("blue", __name__, cli_group="blue")
+    app.register_blueprint(bp)
+
+    result = app.test_cli_runner().invoke(args=["blue", "--help"])
+    assert result.exit_code == 2, f"Unexpected success:\n\n{result.output}"
+
+
+def test_run_exclude_patterns():
+    ctx = run_command.make_context("run", ["--exclude-patterns", __file__])
+    assert ctx.params["exclude_patterns"] == [__file__]
diff --git b/tests/test_helpers.py a/tests/test_helpers.py
new file mode 100644
index 0000000..ee77f17
--- /dev/null
+++ a/tests/test_helpers.py
@@ -0,0 +1,360 @@
+import io
+import os
+
+import pytest
+import werkzeug.exceptions
+
+import flask
+from flask.helpers import get_debug_flag
+
+
+class FakePath:
+    """Fake object to represent a ``PathLike object``.
+
+    This represents a ``pathlib.Path`` object in python 3.
+    See: https://www.python.org/dev/peps/pep-0519/
+    """
+
+    def __init__(self, path):
+        self.path = path
+
+    def __fspath__(self):
+        return self.path
+
+
+class PyBytesIO:
+    def __init__(self, *args, **kwargs):
+        self._io = io.BytesIO(*args, **kwargs)
+
+    def __getattr__(self, name):
+        return getattr(self._io, name)
+
+
+class TestSendfile:
+    def test_send_file(self, app, req_ctx):
+        rv = flask.send_file("static/index.html")
+        assert rv.direct_passthrough
+        assert rv.mimetype == "text/html"
+
+        with app.open_resource("static/index.html") as f:
+            rv.direct_passthrough = False
+            assert rv.data == f.read()
+
+        rv.close()
+
+    def test_static_file(self, app, req_ctx):
+        # Default max_age is None.
+
+        # Test with static file handler.
+        rv = app.send_static_file("index.html")
+        assert rv.cache_control.max_age is None
+        rv.close()
+
+        # Test with direct use of send_file.
+        rv = flask.send_file("static/index.html")
+        assert rv.cache_control.max_age is None
+        rv.close()
+
+        app.config["SEND_FILE_MAX_AGE_DEFAULT"] = 3600
+
+        # Test with static file handler.
+        rv = app.send_static_file("index.html")
+        assert rv.cache_control.max_age == 3600
+        rv.close()
+
+        # Test with direct use of send_file.
+        rv = flask.send_file("static/index.html")
+        assert rv.cache_control.max_age == 3600
+        rv.close()
+
+        # Test with pathlib.Path.
+        rv = app.send_static_file(FakePath("index.html"))
+        assert rv.cache_control.max_age == 3600
+        rv.close()
+
+        class StaticFileApp(flask.Flask):
+            def get_send_file_max_age(self, filename):
+                return 10
+
+        app = StaticFileApp(__name__)
+
+        with app.test_request_context():
+            # Test with static file handler.
+            rv = app.send_static_file("index.html")
+            assert rv.cache_control.max_age == 10
+            rv.close()
+
+            # Test with direct use of send_file.
+            rv = flask.send_file("static/index.html")
+            assert rv.cache_control.max_age == 10
+            rv.close()
+
+    def test_send_from_directory(self, app, req_ctx):
+        app.root_path = os.path.join(
+            os.path.dirname(__file__), "test_apps", "subdomaintestmodule"
+        )
+        rv = flask.send_from_directory("static", "hello.txt")
+        rv.direct_passthrough = False
+        assert rv.data.strip() == b"Hello Subdomain"
+        rv.close()
+
+
+class TestUrlFor:
+    def test_url_for_with_anchor(self, app, req_ctx):
+        @app.route("/")
+        def index():
+            return "42"
+
+        assert flask.url_for("index", _anchor="x y") == "/#x%20y"
+
+    def test_url_for_with_scheme(self, app, req_ctx):
+        @app.route("/")
+        def index():
+            return "42"
+
+        assert (
+            flask.url_for("index", _external=True, _scheme="https")
+            == "https://localhost/"
+        )
+
+    def test_url_for_with_scheme_not_external(self, app, req_ctx):
+        app.add_url_rule("/", endpoint="index")
+
+        # Implicit external with scheme.
+        url = flask.url_for("index", _scheme="https")
+        assert url == "https://localhost/"
+
+        # Error when external=False with scheme
+        with pytest.raises(ValueError):
+            flask.url_for("index", _scheme="https", _external=False)
+
+    def test_url_for_with_alternating_schemes(self, app, req_ctx):
+        @app.route("/")
+        def index():
+            return "42"
+
+        assert flask.url_for("index", _external=True) == "http://localhost/"
+        assert (
+            flask.url_for("index", _external=True, _scheme="https")
+            == "https://localhost/"
+        )
+        assert flask.url_for("index", _external=True) == "http://localhost/"
+
+    def test_url_with_method(self, app, req_ctx):
+        from flask.views import MethodView
+
+        class MyView(MethodView):
+            def get(self, id=None):
+                if id is None:
+                    return "List"
+                return f"Get {id:d}"
+
+            def post(self):
+                return "Create"
+
+        myview = MyView.as_view("myview")
+        app.add_url_rule("/myview/", methods=["GET"], view_func=myview)
+        app.add_url_rule("/myview/<int:id>", methods=["GET"], view_func=myview)
+        app.add_url_rule("/myview/create", methods=["POST"], view_func=myview)
+
+        assert flask.url_for("myview", _method="GET") == "/myview/"
+        assert flask.url_for("myview", id=42, _method="GET") == "/myview/42"
+        assert flask.url_for("myview", _method="POST") == "/myview/create"
+
+    def test_url_for_with_self(self, app, req_ctx):
+        @app.route("/<self>")
+        def index(self):
+            return "42"
+
+        assert flask.url_for("index", self="2") == "/2"
+
+
+def test_redirect_no_app():
+    response = flask.redirect("https://localhost", 307)
+    assert response.location == "https://localhost"
+    assert response.status_code == 307
+
+
+def test_redirect_with_app(app):
+    def redirect(location, code=302):
+        raise ValueError
+
+    app.redirect = redirect
+
+    with app.app_context(), pytest.raises(ValueError):
+        flask.redirect("other")
+
+
+def test_abort_no_app():
+    with pytest.raises(werkzeug.exceptions.Unauthorized):
+        flask.abort(401)
+
+    with pytest.raises(LookupError):
+        flask.abort(900)
+
+
+def test_app_aborter_class():
+    class MyAborter(werkzeug.exceptions.Aborter):
+        pass
+
+    class MyFlask(flask.Flask):
+        aborter_class = MyAborter
+
+    app = MyFlask(__name__)
+    assert isinstance(app.aborter, MyAborter)
+
+
+def test_abort_with_app(app):
+    class My900Error(werkzeug.exceptions.HTTPException):
+        code = 900
+
+    app.aborter.mapping[900] = My900Error
+
+    with app.app_context(), pytest.raises(My900Error):
+        flask.abort(900)
+
+
+class TestNoImports:
+    """Test Flasks are created without import.
+
+    Avoiding ``__import__`` helps create Flask instances where there are errors
+    at import time.  Those runtime errors will be apparent to the user soon
+    enough, but tools which build Flask instances meta-programmatically benefit
+    from a Flask which does not ``__import__``.  Instead of importing to
+    retrieve file paths or metadata on a module or package, use the pkgutil and
+    imp modules in the Python standard library.
+    """
+
+    def test_name_with_import_error(self, modules_tmp_path):
+        (modules_tmp_path / "importerror.py").write_text("raise NotImplementedError()")
+        try:
+            flask.Flask("importerror")
+        except NotImplementedError:
+            AssertionError("Flask(import_name) is importing import_name.")
+
+
+class TestStreaming:
+    def test_streaming_with_context(self, app, client):
+        @app.route("/")
+        def index():
+            def generate():
+                yield "Hello "
+                yield flask.request.args["name"]
+                yield "!"
+
+            return flask.Response(flask.stream_with_context(generate()))
+
+        rv = client.get("/?name=World")
+        assert rv.data == b"Hello World!"
+
+    def test_streaming_with_context_as_decorator(self, app, client):
+        @app.route("/")
+        def index():
+            @flask.stream_with_context
+            def generate(hello):
+                yield hello
+                yield flask.request.args["name"]
+                yield "!"
+
+            return flask.Response(generate("Hello "))
+
+        rv = client.get("/?name=World")
+        assert rv.data == b"Hello World!"
+
+    def test_streaming_with_context_and_custom_close(self, app, client):
+        called = []
+
+        class Wrapper:
+            def __init__(self, gen):
+                self._gen = gen
+
+            def __iter__(self):
+                return self
+
+            def close(self):
+                called.append(42)
+
+            def __next__(self):
+                return next(self._gen)
+
+            next = __next__
+
+        @app.route("/")
+        def index():
+            def generate():
+                yield "Hello "
+                yield flask.request.args["name"]
+                yield "!"
+
+            return flask.Response(flask.stream_with_context(Wrapper(generate())))
+
+        rv = client.get("/?name=World")
+        assert rv.data == b"Hello World!"
+        assert called == [42]
+
+    def test_stream_keeps_session(self, app, client):
+        @app.route("/")
+        def index():
+            flask.session["test"] = "flask"
+
+            @flask.stream_with_context
+            def gen():
+                yield flask.session["test"]
+
+            return flask.Response(gen())
+
+        rv = client.get("/")
+        assert rv.data == b"flask"
+
+
+class TestHelpers:
+    @pytest.mark.parametrize(
+        ("debug", "expect"),
+        [
+            ("", False),
+            ("0", False),
+            ("False", False),
+            ("No", False),
+            ("True", True),
+        ],
+    )
+    def test_get_debug_flag(self, monkeypatch, debug, expect):
+        monkeypatch.setenv("FLASK_DEBUG", debug)
+        assert get_debug_flag() == expect
+
+    def test_make_response(self):
+        app = flask.Flask(__name__)
+        with app.test_request_context():
+            rv = flask.helpers.make_response()
+            assert rv.status_code == 200
+            assert rv.mimetype == "text/html"
+
+            rv = flask.helpers.make_response("Hello")
+            assert rv.status_code == 200
+            assert rv.data == b"Hello"
+            assert rv.mimetype == "text/html"
+
+
+@pytest.mark.parametrize("mode", ("r", "rb", "rt"))
+def test_open_resource(mode):
+    app = flask.Flask(__name__)
+
+    with app.open_resource("static/index.html", mode) as f:
+        assert "<h1>Hello World!</h1>" in str(f.read())
+
+
+@pytest.mark.parametrize("mode", ("w", "x", "a", "r+"))
+def test_open_resource_exceptions(mode):
+    app = flask.Flask(__name__)
+
+    with pytest.raises(ValueError):
+        app.open_resource("static/index.html", mode)
+
+
+@pytest.mark.parametrize("encoding", ("utf-8", "utf-16-le"))
+def test_open_resource_with_encoding(tmp_path, encoding):
+    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))
+    (tmp_path / "test").write_text("test", encoding=encoding)
+
+    with app.open_resource("test", mode="rt", encoding=encoding) as f:
+        assert f.read() == "test"
diff --git b/tests/test_testing.py a/tests/test_testing.py
new file mode 100644
index 0000000..de05215
--- /dev/null
+++ a/tests/test_testing.py
@@ -0,0 +1,396 @@
+import importlib.metadata
+
+import click
+import pytest
+
+import flask
+from flask import appcontext_popped
+from flask.cli import ScriptInfo
+from flask.globals import _cv_request
+from flask.json import jsonify
+from flask.testing import EnvironBuilder
+from flask.testing import FlaskCliRunner
+
+
+def test_environ_defaults_from_config(app, client):
+    app.config["SERVER_NAME"] = "example.com:1234"
+    app.config["APPLICATION_ROOT"] = "/foo"
+
+    @app.route("/")
+    def index():
+        return flask.request.url
+
+    ctx = app.test_request_context()
+    assert ctx.request.url == "http://example.com:1234/foo/"
+
+    rv = client.get("/")
+    assert rv.data == b"http://example.com:1234/foo/"
+
+
+def test_environ_defaults(app, client, app_ctx, req_ctx):
+    @app.route("/")
+    def index():
+        return flask.request.url
+
+    ctx = app.test_request_context()
+    assert ctx.request.url == "http://localhost/"
+    with client:
+        rv = client.get("/")
+        assert rv.data == b"http://localhost/"
+
+
+def test_environ_base_default(app, client):
+    @app.route("/")
+    def index():
+        flask.g.remote_addr = flask.request.remote_addr
+        flask.g.user_agent = flask.request.user_agent.string
+        return ""
+
+    with client:
+        client.get("/")
+        assert flask.g.remote_addr == "127.0.0.1"
+        assert flask.g.user_agent == (
+            f"Werkzeug/{importlib.metadata.version('werkzeug')}"
+        )
+
+
+def test_environ_base_modified(app, client):
+    @app.route("/")
+    def index():
+        flask.g.remote_addr = flask.request.remote_addr
+        flask.g.user_agent = flask.request.user_agent.string
+        return ""
+
+    client.environ_base["REMOTE_ADDR"] = "192.168.0.22"
+    client.environ_base["HTTP_USER_AGENT"] = "Foo"
+
+    with client:
+        client.get("/")
+        assert flask.g.remote_addr == "192.168.0.22"
+        assert flask.g.user_agent == "Foo"
+
+
+def test_client_open_environ(app, client, request):
+    @app.route("/index")
+    def index():
+        return flask.request.remote_addr
+
+    builder = EnvironBuilder(app, path="/index", method="GET")
+    request.addfinalizer(builder.close)
+
+    rv = client.open(builder)
+    assert rv.data == b"127.0.0.1"
+
+    environ = builder.get_environ()
+    client.environ_base["REMOTE_ADDR"] = "127.0.0.2"
+    rv = client.open(environ)
+    assert rv.data == b"127.0.0.2"
+
+
+def test_specify_url_scheme(app, client):
+    @app.route("/")
+    def index():
+        return flask.request.url
+
+    ctx = app.test_request_context(url_scheme="https")
+    assert ctx.request.url == "https://localhost/"
+
+    rv = client.get("/", url_scheme="https")
+    assert rv.data == b"https://localhost/"
+
+
+def test_path_is_url(app):
+    eb = EnvironBuilder(app, "https://example.com/")
+    assert eb.url_scheme == "https"
+    assert eb.host == "example.com"
+    assert eb.script_root == ""
+    assert eb.path == "/"
+
+
+def test_environbuilder_json_dumps(app):
+    """EnvironBuilder.json_dumps() takes settings from the app."""
+    app.json.ensure_ascii = False
+    eb = EnvironBuilder(app, json="\u20ac")
+    assert eb.input_stream.read().decode("utf8") == '"\u20ac"'
+
+
+def test_blueprint_with_subdomain():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    app.config["SERVER_NAME"] = "example.com:1234"
+    app.config["APPLICATION_ROOT"] = "/foo"
+    client = app.test_client()
+
+    bp = flask.Blueprint("company", __name__, subdomain="xxx")
+
+    @bp.route("/")
+    def index():
+        return flask.request.url
+
+    app.register_blueprint(bp)
+
+    ctx = app.test_request_context("/", subdomain="xxx")
+    assert ctx.request.url == "http://xxx.example.com:1234/foo/"
+
+    with ctx:
+        assert ctx.request.blueprint == bp.name
+
+    rv = client.get("/", subdomain="xxx")
+    assert rv.data == b"http://xxx.example.com:1234/foo/"
+
+
+def test_redirect_keep_session(app, client, app_ctx):
+    @app.route("/", methods=["GET", "POST"])
+    def index():
+        if flask.request.method == "POST":
+            return flask.redirect("/getsession")
+        flask.session["data"] = "foo"
+        return "index"
+
+    @app.route("/getsession")
+    def get_session():
+        return flask.session.get("data", "<missing>")
+
+    with client:
+        rv = client.get("/getsession")
+        assert rv.data == b"<missing>"
+
+        rv = client.get("/")
+        assert rv.data == b"index"
+        assert flask.session.get("data") == "foo"
+
+        rv = client.post("/", data={}, follow_redirects=True)
+        assert rv.data == b"foo"
+        assert flask.session.get("data") == "foo"
+
+        rv = client.get("/getsession")
+        assert rv.data == b"foo"
+
+
+def test_session_transactions(app, client):
+    @app.route("/")
+    def index():
+        return str(flask.session["foo"])
+
+    with client:
+        with client.session_transaction() as sess:
+            assert len(sess) == 0
+            sess["foo"] = [42]
+            assert len(sess) == 1
+        rv = client.get("/")
+        assert rv.data == b"[42]"
+        with client.session_transaction() as sess:
+            assert len(sess) == 1
+            assert sess["foo"] == [42]
+
+
+def test_session_transactions_no_null_sessions():
+    app = flask.Flask(__name__)
+
+    with app.test_client() as c:
+        with pytest.raises(RuntimeError) as e:
+            with c.session_transaction():
+                pass
+        assert "Session backend did not open a session" in str(e.value)
+
+
+def test_session_transactions_keep_context(app, client, req_ctx):
+    client.get("/")
+    req = flask.request._get_current_object()
+    assert req is not None
+    with client.session_transaction():
+        assert req is flask.request._get_current_object()
+
+
+def test_session_transaction_needs_cookies(app):
+    c = app.test_client(use_cookies=False)
+
+    with pytest.raises(TypeError, match="Cookies are disabled."):
+        with c.session_transaction():
+            pass
+
+
+def test_test_client_context_binding(app, client):
+    app.testing = False
+
+    @app.route("/")
+    def index():
+        flask.g.value = 42
+        return "Hello World!"
+
+    @app.route("/other")
+    def other():
+        raise ZeroDivisionError
+
+    with client:
+        resp = client.get("/")
+        assert flask.g.value == 42
+        assert resp.data == b"Hello World!"
+        assert resp.status_code == 200
+
+    with client:
+        resp = client.get("/other")
+        assert not hasattr(flask.g, "value")
+        assert b"Internal Server Error" in resp.data
+        assert resp.status_code == 500
+        flask.g.value = 23
+
+    with pytest.raises(RuntimeError):
+        flask.g.value  # noqa: B018
+
+
+def test_reuse_client(client):
+    c = client
+
+    with c:
+        assert client.get("/").status_code == 404
+
+    with c:
+        assert client.get("/").status_code == 404
+
+
+def test_full_url_request(app, client):
+    @app.route("/action", methods=["POST"])
+    def action():
+        return "x"
+
+    with client:
+        rv = client.post("http://domain.com/action?vodka=42", data={"gin": 43})
+        assert rv.status_code == 200
+        assert "gin" in flask.request.form
+        assert "vodka" in flask.request.args
+
+
+def test_json_request_and_response(app, client):
+    @app.route("/echo", methods=["POST"])
+    def echo():
+        return jsonify(flask.request.get_json())
+
+    with client:
+        json_data = {"drink": {"gin": 1, "tonic": True}, "price": 10}
+        rv = client.post("/echo", json=json_data)
+
+        # Request should be in JSON
+        assert flask.request.is_json
+        assert flask.request.get_json() == json_data
+
+        # Response should be in JSON
+        assert rv.status_code == 200
+        assert rv.is_json
+        assert rv.get_json() == json_data
+
+
+def test_client_json_no_app_context(app, client):
+    @app.route("/hello", methods=["POST"])
+    def hello():
+        return f"Hello, {flask.request.json['name']}!"
+
+    class Namespace:
+        count = 0
+
+        def add(self, app):
+            self.count += 1
+
+    ns = Namespace()
+
+    with appcontext_popped.connected_to(ns.add, app):
+        rv = client.post("/hello", json={"name": "Flask"})
+
+    assert rv.get_data(as_text=True) == "Hello, Flask!"
+    assert ns.count == 1
+
+
+def test_subdomain():
+    app = flask.Flask(__name__, subdomain_matching=True)
+    app.config["SERVER_NAME"] = "example.com"
+    client = app.test_client()
+
+    @app.route("/", subdomain="<company_id>")
+    def view(company_id):
+        return company_id
+
+    with app.test_request_context():
+        url = flask.url_for("view", company_id="xxx")
+
+    with client:
+        response = client.get(url)
+
+    assert 200 == response.status_code
+    assert b"xxx" == response.data
+
+
+def test_nosubdomain(app, client):
+    app.config["SERVER_NAME"] = "example.com"
+
+    @app.route("/<company_id>")
+    def view(company_id):
+        return company_id
+
+    with app.test_request_context():
+        url = flask.url_for("view", company_id="xxx")
+
+    with client:
+        response = client.get(url)
+
+    assert 200 == response.status_code
+    assert b"xxx" == response.data
+
+
+def test_cli_runner_class(app):
+    runner = app.test_cli_runner()
+    assert isinstance(runner, FlaskCliRunner)
+
+    class SubRunner(FlaskCliRunner):
+        pass
+
+    app.test_cli_runner_class = SubRunner
+    runner = app.test_cli_runner()
+    assert isinstance(runner, SubRunner)
+
+
+def test_cli_invoke(app):
+    @app.cli.command("hello")
+    def hello_command():
+        click.echo("Hello, World!")
+
+    runner = app.test_cli_runner()
+    # invoke with command name
+    result = runner.invoke(args=["hello"])
+    assert "Hello" in result.output
+    # invoke with command object
+    result = runner.invoke(hello_command)
+    assert "Hello" in result.output
+
+
+def test_cli_custom_obj(app):
+    class NS:
+        called = False
+
+    def create_app():
+        NS.called = True
+        return app
+
+    @app.cli.command("hello")
+    def hello_command():
+        click.echo("Hello, World!")
+
+    script_info = ScriptInfo(create_app=create_app)
+    runner = app.test_cli_runner()
+    runner.invoke(hello_command, obj=script_info)
+    assert NS.called
+
+
+def test_client_pop_all_preserved(app, req_ctx, client):
+    @app.route("/")
+    def index():
+        # stream_with_context pushes a third context, preserved by response
+        return flask.stream_with_context("hello")
+
+    # req_ctx fixture pushed an initial context
+    with client:
+        # request pushes a second request context, preserved by client
+        rv = client.get("/")
+
+    # close the response, releasing the context held by stream_with_context
+    rv.close()
+    # only req_ctx fixture should still be pushed
+    assert _cv_request.get(None) is req_ctx
