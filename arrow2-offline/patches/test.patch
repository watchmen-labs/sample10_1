diff --git b/tests/test_arrow.py a/tests/test_arrow.py
new file mode 100644
index 0000000..60f3a64
--- /dev/null
+++ a/tests/test_arrow.py
@@ -0,0 +1,3105 @@
+import pickle
+import sys
+import time
+from datetime import date, datetime, timedelta
+from typing import List
+
+import dateutil
+import pytest
+import pytz
+import simplejson as json
+from dateutil import tz
+from dateutil.relativedelta import FR, MO, SA, SU, TH, TU, WE
+
+from arrow import arrow, locales
+
+from .utils import assert_datetime_equality
+
+
+class TestTestArrowInit:
+    def test_init_bad_input(self):
+
+        with pytest.raises(TypeError):
+            arrow.Arrow(2013)
+
+        with pytest.raises(TypeError):
+            arrow.Arrow(2013, 2)
+
+        with pytest.raises(ValueError):
+            arrow.Arrow(2013, 2, 2, 12, 30, 45, 9999999)
+
+    def test_init(self):
+
+        result = arrow.Arrow(2013, 2, 2)
+        self.expected = datetime(2013, 2, 2, tzinfo=tz.tzutc())
+        assert result._datetime == self.expected
+
+        result = arrow.Arrow(2013, 2, 2, 12)
+        self.expected = datetime(2013, 2, 2, 12, tzinfo=tz.tzutc())
+        assert result._datetime == self.expected
+
+        result = arrow.Arrow(2013, 2, 2, 12, 30)
+        self.expected = datetime(2013, 2, 2, 12, 30, tzinfo=tz.tzutc())
+        assert result._datetime == self.expected
+
+        result = arrow.Arrow(2013, 2, 2, 12, 30, 45)
+        self.expected = datetime(2013, 2, 2, 12, 30, 45, tzinfo=tz.tzutc())
+        assert result._datetime == self.expected
+
+        result = arrow.Arrow(2013, 2, 2, 12, 30, 45, 999999)
+        self.expected = datetime(2013, 2, 2, 12, 30, 45, 999999, tzinfo=tz.tzutc())
+        assert result._datetime == self.expected
+
+        result = arrow.Arrow(
+            2013, 2, 2, 12, 30, 45, 999999, tzinfo=tz.gettz("Europe/Paris")
+        )
+        self.expected = datetime(
+            2013, 2, 2, 12, 30, 45, 999999, tzinfo=tz.gettz("Europe/Paris")
+        )
+        assert result._datetime == self.expected
+
+    # regression tests for issue #626
+    def test_init_pytz_timezone(self):
+
+        result = arrow.Arrow(
+            2013, 2, 2, 12, 30, 45, 999999, tzinfo=pytz.timezone("Europe/Paris")
+        )
+        self.expected = datetime(
+            2013, 2, 2, 12, 30, 45, 999999, tzinfo=tz.gettz("Europe/Paris")
+        )
+        assert result._datetime == self.expected
+        assert_datetime_equality(result._datetime, self.expected, 1)
+
+    def test_init_with_fold(self):
+        before = arrow.Arrow(2017, 10, 29, 2, 0, tzinfo="Europe/Stockholm")
+        after = arrow.Arrow(2017, 10, 29, 2, 0, tzinfo="Europe/Stockholm", fold=1)
+
+        assert hasattr(before, "fold")
+        assert hasattr(after, "fold")
+
+        # PEP-495 requires the comparisons below to be true
+        assert before == after
+        assert before.utcoffset() != after.utcoffset()
+
+
+class TestTestArrowFactory:
+    def test_now(self):
+
+        result = arrow.Arrow.now()
+
+        assert_datetime_equality(
+            result._datetime, datetime.now().replace(tzinfo=tz.tzlocal())
+        )
+
+    def test_utcnow(self):
+
+        result = arrow.Arrow.utcnow()
+
+        assert_datetime_equality(
+            result._datetime, datetime.utcnow().replace(tzinfo=tz.tzutc())
+        )
+
+        assert result.fold == 0
+
+    def test_fromtimestamp(self):
+
+        timestamp = time.time()
+
+        result = arrow.Arrow.fromtimestamp(timestamp)
+        assert_datetime_equality(
+            result._datetime, datetime.now().replace(tzinfo=tz.tzlocal())
+        )
+
+        result = arrow.Arrow.fromtimestamp(timestamp, tzinfo=tz.gettz("Europe/Paris"))
+        assert_datetime_equality(
+            result._datetime,
+            datetime.fromtimestamp(timestamp, tz.gettz("Europe/Paris")),
+        )
+
+        result = arrow.Arrow.fromtimestamp(timestamp, tzinfo="Europe/Paris")
+        assert_datetime_equality(
+            result._datetime,
+            datetime.fromtimestamp(timestamp, tz.gettz("Europe/Paris")),
+        )
+
+        with pytest.raises(ValueError):
+            arrow.Arrow.fromtimestamp("invalid timestamp")
+
+    def test_utcfromtimestamp(self):
+
+        timestamp = time.time()
+
+        result = arrow.Arrow.utcfromtimestamp(timestamp)
+        assert_datetime_equality(
+            result._datetime, datetime.utcnow().replace(tzinfo=tz.tzutc())
+        )
+
+        with pytest.raises(ValueError):
+            arrow.Arrow.utcfromtimestamp("invalid timestamp")
+
+    def test_fromdatetime(self):
+
+        dt = datetime(2013, 2, 3, 12, 30, 45, 1)
+
+        result = arrow.Arrow.fromdatetime(dt)
+
+        assert result._datetime == dt.replace(tzinfo=tz.tzutc())
+
+    def test_fromdatetime_dt_tzinfo(self):
+
+        dt = datetime(2013, 2, 3, 12, 30, 45, 1, tzinfo=tz.gettz("US/Pacific"))
+
+        result = arrow.Arrow.fromdatetime(dt)
+
+        assert result._datetime == dt.replace(tzinfo=tz.gettz("US/Pacific"))
+
+    def test_fromdatetime_tzinfo_arg(self):
+
+        dt = datetime(2013, 2, 3, 12, 30, 45, 1)
+
+        result = arrow.Arrow.fromdatetime(dt, tz.gettz("US/Pacific"))
+
+        assert result._datetime == dt.replace(tzinfo=tz.gettz("US/Pacific"))
+
+    def test_fromdate(self):
+
+        dt = date(2013, 2, 3)
+
+        result = arrow.Arrow.fromdate(dt, tz.gettz("US/Pacific"))
+
+        assert result._datetime == datetime(2013, 2, 3, tzinfo=tz.gettz("US/Pacific"))
+
+    def test_strptime(self):
+
+        formatted = datetime(2013, 2, 3, 12, 30, 45).strftime("%Y-%m-%d %H:%M:%S")
+
+        result = arrow.Arrow.strptime(formatted, "%Y-%m-%d %H:%M:%S")
+        assert result._datetime == datetime(2013, 2, 3, 12, 30, 45, tzinfo=tz.tzutc())
+
+        result = arrow.Arrow.strptime(
+            formatted, "%Y-%m-%d %H:%M:%S", tzinfo=tz.gettz("Europe/Paris")
+        )
+        assert result._datetime == datetime(
+            2013, 2, 3, 12, 30, 45, tzinfo=tz.gettz("Europe/Paris")
+        )
+
+    def test_fromordinal(self):
+
+        timestamp = 1607066909.937968
+        with pytest.raises(TypeError):
+            arrow.Arrow.fromordinal(timestamp)
+        with pytest.raises(ValueError):
+            arrow.Arrow.fromordinal(int(timestamp))
+
+        ordinal = arrow.Arrow.utcnow().toordinal()
+
+        with pytest.raises(TypeError):
+            arrow.Arrow.fromordinal(str(ordinal))
+
+        result = arrow.Arrow.fromordinal(ordinal)
+        dt = datetime.fromordinal(ordinal)
+
+        assert result.naive == dt
+
+
+@pytest.mark.usefixtures("time_2013_02_03")
+class TestTestArrowRepresentation:
+    def test_repr(self):
+
+        result = self.arrow.__repr__()
+
+        assert result == f"<Arrow [{self.arrow._datetime.isoformat()}]>"
+
+    def test_str(self):
+
+        result = self.arrow.__str__()
+
+        assert result == self.arrow._datetime.isoformat()
+
+    def test_hash(self):
+
+        result = self.arrow.__hash__()
+
+        assert result == self.arrow._datetime.__hash__()
+
+    def test_format(self):
+
+        result = f"{self.arrow:YYYY-MM-DD}"
+
+        assert result == "2013-02-03"
+
+    def test_bare_format(self):
+
+        result = self.arrow.format()
+
+        assert result == "2013-02-03 12:30:45+00:00"
+
+    def test_format_no_format_string(self):
+
+        result = f"{self.arrow}"
+
+        assert result == str(self.arrow)
+
+    def test_clone(self):
+
+        result = self.arrow.clone()
+
+        assert result is not self.arrow
+        assert result._datetime == self.arrow._datetime
+
+
+@pytest.mark.usefixtures("time_2013_01_01")
+class TestArrowAttribute:
+    def test_getattr_base(self):
+
+        with pytest.raises(AttributeError):
+            self.arrow.prop
+
+    def test_getattr_week(self):
+
+        assert self.arrow.week == 1
+
+    def test_getattr_quarter(self):
+        # start dates
+        q1 = arrow.Arrow(2013, 1, 1)
+        q2 = arrow.Arrow(2013, 4, 1)
+        q3 = arrow.Arrow(2013, 8, 1)
+        q4 = arrow.Arrow(2013, 10, 1)
+        assert q1.quarter == 1
+        assert q2.quarter == 2
+        assert q3.quarter == 3
+        assert q4.quarter == 4
+
+        # end dates
+        q1 = arrow.Arrow(2013, 3, 31)
+        q2 = arrow.Arrow(2013, 6, 30)
+        q3 = arrow.Arrow(2013, 9, 30)
+        q4 = arrow.Arrow(2013, 12, 31)
+        assert q1.quarter == 1
+        assert q2.quarter == 2
+        assert q3.quarter == 3
+        assert q4.quarter == 4
+
+    def test_getattr_dt_value(self):
+
+        assert self.arrow.year == 2013
+
+    def test_tzinfo(self):
+
+        assert self.arrow.tzinfo == tz.tzutc()
+
+    def test_naive(self):
+
+        assert self.arrow.naive == self.arrow._datetime.replace(tzinfo=None)
+
+    def test_timestamp(self):
+
+        assert self.arrow.timestamp() == self.arrow._datetime.timestamp()
+
+    def test_int_timestamp(self):
+
+        assert self.arrow.int_timestamp == int(self.arrow._datetime.timestamp())
+
+    def test_float_timestamp(self):
+
+        assert self.arrow.float_timestamp == self.arrow._datetime.timestamp()
+
+    def test_getattr_fold(self):
+
+        # UTC is always unambiguous
+        assert self.now.fold == 0
+
+        ambiguous_dt = arrow.Arrow(
+            2017, 10, 29, 2, 0, tzinfo="Europe/Stockholm", fold=1
+        )
+        assert ambiguous_dt.fold == 1
+
+        with pytest.raises(AttributeError):
+            ambiguous_dt.fold = 0
+
+    def test_getattr_ambiguous(self):
+
+        assert not self.now.ambiguous
+
+        ambiguous_dt = arrow.Arrow(2017, 10, 29, 2, 0, tzinfo="Europe/Stockholm")
+
+        assert ambiguous_dt.ambiguous
+
+    def test_getattr_imaginary(self):
+
+        assert not self.now.imaginary
+
+        imaginary_dt = arrow.Arrow(2013, 3, 31, 2, 30, tzinfo="Europe/Paris")
+
+        assert imaginary_dt.imaginary
+
+
+@pytest.mark.usefixtures("time_utcnow")
+class TestArrowComparison:
+    def test_eq(self):
+
+        assert self.arrow == self.arrow
+        assert self.arrow == self.arrow.datetime
+        assert not (self.arrow == "abc")
+
+    def test_ne(self):
+
+        assert not (self.arrow != self.arrow)
+        assert not (self.arrow != self.arrow.datetime)
+        assert self.arrow != "abc"
+
+    def test_gt(self):
+
+        arrow_cmp = self.arrow.shift(minutes=1)
+
+        assert not (self.arrow > self.arrow)
+        assert not (self.arrow > self.arrow.datetime)
+
+        with pytest.raises(TypeError):
+            self.arrow > "abc"  # noqa: B015
+
+        assert self.arrow < arrow_cmp
+        assert self.arrow < arrow_cmp.datetime
+
+    def test_ge(self):
+
+        with pytest.raises(TypeError):
+            self.arrow >= "abc"  # noqa: B015
+
+        assert self.arrow >= self.arrow
+        assert self.arrow >= self.arrow.datetime
+
+    def test_lt(self):
+
+        arrow_cmp = self.arrow.shift(minutes=1)
+
+        assert not (self.arrow < self.arrow)
+        assert not (self.arrow < self.arrow.datetime)
+
+        with pytest.raises(TypeError):
+            self.arrow < "abc"  # noqa: B015
+
+        assert self.arrow < arrow_cmp
+        assert self.arrow < arrow_cmp.datetime
+
+    def test_le(self):
+
+        with pytest.raises(TypeError):
+            self.arrow <= "abc"  # noqa: B015
+
+        assert self.arrow <= self.arrow
+        assert self.arrow <= self.arrow.datetime
+
+
+@pytest.mark.usefixtures("time_2013_01_01")
+class TestArrowMath:
+    def test_add_timedelta(self):
+
+        result = self.arrow.__add__(timedelta(days=1))
+
+        assert result._datetime == datetime(2013, 1, 2, tzinfo=tz.tzutc())
+
+    def test_add_other(self):
+
+        with pytest.raises(TypeError):
+            self.arrow + 1
+
+    def test_radd(self):
+
+        result = self.arrow.__radd__(timedelta(days=1))
+
+        assert result._datetime == datetime(2013, 1, 2, tzinfo=tz.tzutc())
+
+    def test_sub_timedelta(self):
+
+        result = self.arrow.__sub__(timedelta(days=1))
+
+        assert result._datetime == datetime(2012, 12, 31, tzinfo=tz.tzutc())
+
+    def test_sub_datetime(self):
+
+        result = self.arrow.__sub__(datetime(2012, 12, 21, tzinfo=tz.tzutc()))
+
+        assert result == timedelta(days=11)
+
+    def test_sub_arrow(self):
+
+        result = self.arrow.__sub__(arrow.Arrow(2012, 12, 21, tzinfo=tz.tzutc()))
+
+        assert result == timedelta(days=11)
+
+    def test_sub_other(self):
+
+        with pytest.raises(TypeError):
+            self.arrow - object()
+
+    def test_rsub_datetime(self):
+
+        result = self.arrow.__rsub__(datetime(2012, 12, 21, tzinfo=tz.tzutc()))
+
+        assert result == timedelta(days=-11)
+
+    def test_rsub_other(self):
+
+        with pytest.raises(TypeError):
+            timedelta(days=1) - self.arrow
+
+
+@pytest.mark.usefixtures("time_utcnow")
+class TestArrowDatetimeInterface:
+    def test_date(self):
+
+        result = self.arrow.date()
+
+        assert result == self.arrow._datetime.date()
+
+    def test_time(self):
+
+        result = self.arrow.time()
+
+        assert result == self.arrow._datetime.time()
+
+    def test_timetz(self):
+
+        result = self.arrow.timetz()
+
+        assert result == self.arrow._datetime.timetz()
+
+    def test_astimezone(self):
+
+        other_tz = tz.gettz("US/Pacific")
+
+        result = self.arrow.astimezone(other_tz)
+
+        assert result == self.arrow._datetime.astimezone(other_tz)
+
+    def test_utcoffset(self):
+
+        result = self.arrow.utcoffset()
+
+        assert result == self.arrow._datetime.utcoffset()
+
+    def test_dst(self):
+
+        result = self.arrow.dst()
+
+        assert result == self.arrow._datetime.dst()
+
+    def test_timetuple(self):
+
+        result = self.arrow.timetuple()
+
+        assert result == self.arrow._datetime.timetuple()
+
+    def test_utctimetuple(self):
+
+        result = self.arrow.utctimetuple()
+
+        assert result == self.arrow._datetime.utctimetuple()
+
+    def test_toordinal(self):
+
+        result = self.arrow.toordinal()
+
+        assert result == self.arrow._datetime.toordinal()
+
+    def test_weekday(self):
+
+        result = self.arrow.weekday()
+
+        assert result == self.arrow._datetime.weekday()
+
+    def test_isoweekday(self):
+
+        result = self.arrow.isoweekday()
+
+        assert result == self.arrow._datetime.isoweekday()
+
+    def test_isocalendar(self):
+
+        result = self.arrow.isocalendar()
+
+        assert result == self.arrow._datetime.isocalendar()
+
+    def test_isoformat(self):
+
+        result = self.arrow.isoformat()
+
+        assert result == self.arrow._datetime.isoformat()
+
+    def test_isoformat_timespec(self):
+
+        result = self.arrow.isoformat(timespec="hours")
+        assert result == self.arrow._datetime.isoformat(timespec="hours")
+
+        result = self.arrow.isoformat(timespec="microseconds")
+        assert result == self.arrow._datetime.isoformat()
+
+        result = self.arrow.isoformat(timespec="milliseconds")
+        assert result == self.arrow._datetime.isoformat(timespec="milliseconds")
+
+        result = self.arrow.isoformat(sep="x", timespec="seconds")
+        assert result == self.arrow._datetime.isoformat(sep="x", timespec="seconds")
+
+    def test_simplejson(self):
+
+        result = json.dumps({"v": self.arrow.for_json()}, for_json=True)
+
+        assert json.loads(result)["v"] == self.arrow._datetime.isoformat()
+
+    def test_ctime(self):
+
+        result = self.arrow.ctime()
+
+        assert result == self.arrow._datetime.ctime()
+
+    def test_strftime(self):
+
+        result = self.arrow.strftime("%Y")
+
+        assert result == self.arrow._datetime.strftime("%Y")
+
+
+class TestArrowFalsePositiveDst:
+    """These tests relate to issues #376 and #551.
+    The key points in both issues are that arrow will assign a UTC timezone if none is provided and
+    .to() will change other attributes to be correct whereas .replace() only changes the specified attribute.
+
+    Issue 376
+    >>> arrow.get('2016-11-06').to('America/New_York').ceil('day')
+    < Arrow [2016-11-05T23:59:59.999999-04:00] >
+
+    Issue 551
+    >>> just_before = arrow.get('2018-11-04T01:59:59.999999')
+    >>> just_before
+    2018-11-04T01:59:59.999999+00:00
+    >>> just_after = just_before.shift(microseconds=1)
+    >>> just_after
+    2018-11-04T02:00:00+00:00
+    >>> just_before_eastern = just_before.replace(tzinfo='US/Eastern')
+    >>> just_before_eastern
+    2018-11-04T01:59:59.999999-04:00
+    >>> just_after_eastern = just_after.replace(tzinfo='US/Eastern')
+    >>> just_after_eastern
+    2018-11-04T02:00:00-05:00
+    """
+
+    def test_dst(self):
+        self.before_1 = arrow.Arrow(
+            2016, 11, 6, 3, 59, tzinfo=tz.gettz("America/New_York")
+        )
+        self.before_2 = arrow.Arrow(2016, 11, 6, tzinfo=tz.gettz("America/New_York"))
+        self.after_1 = arrow.Arrow(2016, 11, 6, 4, tzinfo=tz.gettz("America/New_York"))
+        self.after_2 = arrow.Arrow(
+            2016, 11, 6, 23, 59, tzinfo=tz.gettz("America/New_York")
+        )
+        self.before_3 = arrow.Arrow(
+            2018, 11, 4, 3, 59, tzinfo=tz.gettz("America/New_York")
+        )
+        self.before_4 = arrow.Arrow(2018, 11, 4, tzinfo=tz.gettz("America/New_York"))
+        self.after_3 = arrow.Arrow(2018, 11, 4, 4, tzinfo=tz.gettz("America/New_York"))
+        self.after_4 = arrow.Arrow(
+            2018, 11, 4, 23, 59, tzinfo=tz.gettz("America/New_York")
+        )
+        assert self.before_1.day == self.before_2.day
+        assert self.after_1.day == self.after_2.day
+        assert self.before_3.day == self.before_4.day
+        assert self.after_3.day == self.after_4.day
+
+
+class TestArrowConversion:
+    def test_to(self):
+
+        dt_from = datetime.now()
+        arrow_from = arrow.Arrow.fromdatetime(dt_from, tz.gettz("US/Pacific"))
+
+        self.expected = dt_from.replace(tzinfo=tz.gettz("US/Pacific")).astimezone(
+            tz.tzutc()
+        )
+
+        assert arrow_from.to("UTC").datetime == self.expected
+        assert arrow_from.to(tz.tzutc()).datetime == self.expected
+
+    # issue #368
+    def test_to_pacific_then_utc(self):
+        result = arrow.Arrow(2018, 11, 4, 1, tzinfo="-08:00").to("US/Pacific").to("UTC")
+        assert result == arrow.Arrow(2018, 11, 4, 9)
+
+    # issue #368
+    def test_to_amsterdam_then_utc(self):
+        result = arrow.Arrow(2016, 10, 30).to("Europe/Amsterdam")
+        assert result.utcoffset() == timedelta(seconds=7200)
+
+    # regression test for #690
+    def test_to_israel_same_offset(self):
+
+        result = arrow.Arrow(2019, 10, 27, 2, 21, 1, tzinfo="+03:00").to("Israel")
+        expected = arrow.Arrow(2019, 10, 27, 1, 21, 1, tzinfo="Israel")
+
+        assert result == expected
+        assert result.utcoffset() != expected.utcoffset()
+
+    # issue 315
+    def test_anchorage_dst(self):
+        before = arrow.Arrow(2016, 3, 13, 1, 59, tzinfo="America/Anchorage")
+        after = arrow.Arrow(2016, 3, 13, 2, 1, tzinfo="America/Anchorage")
+
+        assert before.utcoffset() != after.utcoffset()
+
+    # issue 476
+    def test_chicago_fall(self):
+
+        result = arrow.Arrow(2017, 11, 5, 2, 1, tzinfo="-05:00").to("America/Chicago")
+        expected = arrow.Arrow(2017, 11, 5, 1, 1, tzinfo="America/Chicago")
+
+        assert result == expected
+        assert result.utcoffset() != expected.utcoffset()
+
+    def test_toronto_gap(self):
+
+        before = arrow.Arrow(2011, 3, 13, 6, 30, tzinfo="UTC").to("America/Toronto")
+        after = arrow.Arrow(2011, 3, 13, 7, 30, tzinfo="UTC").to("America/Toronto")
+
+        assert before.datetime.replace(tzinfo=None) == datetime(2011, 3, 13, 1, 30)
+        assert after.datetime.replace(tzinfo=None) == datetime(2011, 3, 13, 3, 30)
+
+        assert before.utcoffset() != after.utcoffset()
+
+    def test_sydney_gap(self):
+
+        before = arrow.Arrow(2012, 10, 6, 15, 30, tzinfo="UTC").to("Australia/Sydney")
+        after = arrow.Arrow(2012, 10, 6, 16, 30, tzinfo="UTC").to("Australia/Sydney")
+
+        assert before.datetime.replace(tzinfo=None) == datetime(2012, 10, 7, 1, 30)
+        assert after.datetime.replace(tzinfo=None) == datetime(2012, 10, 7, 3, 30)
+
+        assert before.utcoffset() != after.utcoffset()
+
+
+class TestArrowPickling:
+    def test_pickle_and_unpickle(self):
+
+        dt = arrow.Arrow.utcnow()
+
+        pickled = pickle.dumps(dt)
+
+        unpickled = pickle.loads(pickled)
+
+        assert unpickled == dt
+
+
+class TestArrowReplace:
+    def test_not_attr(self):
+
+        with pytest.raises(ValueError):
+            arrow.Arrow.utcnow().replace(abc=1)
+
+    def test_replace(self):
+
+        arw = arrow.Arrow(2013, 5, 5, 12, 30, 45)
+
+        assert arw.replace(year=2012) == arrow.Arrow(2012, 5, 5, 12, 30, 45)
+        assert arw.replace(month=1) == arrow.Arrow(2013, 1, 5, 12, 30, 45)
+        assert arw.replace(day=1) == arrow.Arrow(2013, 5, 1, 12, 30, 45)
+        assert arw.replace(hour=1) == arrow.Arrow(2013, 5, 5, 1, 30, 45)
+        assert arw.replace(minute=1) == arrow.Arrow(2013, 5, 5, 12, 1, 45)
+        assert arw.replace(second=1) == arrow.Arrow(2013, 5, 5, 12, 30, 1)
+
+    def test_replace_tzinfo(self):
+
+        arw = arrow.Arrow.utcnow().to("US/Eastern")
+
+        result = arw.replace(tzinfo=tz.gettz("US/Pacific"))
+
+        assert result == arw.datetime.replace(tzinfo=tz.gettz("US/Pacific"))
+
+    def test_replace_fold(self):
+
+        before = arrow.Arrow(2017, 11, 5, 1, tzinfo="America/New_York")
+        after = before.replace(fold=1)
+
+        assert before.fold == 0
+        assert after.fold == 1
+        assert before == after
+        assert before.utcoffset() != after.utcoffset()
+
+    def test_replace_fold_and_other(self):
+
+        arw = arrow.Arrow(2013, 5, 5, 12, 30, 45)
+
+        assert arw.replace(fold=1, minute=50) == arrow.Arrow(2013, 5, 5, 12, 50, 45)
+        assert arw.replace(minute=50, fold=1) == arrow.Arrow(2013, 5, 5, 12, 50, 45)
+
+    def test_replace_week(self):
+
+        with pytest.raises(ValueError):
+            arrow.Arrow.utcnow().replace(week=1)
+
+    def test_replace_quarter(self):
+
+        with pytest.raises(ValueError):
+            arrow.Arrow.utcnow().replace(quarter=1)
+
+    def test_replace_quarter_and_fold(self):
+        with pytest.raises(AttributeError):
+            arrow.utcnow().replace(fold=1, quarter=1)
+
+        with pytest.raises(AttributeError):
+            arrow.utcnow().replace(quarter=1, fold=1)
+
+    def test_replace_other_kwargs(self):
+
+        with pytest.raises(AttributeError):
+            arrow.utcnow().replace(abc="def")
+
+
+class TestArrowShift:
+    def test_not_attr(self):
+
+        now = arrow.Arrow.utcnow()
+
+        with pytest.raises(ValueError):
+            now.shift(abc=1)
+
+        with pytest.raises(ValueError):
+            now.shift(week=1)
+
+    def test_shift(self):
+
+        arw = arrow.Arrow(2013, 5, 5, 12, 30, 45)
+
+        assert arw.shift(years=1) == arrow.Arrow(2014, 5, 5, 12, 30, 45)
+        assert arw.shift(quarters=1) == arrow.Arrow(2013, 8, 5, 12, 30, 45)
+        assert arw.shift(quarters=1, months=1) == arrow.Arrow(2013, 9, 5, 12, 30, 45)
+        assert arw.shift(months=1) == arrow.Arrow(2013, 6, 5, 12, 30, 45)
+        assert arw.shift(weeks=1) == arrow.Arrow(2013, 5, 12, 12, 30, 45)
+        assert arw.shift(days=1) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(hours=1) == arrow.Arrow(2013, 5, 5, 13, 30, 45)
+        assert arw.shift(minutes=1) == arrow.Arrow(2013, 5, 5, 12, 31, 45)
+        assert arw.shift(seconds=1) == arrow.Arrow(2013, 5, 5, 12, 30, 46)
+        assert arw.shift(microseconds=1) == arrow.Arrow(2013, 5, 5, 12, 30, 45, 1)
+
+        # Remember: Python's weekday 0 is Monday
+        assert arw.shift(weekday=0) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(weekday=1) == arrow.Arrow(2013, 5, 7, 12, 30, 45)
+        assert arw.shift(weekday=2) == arrow.Arrow(2013, 5, 8, 12, 30, 45)
+        assert arw.shift(weekday=3) == arrow.Arrow(2013, 5, 9, 12, 30, 45)
+        assert arw.shift(weekday=4) == arrow.Arrow(2013, 5, 10, 12, 30, 45)
+        assert arw.shift(weekday=5) == arrow.Arrow(2013, 5, 11, 12, 30, 45)
+        assert arw.shift(weekday=6) == arw
+
+        with pytest.raises(IndexError):
+            arw.shift(weekday=7)
+
+        # Use dateutil.relativedelta's convenient day instances
+        assert arw.shift(weekday=MO) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(weekday=MO(0)) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(weekday=MO(1)) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(weekday=MO(2)) == arrow.Arrow(2013, 5, 13, 12, 30, 45)
+        assert arw.shift(weekday=TU) == arrow.Arrow(2013, 5, 7, 12, 30, 45)
+        assert arw.shift(weekday=TU(0)) == arrow.Arrow(2013, 5, 7, 12, 30, 45)
+        assert arw.shift(weekday=TU(1)) == arrow.Arrow(2013, 5, 7, 12, 30, 45)
+        assert arw.shift(weekday=TU(2)) == arrow.Arrow(2013, 5, 14, 12, 30, 45)
+        assert arw.shift(weekday=WE) == arrow.Arrow(2013, 5, 8, 12, 30, 45)
+        assert arw.shift(weekday=WE(0)) == arrow.Arrow(2013, 5, 8, 12, 30, 45)
+        assert arw.shift(weekday=WE(1)) == arrow.Arrow(2013, 5, 8, 12, 30, 45)
+        assert arw.shift(weekday=WE(2)) == arrow.Arrow(2013, 5, 15, 12, 30, 45)
+        assert arw.shift(weekday=TH) == arrow.Arrow(2013, 5, 9, 12, 30, 45)
+        assert arw.shift(weekday=TH(0)) == arrow.Arrow(2013, 5, 9, 12, 30, 45)
+        assert arw.shift(weekday=TH(1)) == arrow.Arrow(2013, 5, 9, 12, 30, 45)
+        assert arw.shift(weekday=TH(2)) == arrow.Arrow(2013, 5, 16, 12, 30, 45)
+        assert arw.shift(weekday=FR) == arrow.Arrow(2013, 5, 10, 12, 30, 45)
+        assert arw.shift(weekday=FR(0)) == arrow.Arrow(2013, 5, 10, 12, 30, 45)
+        assert arw.shift(weekday=FR(1)) == arrow.Arrow(2013, 5, 10, 12, 30, 45)
+        assert arw.shift(weekday=FR(2)) == arrow.Arrow(2013, 5, 17, 12, 30, 45)
+        assert arw.shift(weekday=SA) == arrow.Arrow(2013, 5, 11, 12, 30, 45)
+        assert arw.shift(weekday=SA(0)) == arrow.Arrow(2013, 5, 11, 12, 30, 45)
+        assert arw.shift(weekday=SA(1)) == arrow.Arrow(2013, 5, 11, 12, 30, 45)
+        assert arw.shift(weekday=SA(2)) == arrow.Arrow(2013, 5, 18, 12, 30, 45)
+        assert arw.shift(weekday=SU) == arw
+        assert arw.shift(weekday=SU(0)) == arw
+        assert arw.shift(weekday=SU(1)) == arw
+        assert arw.shift(weekday=SU(2)) == arrow.Arrow(2013, 5, 12, 12, 30, 45)
+
+    def test_shift_negative(self):
+
+        arw = arrow.Arrow(2013, 5, 5, 12, 30, 45)
+
+        assert arw.shift(years=-1) == arrow.Arrow(2012, 5, 5, 12, 30, 45)
+        assert arw.shift(quarters=-1) == arrow.Arrow(2013, 2, 5, 12, 30, 45)
+        assert arw.shift(quarters=-1, months=-1) == arrow.Arrow(2013, 1, 5, 12, 30, 45)
+        assert arw.shift(months=-1) == arrow.Arrow(2013, 4, 5, 12, 30, 45)
+        assert arw.shift(weeks=-1) == arrow.Arrow(2013, 4, 28, 12, 30, 45)
+        assert arw.shift(days=-1) == arrow.Arrow(2013, 5, 4, 12, 30, 45)
+        assert arw.shift(hours=-1) == arrow.Arrow(2013, 5, 5, 11, 30, 45)
+        assert arw.shift(minutes=-1) == arrow.Arrow(2013, 5, 5, 12, 29, 45)
+        assert arw.shift(seconds=-1) == arrow.Arrow(2013, 5, 5, 12, 30, 44)
+        assert arw.shift(microseconds=-1) == arrow.Arrow(2013, 5, 5, 12, 30, 44, 999999)
+
+        # Not sure how practical these negative weekdays are
+        assert arw.shift(weekday=-1) == arw.shift(weekday=SU)
+        assert arw.shift(weekday=-2) == arw.shift(weekday=SA)
+        assert arw.shift(weekday=-3) == arw.shift(weekday=FR)
+        assert arw.shift(weekday=-4) == arw.shift(weekday=TH)
+        assert arw.shift(weekday=-5) == arw.shift(weekday=WE)
+        assert arw.shift(weekday=-6) == arw.shift(weekday=TU)
+        assert arw.shift(weekday=-7) == arw.shift(weekday=MO)
+
+        with pytest.raises(IndexError):
+            arw.shift(weekday=-8)
+
+        assert arw.shift(weekday=MO(-1)) == arrow.Arrow(2013, 4, 29, 12, 30, 45)
+        assert arw.shift(weekday=TU(-1)) == arrow.Arrow(2013, 4, 30, 12, 30, 45)
+        assert arw.shift(weekday=WE(-1)) == arrow.Arrow(2013, 5, 1, 12, 30, 45)
+        assert arw.shift(weekday=TH(-1)) == arrow.Arrow(2013, 5, 2, 12, 30, 45)
+        assert arw.shift(weekday=FR(-1)) == arrow.Arrow(2013, 5, 3, 12, 30, 45)
+        assert arw.shift(weekday=SA(-1)) == arrow.Arrow(2013, 5, 4, 12, 30, 45)
+        assert arw.shift(weekday=SU(-1)) == arw
+        assert arw.shift(weekday=SU(-2)) == arrow.Arrow(2013, 4, 28, 12, 30, 45)
+
+    def test_shift_quarters_bug(self):
+
+        arw = arrow.Arrow(2013, 5, 5, 12, 30, 45)
+
+        # The value of the last-read argument was used instead of the ``quarters`` argument.
+        # Recall that the keyword argument dict, like all dicts, is unordered, so only certain
+        # combinations of arguments would exhibit this.
+        assert arw.shift(quarters=0, years=1) == arrow.Arrow(2014, 5, 5, 12, 30, 45)
+        assert arw.shift(quarters=0, months=1) == arrow.Arrow(2013, 6, 5, 12, 30, 45)
+        assert arw.shift(quarters=0, weeks=1) == arrow.Arrow(2013, 5, 12, 12, 30, 45)
+        assert arw.shift(quarters=0, days=1) == arrow.Arrow(2013, 5, 6, 12, 30, 45)
+        assert arw.shift(quarters=0, hours=1) == arrow.Arrow(2013, 5, 5, 13, 30, 45)
+        assert arw.shift(quarters=0, minutes=1) == arrow.Arrow(2013, 5, 5, 12, 31, 45)
+        assert arw.shift(quarters=0, seconds=1) == arrow.Arrow(2013, 5, 5, 12, 30, 46)
+        assert arw.shift(quarters=0, microseconds=1) == arrow.Arrow(
+            2013, 5, 5, 12, 30, 45, 1
+        )
+
+    def test_shift_positive_imaginary(self):
+
+        # Avoid shifting into imaginary datetimes, take into account DST and other timezone changes.
+
+        new_york = arrow.Arrow(2017, 3, 12, 1, 30, tzinfo="America/New_York")
+        assert new_york.shift(hours=+1) == arrow.Arrow(
+            2017, 3, 12, 3, 30, tzinfo="America/New_York"
+        )
+
+        # pendulum example
+        paris = arrow.Arrow(2013, 3, 31, 1, 50, tzinfo="Europe/Paris")
+        assert paris.shift(minutes=+20) == arrow.Arrow(
+            2013, 3, 31, 3, 10, tzinfo="Europe/Paris"
+        )
+
+        canberra = arrow.Arrow(2018, 10, 7, 1, 30, tzinfo="Australia/Canberra")
+        assert canberra.shift(hours=+1) == arrow.Arrow(
+            2018, 10, 7, 3, 30, tzinfo="Australia/Canberra"
+        )
+
+        kiev = arrow.Arrow(2018, 3, 25, 2, 30, tzinfo="Europe/Kiev")
+        assert kiev.shift(hours=+1) == arrow.Arrow(
+            2018, 3, 25, 4, 30, tzinfo="Europe/Kiev"
+        )
+
+        # Edge case, the entire day of 2011-12-30 is imaginary in this zone!
+        apia = arrow.Arrow(2011, 12, 29, 23, tzinfo="Pacific/Apia")
+        assert apia.shift(hours=+2) == arrow.Arrow(
+            2011, 12, 31, 1, tzinfo="Pacific/Apia"
+        )
+
+    def test_shift_negative_imaginary(self):
+
+        new_york = arrow.Arrow(2011, 3, 13, 3, 30, tzinfo="America/New_York")
+        assert new_york.shift(hours=-1) == arrow.Arrow(
+            2011, 3, 13, 3, 30, tzinfo="America/New_York"
+        )
+        assert new_york.shift(hours=-2) == arrow.Arrow(
+            2011, 3, 13, 1, 30, tzinfo="America/New_York"
+        )
+
+        london = arrow.Arrow(2019, 3, 31, 2, tzinfo="Europe/London")
+        assert london.shift(hours=-1) == arrow.Arrow(
+            2019, 3, 31, 2, tzinfo="Europe/London"
+        )
+        assert london.shift(hours=-2) == arrow.Arrow(
+            2019, 3, 31, 0, tzinfo="Europe/London"
+        )
+
+        # edge case, crossing the international dateline
+        apia = arrow.Arrow(2011, 12, 31, 1, tzinfo="Pacific/Apia")
+        assert apia.shift(hours=-2) == arrow.Arrow(
+            2011, 12, 31, 23, tzinfo="Pacific/Apia"
+        )
+
+    @pytest.mark.skipif(
+        dateutil.__version__ < "2.7.1", reason="old tz database (2018d needed)"
+    )
+    def test_shift_kiritimati(self):
+        # corrected 2018d tz database release, will fail in earlier versions
+
+        kiritimati = arrow.Arrow(1994, 12, 30, 12, 30, tzinfo="Pacific/Kiritimati")
+        assert kiritimati.shift(days=+1) == arrow.Arrow(
+            1995, 1, 1, 12, 30, tzinfo="Pacific/Kiritimati"
+        )
+
+    def shift_imaginary_seconds(self):
+        # offset has a seconds component
+        monrovia = arrow.Arrow(1972, 1, 6, 23, tzinfo="Africa/Monrovia")
+        assert monrovia.shift(hours=+1, minutes=+30) == arrow.Arrow(
+            1972, 1, 7, 1, 14, 30, tzinfo="Africa/Monrovia"
+        )
+
+
+class TestArrowRange:
+    def test_year(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "year", datetime(2013, 1, 2, 3, 4, 5), datetime(2016, 4, 5, 6, 7, 8)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2014, 1, 2, 3, 4, 5),
+            arrow.Arrow(2015, 1, 2, 3, 4, 5),
+            arrow.Arrow(2016, 1, 2, 3, 4, 5),
+        ]
+
+    def test_quarter(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "quarter", datetime(2013, 2, 3, 4, 5, 6), datetime(2013, 5, 6, 7, 8, 9)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 2, 3, 4, 5, 6),
+            arrow.Arrow(2013, 5, 3, 4, 5, 6),
+        ]
+
+    def test_month(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "month", datetime(2013, 2, 3, 4, 5, 6), datetime(2013, 5, 6, 7, 8, 9)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 2, 3, 4, 5, 6),
+            arrow.Arrow(2013, 3, 3, 4, 5, 6),
+            arrow.Arrow(2013, 4, 3, 4, 5, 6),
+            arrow.Arrow(2013, 5, 3, 4, 5, 6),
+        ]
+
+    def test_week(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "week", datetime(2013, 9, 1, 2, 3, 4), datetime(2013, 10, 1, 2, 3, 4)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 9, 1, 2, 3, 4),
+            arrow.Arrow(2013, 9, 8, 2, 3, 4),
+            arrow.Arrow(2013, 9, 15, 2, 3, 4),
+            arrow.Arrow(2013, 9, 22, 2, 3, 4),
+            arrow.Arrow(2013, 9, 29, 2, 3, 4),
+        ]
+
+    def test_day(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "day", datetime(2013, 1, 2, 3, 4, 5), datetime(2013, 1, 5, 6, 7, 8)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2013, 1, 3, 3, 4, 5),
+            arrow.Arrow(2013, 1, 4, 3, 4, 5),
+            arrow.Arrow(2013, 1, 5, 3, 4, 5),
+        ]
+
+    def test_hour(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "hour", datetime(2013, 1, 2, 3, 4, 5), datetime(2013, 1, 2, 6, 7, 8)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2013, 1, 2, 4, 4, 5),
+            arrow.Arrow(2013, 1, 2, 5, 4, 5),
+            arrow.Arrow(2013, 1, 2, 6, 4, 5),
+        ]
+
+        result = list(
+            arrow.Arrow.range(
+                "hour", datetime(2013, 1, 2, 3, 4, 5), datetime(2013, 1, 2, 3, 4, 5)
+            )
+        )
+
+        assert result == [arrow.Arrow(2013, 1, 2, 3, 4, 5)]
+
+    def test_minute(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "minute", datetime(2013, 1, 2, 3, 4, 5), datetime(2013, 1, 2, 3, 7, 8)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2013, 1, 2, 3, 5, 5),
+            arrow.Arrow(2013, 1, 2, 3, 6, 5),
+            arrow.Arrow(2013, 1, 2, 3, 7, 5),
+        ]
+
+    def test_second(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "second", datetime(2013, 1, 2, 3, 4, 5), datetime(2013, 1, 2, 3, 4, 8)
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2013, 1, 2, 3, 4, 6),
+            arrow.Arrow(2013, 1, 2, 3, 4, 7),
+            arrow.Arrow(2013, 1, 2, 3, 4, 8),
+        ]
+
+    def test_arrow(self):
+
+        result = list(
+            arrow.Arrow.range(
+                "day",
+                arrow.Arrow(2013, 1, 2, 3, 4, 5),
+                arrow.Arrow(2013, 1, 5, 6, 7, 8),
+            )
+        )
+
+        assert result == [
+            arrow.Arrow(2013, 1, 2, 3, 4, 5),
+            arrow.Arrow(2013, 1, 3, 3, 4, 5),
+            arrow.Arrow(2013, 1, 4, 3, 4, 5),
+            arrow.Arrow(2013, 1, 5, 3, 4, 5),
+        ]
+
+    def test_naive_tz(self):
+
+        result = arrow.Arrow.range(
+            "year", datetime(2013, 1, 2, 3), datetime(2016, 4, 5, 6), "US/Pacific"
+        )
+
+        for r in result:
+            assert r.tzinfo == tz.gettz("US/Pacific")
+
+    def test_aware_same_tz(self):
+
+        result = arrow.Arrow.range(
+            "day",
+            arrow.Arrow(2013, 1, 1, tzinfo=tz.gettz("US/Pacific")),
+            arrow.Arrow(2013, 1, 3, tzinfo=tz.gettz("US/Pacific")),
+        )
+
+        for r in result:
+            assert r.tzinfo == tz.gettz("US/Pacific")
+
+    def test_aware_different_tz(self):
+
+        result = arrow.Arrow.range(
+            "day",
+            datetime(2013, 1, 1, tzinfo=tz.gettz("US/Eastern")),
+            datetime(2013, 1, 3, tzinfo=tz.gettz("US/Pacific")),
+        )
+
+        for r in result:
+            assert r.tzinfo == tz.gettz("US/Eastern")
+
+    def test_aware_tz(self):
+
+        result = arrow.Arrow.range(
+            "day",
+            datetime(2013, 1, 1, tzinfo=tz.gettz("US/Eastern")),
+            datetime(2013, 1, 3, tzinfo=tz.gettz("US/Pacific")),
+            tz=tz.gettz("US/Central"),
+        )
+
+        for r in result:
+            assert r.tzinfo == tz.gettz("US/Central")
+
+    def test_imaginary(self):
+        # issue #72, avoid duplication in utc column
+
+        before = arrow.Arrow(2018, 3, 10, 23, tzinfo="US/Pacific")
+        after = arrow.Arrow(2018, 3, 11, 4, tzinfo="US/Pacific")
+
+        pacific_range = [t for t in arrow.Arrow.range("hour", before, after)]
+        utc_range = [t.to("utc") for t in arrow.Arrow.range("hour", before, after)]
+
+        assert len(pacific_range) == len(set(pacific_range))
+        assert len(utc_range) == len(set(utc_range))
+
+    def test_unsupported(self):
+
+        with pytest.raises(ValueError):
+            next(arrow.Arrow.range("abc", datetime.utcnow(), datetime.utcnow()))
+
+    def test_range_over_months_ending_on_different_days(self):
+        # regression test for issue #842
+        result = list(arrow.Arrow.range("month", datetime(2015, 1, 31), limit=4))
+        assert result == [
+            arrow.Arrow(2015, 1, 31),
+            arrow.Arrow(2015, 2, 28),
+            arrow.Arrow(2015, 3, 31),
+            arrow.Arrow(2015, 4, 30),
+        ]
+
+        result = list(arrow.Arrow.range("month", datetime(2015, 1, 30), limit=3))
+        assert result == [
+            arrow.Arrow(2015, 1, 30),
+            arrow.Arrow(2015, 2, 28),
+            arrow.Arrow(2015, 3, 30),
+        ]
+
+        result = list(arrow.Arrow.range("month", datetime(2015, 2, 28), limit=3))
+        assert result == [
+            arrow.Arrow(2015, 2, 28),
+            arrow.Arrow(2015, 3, 28),
+            arrow.Arrow(2015, 4, 28),
+        ]
+
+        result = list(arrow.Arrow.range("month", datetime(2015, 3, 31), limit=3))
+        assert result == [
+            arrow.Arrow(2015, 3, 31),
+            arrow.Arrow(2015, 4, 30),
+            arrow.Arrow(2015, 5, 31),
+        ]
+
+    def test_range_over_quarter_months_ending_on_different_days(self):
+        result = list(arrow.Arrow.range("quarter", datetime(2014, 11, 30), limit=3))
+        assert result == [
+            arrow.Arrow(2014, 11, 30),
+            arrow.Arrow(2015, 2, 28),
+            arrow.Arrow(2015, 5, 30),
+        ]
+
+    def test_range_over_year_maintains_end_date_across_leap_year(self):
+        result = list(arrow.Arrow.range("year", datetime(2012, 2, 29), limit=5))
+        assert result == [
+            arrow.Arrow(2012, 2, 29),
+            arrow.Arrow(2013, 2, 28),
+            arrow.Arrow(2014, 2, 28),
+            arrow.Arrow(2015, 2, 28),
+            arrow.Arrow(2016, 2, 29),
+        ]
+
+
+class TestArrowSpanRange:
+    def test_year(self):
+
+        result = list(
+            arrow.Arrow.span_range("year", datetime(2013, 2, 1), datetime(2016, 3, 31))
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1),
+                arrow.Arrow(2013, 12, 31, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2014, 1, 1),
+                arrow.Arrow(2014, 12, 31, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2015, 1, 1),
+                arrow.Arrow(2015, 12, 31, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2016, 1, 1),
+                arrow.Arrow(2016, 12, 31, 23, 59, 59, 999999),
+            ),
+        ]
+
+    def test_quarter(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "quarter", datetime(2013, 2, 2), datetime(2013, 5, 15)
+            )
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 1, 1), arrow.Arrow(2013, 3, 31, 23, 59, 59, 999999)),
+            (arrow.Arrow(2013, 4, 1), arrow.Arrow(2013, 6, 30, 23, 59, 59, 999999)),
+        ]
+
+    def test_month(self):
+
+        result = list(
+            arrow.Arrow.span_range("month", datetime(2013, 1, 2), datetime(2013, 4, 15))
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 1, 1), arrow.Arrow(2013, 1, 31, 23, 59, 59, 999999)),
+            (arrow.Arrow(2013, 2, 1), arrow.Arrow(2013, 2, 28, 23, 59, 59, 999999)),
+            (arrow.Arrow(2013, 3, 1), arrow.Arrow(2013, 3, 31, 23, 59, 59, 999999)),
+            (arrow.Arrow(2013, 4, 1), arrow.Arrow(2013, 4, 30, 23, 59, 59, 999999)),
+        ]
+
+    def test_week(self):
+
+        result = list(
+            arrow.Arrow.span_range("week", datetime(2013, 2, 2), datetime(2013, 2, 28))
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 1, 28), arrow.Arrow(2013, 2, 3, 23, 59, 59, 999999)),
+            (arrow.Arrow(2013, 2, 4), arrow.Arrow(2013, 2, 10, 23, 59, 59, 999999)),
+            (
+                arrow.Arrow(2013, 2, 11),
+                arrow.Arrow(2013, 2, 17, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 2, 18),
+                arrow.Arrow(2013, 2, 24, 23, 59, 59, 999999),
+            ),
+            (arrow.Arrow(2013, 2, 25), arrow.Arrow(2013, 3, 3, 23, 59, 59, 999999)),
+        ]
+
+    def test_day(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "day", datetime(2013, 1, 1, 12), datetime(2013, 1, 4, 12)
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1, 0),
+                arrow.Arrow(2013, 1, 1, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 2, 0),
+                arrow.Arrow(2013, 1, 2, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 3, 0),
+                arrow.Arrow(2013, 1, 3, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 4, 0),
+                arrow.Arrow(2013, 1, 4, 23, 59, 59, 999999),
+            ),
+        ]
+
+    def test_days(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "days", datetime(2013, 1, 1, 12), datetime(2013, 1, 4, 12)
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1, 0),
+                arrow.Arrow(2013, 1, 1, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 2, 0),
+                arrow.Arrow(2013, 1, 2, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 3, 0),
+                arrow.Arrow(2013, 1, 3, 23, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 4, 0),
+                arrow.Arrow(2013, 1, 4, 23, 59, 59, 999999),
+            ),
+        ]
+
+    def test_hour(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "hour", datetime(2013, 1, 1, 0, 30), datetime(2013, 1, 1, 3, 30)
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1, 0),
+                arrow.Arrow(2013, 1, 1, 0, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 1),
+                arrow.Arrow(2013, 1, 1, 1, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 2),
+                arrow.Arrow(2013, 1, 1, 2, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 3),
+                arrow.Arrow(2013, 1, 1, 3, 59, 59, 999999),
+            ),
+        ]
+
+        result = list(
+            arrow.Arrow.span_range(
+                "hour", datetime(2013, 1, 1, 3, 30), datetime(2013, 1, 1, 3, 30)
+            )
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 1, 1, 3), arrow.Arrow(2013, 1, 1, 3, 59, 59, 999999))
+        ]
+
+    def test_minute(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "minute", datetime(2013, 1, 1, 0, 0, 30), datetime(2013, 1, 1, 0, 3, 30)
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1, 0, 0),
+                arrow.Arrow(2013, 1, 1, 0, 0, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 1),
+                arrow.Arrow(2013, 1, 1, 0, 1, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 2),
+                arrow.Arrow(2013, 1, 1, 0, 2, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 3),
+                arrow.Arrow(2013, 1, 1, 0, 3, 59, 999999),
+            ),
+        ]
+
+    def test_second(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "second", datetime(2013, 1, 1), datetime(2013, 1, 1, 0, 0, 3)
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 1, 1, 0, 0, 0),
+                arrow.Arrow(2013, 1, 1, 0, 0, 0, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 0, 1),
+                arrow.Arrow(2013, 1, 1, 0, 0, 1, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 0, 2),
+                arrow.Arrow(2013, 1, 1, 0, 0, 2, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 1, 1, 0, 0, 3),
+                arrow.Arrow(2013, 1, 1, 0, 0, 3, 999999),
+            ),
+        ]
+
+    def test_naive_tz(self):
+
+        tzinfo = tz.gettz("US/Pacific")
+
+        result = arrow.Arrow.span_range(
+            "hour", datetime(2013, 1, 1, 0), datetime(2013, 1, 1, 3, 59), "US/Pacific"
+        )
+
+        for f, c in result:
+            assert f.tzinfo == tzinfo
+            assert c.tzinfo == tzinfo
+
+    def test_aware_same_tz(self):
+
+        tzinfo = tz.gettz("US/Pacific")
+
+        result = arrow.Arrow.span_range(
+            "hour",
+            datetime(2013, 1, 1, 0, tzinfo=tzinfo),
+            datetime(2013, 1, 1, 2, 59, tzinfo=tzinfo),
+        )
+
+        for f, c in result:
+            assert f.tzinfo == tzinfo
+            assert c.tzinfo == tzinfo
+
+    def test_aware_different_tz(self):
+
+        tzinfo1 = tz.gettz("US/Pacific")
+        tzinfo2 = tz.gettz("US/Eastern")
+
+        result = arrow.Arrow.span_range(
+            "hour",
+            datetime(2013, 1, 1, 0, tzinfo=tzinfo1),
+            datetime(2013, 1, 1, 2, 59, tzinfo=tzinfo2),
+        )
+
+        for f, c in result:
+            assert f.tzinfo == tzinfo1
+            assert c.tzinfo == tzinfo1
+
+    def test_aware_tz(self):
+
+        result = arrow.Arrow.span_range(
+            "hour",
+            datetime(2013, 1, 1, 0, tzinfo=tz.gettz("US/Eastern")),
+            datetime(2013, 1, 1, 2, 59, tzinfo=tz.gettz("US/Eastern")),
+            tz="US/Central",
+        )
+
+        for f, c in result:
+            assert f.tzinfo == tz.gettz("US/Central")
+            assert c.tzinfo == tz.gettz("US/Central")
+
+    def test_bounds_param_is_passed(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "quarter", datetime(2013, 2, 2), datetime(2013, 5, 15), bounds="[]"
+            )
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 1, 1), arrow.Arrow(2013, 4, 1)),
+            (arrow.Arrow(2013, 4, 1), arrow.Arrow(2013, 7, 1)),
+        ]
+
+    def test_exact_bound_exclude(self):
+
+        result = list(
+            arrow.Arrow.span_range(
+                "hour",
+                datetime(2013, 5, 5, 12, 30),
+                datetime(2013, 5, 5, 17, 15),
+                bounds="[)",
+                exact=True,
+            )
+        )
+
+        expected = [
+            (
+                arrow.Arrow(2013, 5, 5, 12, 30),
+                arrow.Arrow(2013, 5, 5, 13, 29, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 13, 30),
+                arrow.Arrow(2013, 5, 5, 14, 29, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 14, 30),
+                arrow.Arrow(2013, 5, 5, 15, 29, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 15, 30),
+                arrow.Arrow(2013, 5, 5, 16, 29, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 16, 30),
+                arrow.Arrow(2013, 5, 5, 17, 14, 59, 999999),
+            ),
+        ]
+
+        assert result == expected
+
+    def test_exact_floor_equals_end(self):
+        result = list(
+            arrow.Arrow.span_range(
+                "minute",
+                datetime(2013, 5, 5, 12, 30),
+                datetime(2013, 5, 5, 12, 40),
+                exact=True,
+            )
+        )
+
+        expected = [
+            (
+                arrow.Arrow(2013, 5, 5, 12, 30),
+                arrow.Arrow(2013, 5, 5, 12, 30, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 31),
+                arrow.Arrow(2013, 5, 5, 12, 31, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 32),
+                arrow.Arrow(2013, 5, 5, 12, 32, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 33),
+                arrow.Arrow(2013, 5, 5, 12, 33, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 34),
+                arrow.Arrow(2013, 5, 5, 12, 34, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 35),
+                arrow.Arrow(2013, 5, 5, 12, 35, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 36),
+                arrow.Arrow(2013, 5, 5, 12, 36, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 37),
+                arrow.Arrow(2013, 5, 5, 12, 37, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 38),
+                arrow.Arrow(2013, 5, 5, 12, 38, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 12, 39),
+                arrow.Arrow(2013, 5, 5, 12, 39, 59, 999999),
+            ),
+        ]
+
+        assert result == expected
+
+    def test_exact_bound_include(self):
+        result = list(
+            arrow.Arrow.span_range(
+                "hour",
+                datetime(2013, 5, 5, 2, 30),
+                datetime(2013, 5, 5, 6, 00),
+                bounds="(]",
+                exact=True,
+            )
+        )
+
+        expected = [
+            (
+                arrow.Arrow(2013, 5, 5, 2, 30, 00, 1),
+                arrow.Arrow(2013, 5, 5, 3, 30, 00, 0),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 3, 30, 00, 1),
+                arrow.Arrow(2013, 5, 5, 4, 30, 00, 0),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 4, 30, 00, 1),
+                arrow.Arrow(2013, 5, 5, 5, 30, 00, 0),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 5, 30, 00, 1),
+                arrow.Arrow(2013, 5, 5, 6, 00),
+            ),
+        ]
+
+        assert result == expected
+
+    def test_small_interval_exact_open_bounds(self):
+        result = list(
+            arrow.Arrow.span_range(
+                "minute",
+                datetime(2013, 5, 5, 2, 30),
+                datetime(2013, 5, 5, 2, 31),
+                bounds="()",
+                exact=True,
+            )
+        )
+
+        expected = [
+            (
+                arrow.Arrow(2013, 5, 5, 2, 30, 00, 1),
+                arrow.Arrow(2013, 5, 5, 2, 30, 59, 999999),
+            ),
+        ]
+
+        assert result == expected
+
+
+class TestArrowInterval:
+    def test_incorrect_input(self):
+        with pytest.raises(ValueError):
+            list(
+                arrow.Arrow.interval(
+                    "month", datetime(2013, 1, 2), datetime(2013, 4, 15), 0
+                )
+            )
+
+    def test_correct(self):
+        result = list(
+            arrow.Arrow.interval(
+                "hour", datetime(2013, 5, 5, 12, 30), datetime(2013, 5, 5, 17, 15), 2
+            )
+        )
+
+        assert result == [
+            (
+                arrow.Arrow(2013, 5, 5, 12),
+                arrow.Arrow(2013, 5, 5, 13, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 14),
+                arrow.Arrow(2013, 5, 5, 15, 59, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 16),
+                arrow.Arrow(2013, 5, 5, 17, 59, 59, 999999),
+            ),
+        ]
+
+    def test_bounds_param_is_passed(self):
+        result = list(
+            arrow.Arrow.interval(
+                "hour",
+                datetime(2013, 5, 5, 12, 30),
+                datetime(2013, 5, 5, 17, 15),
+                2,
+                bounds="[]",
+            )
+        )
+
+        assert result == [
+            (arrow.Arrow(2013, 5, 5, 12), arrow.Arrow(2013, 5, 5, 14)),
+            (arrow.Arrow(2013, 5, 5, 14), arrow.Arrow(2013, 5, 5, 16)),
+            (arrow.Arrow(2013, 5, 5, 16), arrow.Arrow(2013, 5, 5, 18)),
+        ]
+
+    def test_exact(self):
+        result = list(
+            arrow.Arrow.interval(
+                "hour",
+                datetime(2013, 5, 5, 12, 30),
+                datetime(2013, 5, 5, 17, 15),
+                4,
+                exact=True,
+            )
+        )
+
+        expected = [
+            (
+                arrow.Arrow(2013, 5, 5, 12, 30),
+                arrow.Arrow(2013, 5, 5, 16, 29, 59, 999999),
+            ),
+            (
+                arrow.Arrow(2013, 5, 5, 16, 30),
+                arrow.Arrow(2013, 5, 5, 17, 14, 59, 999999),
+            ),
+        ]
+
+        assert result == expected
+
+
+@pytest.mark.usefixtures("time_2013_02_15")
+class TestArrowSpan:
+    def test_span_attribute(self):
+
+        with pytest.raises(ValueError):
+            self.arrow.span("span")
+
+    def test_span_year(self):
+
+        floor, ceil = self.arrow.span("year")
+
+        assert floor == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 12, 31, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_quarter(self):
+
+        floor, ceil = self.arrow.span("quarter")
+
+        assert floor == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 3, 31, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_quarter_count(self):
+
+        floor, ceil = self.arrow.span("quarter", 2)
+
+        assert floor == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 6, 30, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_year_count(self):
+
+        floor, ceil = self.arrow.span("year", 2)
+
+        assert floor == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2014, 12, 31, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_month(self):
+
+        floor, ceil = self.arrow.span("month")
+
+        assert floor == datetime(2013, 2, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 28, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_week(self):
+        """
+        >>> self.arrow.format("YYYY-MM-DD") == "2013-02-15"
+        >>> self.arrow.isoweekday() == 5  # a Friday
+        """
+        # span week from Monday to Sunday
+        floor, ceil = self.arrow.span("week")
+
+        assert floor == datetime(2013, 2, 11, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 17, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+        # span week from Tuesday to Monday
+        floor, ceil = self.arrow.span("week", week_start=2)
+
+        assert floor == datetime(2013, 2, 12, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 18, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+        # span week from Saturday to Friday
+        floor, ceil = self.arrow.span("week", week_start=6)
+
+        assert floor == datetime(2013, 2, 9, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+        # span week from Sunday to Saturday
+        floor, ceil = self.arrow.span("week", week_start=7)
+
+        assert floor == datetime(2013, 2, 10, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 16, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_day(self):
+
+        floor, ceil = self.arrow.span("day")
+
+        assert floor == datetime(2013, 2, 15, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 23, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_hour(self):
+
+        floor, ceil = self.arrow.span("hour")
+
+        assert floor == datetime(2013, 2, 15, 3, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_minute(self):
+
+        floor, ceil = self.arrow.span("minute")
+
+        assert floor == datetime(2013, 2, 15, 3, 41, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 41, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_span_second(self):
+
+        floor, ceil = self.arrow.span("second")
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 41, 22, 999999, tzinfo=tz.tzutc())
+
+    def test_span_microsecond(self):
+
+        floor, ceil = self.arrow.span("microsecond")
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, 8923, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 41, 22, 8923, tzinfo=tz.tzutc())
+
+    def test_floor(self):
+
+        floor, ceil = self.arrow.span("month")
+
+        assert floor == self.arrow.floor("month")
+        assert ceil == self.arrow.ceil("month")
+
+    def test_span_inclusive_inclusive(self):
+
+        floor, ceil = self.arrow.span("hour", bounds="[]")
+
+        assert floor == datetime(2013, 2, 15, 3, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 4, tzinfo=tz.tzutc())
+
+    def test_span_exclusive_inclusive(self):
+
+        floor, ceil = self.arrow.span("hour", bounds="(]")
+
+        assert floor == datetime(2013, 2, 15, 3, 0, 0, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 4, tzinfo=tz.tzutc())
+
+    def test_span_exclusive_exclusive(self):
+
+        floor, ceil = self.arrow.span("hour", bounds="()")
+
+        assert floor == datetime(2013, 2, 15, 3, 0, 0, 1, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 59, 59, 999999, tzinfo=tz.tzutc())
+
+    def test_bounds_are_validated(self):
+
+        with pytest.raises(ValueError):
+            floor, ceil = self.arrow.span("hour", bounds="][")
+
+    def test_exact(self):
+
+        result_floor, result_ceil = self.arrow.span("hour", exact=True)
+
+        expected_floor = datetime(2013, 2, 15, 3, 41, 22, 8923, tzinfo=tz.tzutc())
+        expected_ceil = datetime(2013, 2, 15, 4, 41, 22, 8922, tzinfo=tz.tzutc())
+
+        assert result_floor == expected_floor
+        assert result_ceil == expected_ceil
+
+    def test_exact_inclusive_inclusive(self):
+
+        floor, ceil = self.arrow.span("minute", bounds="[]", exact=True)
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, 8923, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 42, 22, 8923, tzinfo=tz.tzutc())
+
+    def test_exact_exclusive_inclusive(self):
+
+        floor, ceil = self.arrow.span("day", bounds="(]", exact=True)
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, 8924, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 16, 3, 41, 22, 8923, tzinfo=tz.tzutc())
+
+    def test_exact_exclusive_exclusive(self):
+
+        floor, ceil = self.arrow.span("second", bounds="()", exact=True)
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, 8924, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 2, 15, 3, 41, 23, 8922, tzinfo=tz.tzutc())
+
+    def test_all_parameters_specified(self):
+
+        floor, ceil = self.arrow.span("week", bounds="()", exact=True, count=2)
+
+        assert floor == datetime(2013, 2, 15, 3, 41, 22, 8924, tzinfo=tz.tzutc())
+        assert ceil == datetime(2013, 3, 1, 3, 41, 22, 8922, tzinfo=tz.tzutc())
+
+
+@pytest.mark.usefixtures("time_2013_01_01")
+class TestArrowHumanize:
+    def test_granularity(self):
+
+        assert self.now.humanize(granularity="second") == "just now"
+
+        later1 = self.now.shift(seconds=1)
+        assert self.now.humanize(later1, granularity="second") == "just now"
+        assert later1.humanize(self.now, granularity="second") == "just now"
+        assert self.now.humanize(later1, granularity="minute") == "0 minutes ago"
+        assert later1.humanize(self.now, granularity="minute") == "in 0 minutes"
+
+        later100 = self.now.shift(seconds=100)
+        assert self.now.humanize(later100, granularity="second") == "100 seconds ago"
+        assert later100.humanize(self.now, granularity="second") == "in 100 seconds"
+        assert self.now.humanize(later100, granularity="minute") == "a minute ago"
+        assert later100.humanize(self.now, granularity="minute") == "in a minute"
+        assert self.now.humanize(later100, granularity="hour") == "0 hours ago"
+        assert later100.humanize(self.now, granularity="hour") == "in 0 hours"
+
+        later4000 = self.now.shift(seconds=4000)
+        assert self.now.humanize(later4000, granularity="minute") == "66 minutes ago"
+        assert later4000.humanize(self.now, granularity="minute") == "in 66 minutes"
+        assert self.now.humanize(later4000, granularity="hour") == "an hour ago"
+        assert later4000.humanize(self.now, granularity="hour") == "in an hour"
+        assert self.now.humanize(later4000, granularity="day") == "0 days ago"
+        assert later4000.humanize(self.now, granularity="day") == "in 0 days"
+
+        later105 = self.now.shift(seconds=10 ** 5)
+        assert self.now.humanize(later105, granularity="hour") == "27 hours ago"
+        assert later105.humanize(self.now, granularity="hour") == "in 27 hours"
+        assert self.now.humanize(later105, granularity="day") == "a day ago"
+        assert later105.humanize(self.now, granularity="day") == "in a day"
+        assert self.now.humanize(later105, granularity="week") == "0 weeks ago"
+        assert later105.humanize(self.now, granularity="week") == "in 0 weeks"
+        assert self.now.humanize(later105, granularity="month") == "0 months ago"
+        assert later105.humanize(self.now, granularity="month") == "in 0 months"
+        assert self.now.humanize(later105, granularity=["month"]) == "0 months ago"
+        assert later105.humanize(self.now, granularity=["month"]) == "in 0 months"
+
+        later106 = self.now.shift(seconds=3 * 10 ** 6)
+        assert self.now.humanize(later106, granularity="day") == "34 days ago"
+        assert later106.humanize(self.now, granularity="day") == "in 34 days"
+        assert self.now.humanize(later106, granularity="week") == "4 weeks ago"
+        assert later106.humanize(self.now, granularity="week") == "in 4 weeks"
+        assert self.now.humanize(later106, granularity="month") == "a month ago"
+        assert later106.humanize(self.now, granularity="month") == "in a month"
+        assert self.now.humanize(later106, granularity="year") == "0 years ago"
+        assert later106.humanize(self.now, granularity="year") == "in 0 years"
+
+        later506 = self.now.shift(seconds=50 * 10 ** 6)
+        assert self.now.humanize(later506, granularity="week") == "82 weeks ago"
+        assert later506.humanize(self.now, granularity="week") == "in 82 weeks"
+        assert self.now.humanize(later506, granularity="month") == "18 months ago"
+        assert later506.humanize(self.now, granularity="month") == "in 18 months"
+        assert self.now.humanize(later506, granularity="quarter") == "6 quarters ago"
+        assert later506.humanize(self.now, granularity="quarter") == "in 6 quarters"
+        assert self.now.humanize(later506, granularity="year") == "a year ago"
+        assert later506.humanize(self.now, granularity="year") == "in a year"
+
+        assert self.now.humanize(later1, granularity="quarter") == "0 quarters ago"
+        assert later1.humanize(self.now, granularity="quarter") == "in 0 quarters"
+        later107 = self.now.shift(seconds=10 ** 7)
+        assert self.now.humanize(later107, granularity="quarter") == "a quarter ago"
+        assert later107.humanize(self.now, granularity="quarter") == "in a quarter"
+        later207 = self.now.shift(seconds=2 * 10 ** 7)
+        assert self.now.humanize(later207, granularity="quarter") == "2 quarters ago"
+        assert later207.humanize(self.now, granularity="quarter") == "in 2 quarters"
+        later307 = self.now.shift(seconds=3 * 10 ** 7)
+        assert self.now.humanize(later307, granularity="quarter") == "3 quarters ago"
+        assert later307.humanize(self.now, granularity="quarter") == "in 3 quarters"
+        later377 = self.now.shift(seconds=3.7 * 10 ** 7)
+        assert self.now.humanize(later377, granularity="quarter") == "4 quarters ago"
+        assert later377.humanize(self.now, granularity="quarter") == "in 4 quarters"
+        later407 = self.now.shift(seconds=4 * 10 ** 7)
+        assert self.now.humanize(later407, granularity="quarter") == "5 quarters ago"
+        assert later407.humanize(self.now, granularity="quarter") == "in 5 quarters"
+
+        later108 = self.now.shift(seconds=10 ** 8)
+        assert self.now.humanize(later108, granularity="year") == "3 years ago"
+        assert later108.humanize(self.now, granularity="year") == "in 3 years"
+
+        later108onlydistance = self.now.shift(seconds=10 ** 8)
+        assert (
+            self.now.humanize(
+                later108onlydistance, only_distance=True, granularity="year"
+            )
+            == "3 years"
+        )
+        assert (
+            later108onlydistance.humanize(
+                self.now, only_distance=True, granularity="year"
+            )
+            == "3 years"
+        )
+
+        with pytest.raises(ValueError):
+            self.now.humanize(later108, granularity="years")
+
+    def test_multiple_granularity(self):
+        assert self.now.humanize(granularity="second") == "just now"
+        assert self.now.humanize(granularity=["second"]) == "just now"
+        assert (
+            self.now.humanize(granularity=["year", "month", "day", "hour", "second"])
+            == "in 0 years 0 months 0 days 0 hours and 0 seconds"
+        )
+
+        later4000 = self.now.shift(seconds=4000)
+        assert (
+            later4000.humanize(self.now, granularity=["hour", "minute"])
+            == "in an hour and 6 minutes"
+        )
+        assert (
+            self.now.humanize(later4000, granularity=["hour", "minute"])
+            == "an hour and 6 minutes ago"
+        )
+        assert (
+            later4000.humanize(
+                self.now, granularity=["hour", "minute"], only_distance=True
+            )
+            == "an hour and 6 minutes"
+        )
+        assert (
+            later4000.humanize(self.now, granularity=["day", "hour", "minute"])
+            == "in 0 days an hour and 6 minutes"
+        )
+        assert (
+            self.now.humanize(later4000, granularity=["day", "hour", "minute"])
+            == "0 days an hour and 6 minutes ago"
+        )
+
+        later105 = self.now.shift(seconds=10 ** 5)
+        assert (
+            self.now.humanize(later105, granularity=["hour", "day", "minute"])
+            == "a day 3 hours and 46 minutes ago"
+        )
+        with pytest.raises(ValueError):
+            self.now.humanize(later105, granularity=["error", "second"])
+
+        later108onlydistance = self.now.shift(seconds=10 ** 8)
+        assert (
+            self.now.humanize(
+                later108onlydistance, only_distance=True, granularity=["year"]
+            )
+            == "3 years"
+        )
+        assert (
+            self.now.humanize(
+                later108onlydistance, only_distance=True, granularity=["month", "week"]
+            )
+            == "37 months and 4 weeks"
+        )
+        # this will change when leap years are implemented
+        assert (
+            self.now.humanize(
+                later108onlydistance, only_distance=True, granularity=["year", "second"]
+            )
+            == "3 years and 5392000 seconds"
+        )
+
+        one_min_one_sec_ago = self.now.shift(minutes=-1, seconds=-1)
+        assert (
+            one_min_one_sec_ago.humanize(self.now, granularity=["minute", "second"])
+            == "a minute and a second ago"
+        )
+
+        one_min_two_secs_ago = self.now.shift(minutes=-1, seconds=-2)
+        assert (
+            one_min_two_secs_ago.humanize(self.now, granularity=["minute", "second"])
+            == "a minute and 2 seconds ago"
+        )
+
+    def test_seconds(self):
+
+        later = self.now.shift(seconds=10)
+
+        # regression test for issue #727
+        assert self.now.humanize(later) == "10 seconds ago"
+        assert later.humanize(self.now) == "in 10 seconds"
+
+        assert self.now.humanize(later, only_distance=True) == "10 seconds"
+        assert later.humanize(self.now, only_distance=True) == "10 seconds"
+
+    def test_minute(self):
+
+        later = self.now.shift(minutes=1)
+
+        assert self.now.humanize(later) == "a minute ago"
+        assert later.humanize(self.now) == "in a minute"
+
+        assert self.now.humanize(later, only_distance=True) == "a minute"
+        assert later.humanize(self.now, only_distance=True) == "a minute"
+
+    def test_minutes(self):
+
+        later = self.now.shift(minutes=2)
+
+        assert self.now.humanize(later) == "2 minutes ago"
+        assert later.humanize(self.now) == "in 2 minutes"
+
+        assert self.now.humanize(later, only_distance=True) == "2 minutes"
+        assert later.humanize(self.now, only_distance=True) == "2 minutes"
+
+    def test_hour(self):
+
+        later = self.now.shift(hours=1)
+
+        assert self.now.humanize(later) == "an hour ago"
+        assert later.humanize(self.now) == "in an hour"
+
+        assert self.now.humanize(later, only_distance=True) == "an hour"
+        assert later.humanize(self.now, only_distance=True) == "an hour"
+
+    def test_hours(self):
+
+        later = self.now.shift(hours=2)
+
+        assert self.now.humanize(later) == "2 hours ago"
+        assert later.humanize(self.now) == "in 2 hours"
+
+        assert self.now.humanize(later, only_distance=True) == "2 hours"
+        assert later.humanize(self.now, only_distance=True) == "2 hours"
+
+    def test_day(self):
+
+        later = self.now.shift(days=1)
+
+        assert self.now.humanize(later) == "a day ago"
+        assert later.humanize(self.now) == "in a day"
+
+        # regression test for issue #697
+        less_than_48_hours = self.now.shift(
+            days=1, hours=23, seconds=59, microseconds=999999
+        )
+        assert self.now.humanize(less_than_48_hours) == "a day ago"
+        assert less_than_48_hours.humanize(self.now) == "in a day"
+
+        less_than_48_hours_date = less_than_48_hours._datetime.date()
+        with pytest.raises(TypeError):
+            # humanize other argument does not take raw datetime.date objects
+            self.now.humanize(less_than_48_hours_date)
+
+        assert self.now.humanize(later, only_distance=True) == "a day"
+        assert later.humanize(self.now, only_distance=True) == "a day"
+
+    def test_days(self):
+
+        later = self.now.shift(days=2)
+
+        assert self.now.humanize(later) == "2 days ago"
+        assert later.humanize(self.now) == "in 2 days"
+
+        assert self.now.humanize(later, only_distance=True) == "2 days"
+        assert later.humanize(self.now, only_distance=True) == "2 days"
+
+        # Regression tests for humanize bug referenced in issue 541
+        later = self.now.shift(days=3)
+        assert later.humanize(self.now) == "in 3 days"
+
+        later = self.now.shift(days=3, seconds=1)
+        assert later.humanize(self.now) == "in 3 days"
+
+        later = self.now.shift(days=4)
+        assert later.humanize(self.now) == "in 4 days"
+
+    def test_week(self):
+
+        later = self.now.shift(weeks=1)
+
+        assert self.now.humanize(later) == "a week ago"
+        assert later.humanize(self.now) == "in a week"
+
+        assert self.now.humanize(later, only_distance=True) == "a week"
+        assert later.humanize(self.now, only_distance=True) == "a week"
+
+    def test_weeks(self):
+
+        later = self.now.shift(weeks=2)
+
+        assert self.now.humanize(later) == "2 weeks ago"
+        assert later.humanize(self.now) == "in 2 weeks"
+
+        assert self.now.humanize(later, only_distance=True) == "2 weeks"
+        assert later.humanize(self.now, only_distance=True) == "2 weeks"
+
+    @pytest.mark.xfail(reason="known issue with humanize month limits")
+    def test_month(self):
+
+        later = self.now.shift(months=1)
+
+        # TODO this test now returns "4 weeks ago", we need to fix this to be correct on a per month basis
+        assert self.now.humanize(later) == "a month ago"
+        assert later.humanize(self.now) == "in a month"
+
+        assert self.now.humanize(later, only_distance=True) == "a month"
+        assert later.humanize(self.now, only_distance=True) == "a month"
+
+    def test_month_plus_4_days(self):
+
+        # TODO needed for coverage, remove when month limits are fixed
+        later = self.now.shift(months=1, days=4)
+
+        assert self.now.humanize(later) == "a month ago"
+        assert later.humanize(self.now) == "in a month"
+
+    @pytest.mark.xfail(reason="known issue with humanize month limits")
+    def test_months(self):
+
+        later = self.now.shift(months=2)
+        earlier = self.now.shift(months=-2)
+
+        assert earlier.humanize(self.now) == "2 months ago"
+        assert later.humanize(self.now) == "in 2 months"
+
+        assert self.now.humanize(later, only_distance=True) == "2 months"
+        assert later.humanize(self.now, only_distance=True) == "2 months"
+
+    def test_year(self):
+
+        later = self.now.shift(years=1)
+
+        assert self.now.humanize(later) == "a year ago"
+        assert later.humanize(self.now) == "in a year"
+
+        assert self.now.humanize(later, only_distance=True) == "a year"
+        assert later.humanize(self.now, only_distance=True) == "a year"
+
+    def test_years(self):
+
+        later = self.now.shift(years=2)
+
+        assert self.now.humanize(later) == "2 years ago"
+        assert later.humanize(self.now) == "in 2 years"
+
+        assert self.now.humanize(later, only_distance=True) == "2 years"
+        assert later.humanize(self.now, only_distance=True) == "2 years"
+
+        arw = arrow.Arrow(2014, 7, 2)
+
+        result = arw.humanize(self.datetime)
+
+        assert result == "in a year"
+
+    def test_arrow(self):
+
+        arw = arrow.Arrow.fromdatetime(self.datetime)
+
+        result = arw.humanize(arrow.Arrow.fromdatetime(self.datetime))
+
+        assert result == "just now"
+
+    def test_datetime_tzinfo(self):
+
+        arw = arrow.Arrow.fromdatetime(self.datetime)
+
+        result = arw.humanize(self.datetime.replace(tzinfo=tz.tzutc()))
+
+        assert result == "just now"
+
+    def test_other(self):
+
+        arw = arrow.Arrow.fromdatetime(self.datetime)
+
+        with pytest.raises(TypeError):
+            arw.humanize(object())
+
+    def test_invalid_locale(self):
+
+        arw = arrow.Arrow.fromdatetime(self.datetime)
+
+        with pytest.raises(ValueError):
+            arw.humanize(locale="klingon")
+
+    def test_none(self):
+
+        arw = arrow.Arrow.utcnow()
+
+        result = arw.humanize()
+
+        assert result == "just now"
+
+        result = arw.humanize(None)
+
+        assert result == "just now"
+
+    def test_week_limit(self):
+        # regression test for issue #848
+        arw = arrow.Arrow.utcnow()
+
+        later = arw.shift(weeks=+1)
+
+        result = arw.humanize(later)
+
+        assert result == "a week ago"
+
+    def test_untranslated_granularity(self, mocker):
+
+        arw = arrow.Arrow.utcnow()
+        later = arw.shift(weeks=1)
+
+        # simulate an untranslated timeframe key
+        mocker.patch.dict("arrow.locales.EnglishLocale.timeframes")
+        del arrow.locales.EnglishLocale.timeframes["week"]
+        with pytest.raises(ValueError):
+            arw.humanize(later, granularity="week")
+
+    def test_empty_granularity_list(self):
+        arw = arrow.Arrow(2013, 1, 1, 0, 0, 0)
+        later = arw.shift(seconds=55000)
+
+        with pytest.raises(ValueError):
+            arw.humanize(later, granularity=[])
+
+    # Bulgarian is an example of a language that overrides _format_timeframe
+    # Applicabale to all locales. Note: Contributors need to make sure
+    # that if they override describe or describe_mutli, that delta
+    # is truncated on call
+
+    def test_no_floats(self):
+        arw = arrow.Arrow(2013, 1, 1, 0, 0, 0)
+        later = arw.shift(seconds=55000)
+        humanize_string = arw.humanize(later, locale="bg", granularity="minute")
+        assert humanize_string == "916  "
+
+    def test_no_floats_multi_gran(self):
+        arw = arrow.Arrow(2013, 1, 1, 0, 0, 0)
+        later = arw.shift(seconds=55000)
+        humanize_string = arw.humanize(
+            later, locale="bg", granularity=["second", "minute"]
+        )
+        assert humanize_string == "916  40   "
+
+
+@pytest.mark.usefixtures("time_2013_01_01")
+class TestArrowHumanizeTestsWithLocale:
+    def test_now(self):
+
+        arw = arrow.Arrow(2013, 1, 1, 0, 0, 0)
+
+        result = arw.humanize(self.datetime, locale="ru")
+
+        assert result == ""
+
+    def test_seconds(self):
+        arw = arrow.Arrow(2013, 1, 1, 0, 0, 44)
+
+        result = arw.humanize(self.datetime, locale="ru")
+        assert result == " 44 "
+
+    def test_years(self):
+
+        arw = arrow.Arrow(2011, 7, 2)
+
+        result = arw.humanize(self.datetime, locale="ru")
+
+        assert result == " "
+
+
+# Fixtures for Dehumanize
+@pytest.fixture(scope="class")
+def locale_list_no_weeks() -> List[str]:
+    tested_langs = [
+        "en",
+        "en-us",
+        "en-gb",
+        "en-au",
+        "en-be",
+        "en-jp",
+        "en-za",
+        "en-ca",
+        "en-ph",
+        "fr",
+        "fr-fr",
+        "fr-ca",
+        "it",
+        "it-it",
+        "es",
+        "es-es",
+        "el",
+        "el-gr",
+        "ja",
+        "ja-jp",
+        "sv",
+        "sv-se",
+        "fi",
+        "fi-fi",
+        "zh",
+        "zh-cn",
+        "zh-tw",
+        "zh-hk",
+        "nl",
+        "nl-nl",
+        "be",
+        "be-by",
+        "pl",
+        "pl-pl",
+        "ru",
+        "ru-ru",
+        "af",
+        "bg",
+        "bg-bg",
+        "ua",
+        "uk",
+        "uk-ua",
+        "mk",
+        "mk-mk",
+        "de",
+        "de-de",
+        "de-ch",
+        "de-at",
+        "nb",
+        "nb-no",
+        "nn",
+        "nn-no",
+        "pt",
+        "pt-pt",
+        "pt_br",
+        "tl",
+        "tl-ph",
+        "vi",
+        "vi-vn",
+        "tr",
+        "tr-tr",
+        "az",
+        "az-az",
+        "da",
+        "da-dk",
+        "ml",
+        "hi",
+        "cs",
+        "cs-cz",
+        "sk",
+        "sk-sk",
+        "fa",
+        "fa-ir",
+        "mr",
+        "ca",
+        "ca-es",
+        "ca-ad",
+        "ca-fr",
+        "ca-it",
+        "eo",
+        "eo-xx",
+        "bn",
+        "bn-bd",
+        "bn-in",
+        "rm",
+        "rm-ch",
+        "ro",
+        "ro-ro",
+        "sl",
+        "sl-si",
+        "id",
+        "id-id",
+        "ne",
+        "ne-np",
+        "ee",
+        "et",
+        "sw",
+        "sw-ke",
+        "sw-tz",
+        "la",
+        "la-va",
+        "lt",
+        "lt-lt",
+        "ms",
+        "ms-my",
+        "ms-bn",
+        "or",
+        "or-in",
+        "se",
+        "se-fi",
+        "se-no",
+        "se-se",
+        "lb",
+        "lb-lu",
+        "zu",
+        "zu-za",
+        "sq",
+        "sq-al",
+        "ta",
+        "ta-in",
+        "ta-lk",
+        "ur",
+        "ur-pk",
+        "kk",
+        "kk-kz",
+    ]
+
+    return tested_langs
+
+
+@pytest.fixture(scope="class")
+def locale_list_with_weeks() -> List[str]:
+    tested_langs = [
+        "en",
+        "en-us",
+        "en-gb",
+        "en-au",
+        "en-be",
+        "en-jp",
+        "en-za",
+        "en-ca",
+        "en-ph",
+        "fr",
+        "fr-fr",
+        "fr-ca",
+        "it",
+        "it-it",
+        "es",
+        "es-es",
+        "ja",
+        "ja-jp",
+        "sv",
+        "sv-se",
+        "zh",
+        "zh-cn",
+        "zh-tw",
+        "zh-hk",
+        "nl",
+        "nl-nl",
+        "pl",
+        "pl-pl",
+        "ru",
+        "ru-ru",
+        "mk",
+        "mk-mk",
+        "de",
+        "de-de",
+        "de-ch",
+        "de-at",
+        "pt",
+        "pt-pt",
+        "pt-br",
+        "cs",
+        "cs-cz",
+        "sk",
+        "sk-sk",
+        "tl",
+        "tl-ph",
+        "vi",
+        "vi-vn",
+        "sw",
+        "sw-ke",
+        "sw-tz",
+        "la",
+        "la-va",
+        "lt",
+        "lt-lt",
+        "ms",
+        "ms-my",
+        "ms-bn",
+        "lb",
+        "lb-lu",
+        "zu",
+        "zu-za",
+        "ta",
+        "ta-in",
+        "ta-lk",
+        "kk",
+        "kk-kz",
+    ]
+
+    return tested_langs
+
+
+@pytest.fixture(scope="class")
+def slavic_locales() -> List[str]:
+    tested_langs = [
+        "be",
+        "be-by",
+        "pl",
+        "pl-pl",
+        "ru",
+        "ru-ru",
+        "bg",
+        "bg-bg",
+        "ua",
+        "uk",
+        "uk-ua",
+        "mk",
+        "mk-mk",
+    ]
+
+    return tested_langs
+
+
+class TestArrowDehumanize:
+    def test_now(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+            second_ago = arw.shift(seconds=-1)
+            second_future = arw.shift(seconds=1)
+
+            second_ago_string = second_ago.humanize(
+                arw, locale=lang, granularity=["second"]
+            )
+            second_future_string = second_future.humanize(
+                arw, locale=lang, granularity=["second"]
+            )
+
+            assert arw.dehumanize(second_ago_string, locale=lang) == arw
+            assert arw.dehumanize(second_future_string, locale=lang) == arw
+
+    def test_seconds(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+            second_ago = arw.shift(seconds=-5)
+            second_future = arw.shift(seconds=5)
+
+            second_ago_string = second_ago.humanize(
+                arw, locale=lang, granularity=["second"]
+            )
+            second_future_string = second_future.humanize(
+                arw, locale=lang, granularity=["second"]
+            )
+
+            assert arw.dehumanize(second_ago_string, locale=lang) == second_ago
+            assert arw.dehumanize(second_future_string, locale=lang) == second_future
+
+    def test_minute(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2001, 6, 18, 5, 55, 0)
+            minute_ago = arw.shift(minutes=-1)
+            minute_future = arw.shift(minutes=1)
+
+            minute_ago_string = minute_ago.humanize(
+                arw, locale=lang, granularity=["minute"]
+            )
+            minute_future_string = minute_future.humanize(
+                arw, locale=lang, granularity=["minute"]
+            )
+
+            assert arw.dehumanize(minute_ago_string, locale=lang) == minute_ago
+            assert arw.dehumanize(minute_future_string, locale=lang) == minute_future
+
+    def test_minutes(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2007, 1, 10, 5, 55, 0)
+            minute_ago = arw.shift(minutes=-5)
+            minute_future = arw.shift(minutes=5)
+
+            minute_ago_string = minute_ago.humanize(
+                arw, locale=lang, granularity=["minute"]
+            )
+            minute_future_string = minute_future.humanize(
+                arw, locale=lang, granularity=["minute"]
+            )
+
+            assert arw.dehumanize(minute_ago_string, locale=lang) == minute_ago
+            assert arw.dehumanize(minute_future_string, locale=lang) == minute_future
+
+    def test_hour(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2009, 4, 20, 5, 55, 0)
+            hour_ago = arw.shift(hours=-1)
+            hour_future = arw.shift(hours=1)
+
+            hour_ago_string = hour_ago.humanize(arw, locale=lang, granularity=["hour"])
+            hour_future_string = hour_future.humanize(
+                arw, locale=lang, granularity=["hour"]
+            )
+
+            assert arw.dehumanize(hour_ago_string, locale=lang) == hour_ago
+            assert arw.dehumanize(hour_future_string, locale=lang) == hour_future
+
+    def test_hours(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2010, 2, 16, 7, 55, 0)
+            hour_ago = arw.shift(hours=-3)
+            hour_future = arw.shift(hours=3)
+
+            hour_ago_string = hour_ago.humanize(arw, locale=lang, granularity=["hour"])
+            hour_future_string = hour_future.humanize(
+                arw, locale=lang, granularity=["hour"]
+            )
+
+            assert arw.dehumanize(hour_ago_string, locale=lang) == hour_ago
+            assert arw.dehumanize(hour_future_string, locale=lang) == hour_future
+
+    def test_week(self, locale_list_with_weeks: List[str]):
+
+        for lang in locale_list_with_weeks:
+
+            arw = arrow.Arrow(2012, 2, 18, 1, 52, 0)
+            week_ago = arw.shift(weeks=-1)
+            week_future = arw.shift(weeks=1)
+
+            week_ago_string = week_ago.humanize(arw, locale=lang, granularity=["week"])
+            week_future_string = week_future.humanize(
+                arw, locale=lang, granularity=["week"]
+            )
+
+            assert arw.dehumanize(week_ago_string, locale=lang) == week_ago
+            assert arw.dehumanize(week_future_string, locale=lang) == week_future
+
+    def test_weeks(self, locale_list_with_weeks: List[str]):
+
+        for lang in locale_list_with_weeks:
+
+            arw = arrow.Arrow(2020, 3, 18, 5, 3, 0)
+            week_ago = arw.shift(weeks=-7)
+            week_future = arw.shift(weeks=7)
+
+            week_ago_string = week_ago.humanize(arw, locale=lang, granularity=["week"])
+            week_future_string = week_future.humanize(
+                arw, locale=lang, granularity=["week"]
+            )
+
+            assert arw.dehumanize(week_ago_string, locale=lang) == week_ago
+            assert arw.dehumanize(week_future_string, locale=lang) == week_future
+
+    def test_year(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            year_ago = arw.shift(years=-1)
+            year_future = arw.shift(years=1)
+
+            year_ago_string = year_ago.humanize(arw, locale=lang, granularity=["year"])
+            year_future_string = year_future.humanize(
+                arw, locale=lang, granularity=["year"]
+            )
+
+            assert arw.dehumanize(year_ago_string, locale=lang) == year_ago
+            assert arw.dehumanize(year_future_string, locale=lang) == year_future
+
+    def test_years(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            year_ago = arw.shift(years=-10)
+            year_future = arw.shift(years=10)
+
+            year_ago_string = year_ago.humanize(arw, locale=lang, granularity=["year"])
+            year_future_string = year_future.humanize(
+                arw, locale=lang, granularity=["year"]
+            )
+
+            assert arw.dehumanize(year_ago_string, locale=lang) == year_ago
+            assert arw.dehumanize(year_future_string, locale=lang) == year_future
+
+    def test_gt_than_10_years(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            year_ago = arw.shift(years=-25)
+            year_future = arw.shift(years=25)
+
+            year_ago_string = year_ago.humanize(arw, locale=lang, granularity=["year"])
+            year_future_string = year_future.humanize(
+                arw, locale=lang, granularity=["year"]
+            )
+
+            assert arw.dehumanize(year_ago_string, locale=lang) == year_ago
+            assert arw.dehumanize(year_future_string, locale=lang) == year_future
+
+    def test_mixed_granularity(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            past = arw.shift(hours=-1, minutes=-1, seconds=-1)
+            future = arw.shift(hours=1, minutes=1, seconds=1)
+
+            past_string = past.humanize(
+                arw, locale=lang, granularity=["hour", "minute", "second"]
+            )
+            future_string = future.humanize(
+                arw, locale=lang, granularity=["hour", "minute", "second"]
+            )
+
+            assert arw.dehumanize(past_string, locale=lang) == past
+            assert arw.dehumanize(future_string, locale=lang) == future
+
+    def test_mixed_granularity_hours(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            past = arw.shift(hours=-3, minutes=-1, seconds=-15)
+            future = arw.shift(hours=3, minutes=1, seconds=15)
+
+            past_string = past.humanize(
+                arw, locale=lang, granularity=["hour", "minute", "second"]
+            )
+            future_string = future.humanize(
+                arw, locale=lang, granularity=["hour", "minute", "second"]
+            )
+
+            assert arw.dehumanize(past_string, locale=lang) == past
+            assert arw.dehumanize(future_string, locale=lang) == future
+
+    def test_mixed_granularity_day(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            past = arw.shift(days=-3, minutes=-1, seconds=-15)
+            future = arw.shift(days=3, minutes=1, seconds=15)
+
+            past_string = past.humanize(
+                arw, locale=lang, granularity=["day", "minute", "second"]
+            )
+            future_string = future.humanize(
+                arw, locale=lang, granularity=["day", "minute", "second"]
+            )
+
+            assert arw.dehumanize(past_string, locale=lang) == past
+            assert arw.dehumanize(future_string, locale=lang) == future
+
+    def test_mixed_granularity_day_hour(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 1, 10, 5, 55, 0)
+            past = arw.shift(days=-3, hours=-23, seconds=-15)
+            future = arw.shift(days=3, hours=23, seconds=15)
+
+            past_string = past.humanize(
+                arw, locale=lang, granularity=["day", "hour", "second"]
+            )
+            future_string = future.humanize(
+                arw, locale=lang, granularity=["day", "hour", "second"]
+            )
+
+            assert arw.dehumanize(past_string, locale=lang) == past
+            assert arw.dehumanize(future_string, locale=lang) == future
+
+    # Test to make sure unsupported locales error out
+    def test_unsupported_locale(self):
+
+        arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+        second_ago = arw.shift(seconds=-5)
+        second_future = arw.shift(seconds=5)
+
+        second_ago_string = second_ago.humanize(
+            arw, locale="ko", granularity=["second"]
+        )
+        second_future_string = second_future.humanize(
+            arw, locale="ko", granularity=["second"]
+        )
+
+        # ko is an example of many unsupported locales currently
+        with pytest.raises(ValueError):
+            arw.dehumanize(second_ago_string, locale="ko")
+
+        with pytest.raises(ValueError):
+            arw.dehumanize(second_future_string, locale="ko")
+
+    # Test to ensure old style locale strings are supported
+    def test_normalized_locale(self):
+
+        arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+        second_ago = arw.shift(seconds=-5)
+        second_future = arw.shift(seconds=5)
+
+        second_ago_string = second_ago.humanize(
+            arw, locale="zh_hk", granularity=["second"]
+        )
+        second_future_string = second_future.humanize(
+            arw, locale="zh_hk", granularity=["second"]
+        )
+
+        assert arw.dehumanize(second_ago_string, locale="zh_hk") == second_ago
+        assert arw.dehumanize(second_future_string, locale="zh_hk") == second_future
+
+    # Ensures relative units are required in string
+    def test_require_relative_unit(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+            second_ago = arw.shift(seconds=-5)
+            second_future = arw.shift(seconds=5)
+
+            second_ago_string = second_ago.humanize(
+                arw, locale=lang, granularity=["second"], only_distance=True
+            )
+            second_future_string = second_future.humanize(
+                arw, locale=lang, granularity=["second"], only_distance=True
+            )
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(second_ago_string, locale=lang)
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(second_future_string, locale=lang)
+
+    # Test for scrambled input
+    def test_scrambled_input(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+            second_ago = arw.shift(seconds=-5)
+            second_future = arw.shift(seconds=5)
+
+            second_ago_string = second_ago.humanize(
+                arw, locale=lang, granularity=["second"], only_distance=True
+            )
+            second_future_string = second_future.humanize(
+                arw, locale=lang, granularity=["second"], only_distance=True
+            )
+
+            # Scrambles input by sorting strings
+            second_ago_presort = sorted(second_ago_string)
+            second_ago_string = "".join(second_ago_presort)
+
+            second_future_presort = sorted(second_future_string)
+            second_future_string = "".join(second_future_presort)
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(second_ago_string, locale=lang)
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(second_future_string, locale=lang)
+
+    def test_no_units_modified(self, locale_list_no_weeks: List[str]):
+
+        for lang in locale_list_no_weeks:
+
+            arw = arrow.Arrow(2000, 6, 18, 5, 55, 0)
+
+            # Ensures we pass the first stage of checking whether relative units exist
+            locale_obj = locales.get_locale(lang)
+            empty_past_string = locale_obj.past
+            empty_future_string = locale_obj.future
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(empty_past_string, locale=lang)
+
+            with pytest.raises(ValueError):
+                arw.dehumanize(empty_future_string, locale=lang)
+
+    def test_slavic_locales(self, slavic_locales: List[str]):
+
+        # Relevant units for Slavic locale plural logic
+        units = [
+            0,
+            1,
+            2,
+            5,
+            21,
+            22,
+            25,
+        ]
+
+        # Only need to test on seconds as logic holds for all slavic plural units
+        for lang in slavic_locales:
+            for unit in units:
+                arw = arrow.Arrow(2000, 2, 18, 1, 50, 30)
+
+                past = arw.shift(minutes=-1 * unit, days=-1)
+                future = arw.shift(minutes=unit, days=1)
+
+                past_string = past.humanize(
+                    arw, locale=lang, granularity=["minute", "day"]
+                )
+                future_string = future.humanize(
+                    arw, locale=lang, granularity=["minute", "day"]
+                )
+
+                assert arw.dehumanize(past_string, locale=lang) == past
+                assert arw.dehumanize(future_string, locale=lang) == future
+
+    def test_czech_slovak(self):
+
+        # Relevant units for Slavic locale plural logic
+        units = [
+            0,
+            1,
+            2,
+            5,
+        ]
+
+        # Only need to test on seconds as logic holds for all slavic plural units
+        for lang in ["cs"]:
+            for unit in units:
+                arw = arrow.Arrow(2000, 2, 18, 1, 50, 30)
+
+                past = arw.shift(minutes=-1 * unit, days=-1)
+                future = arw.shift(minutes=unit, days=1)
+
+                past_string = past.humanize(
+                    arw, locale=lang, granularity=["minute", "day"]
+                )
+                future_string = future.humanize(
+                    arw, locale=lang, granularity=["minute", "day"]
+                )
+
+                assert arw.dehumanize(past_string, locale=lang) == past
+                assert arw.dehumanize(future_string, locale=lang) == future
+
+
+class TestArrowIsBetween:
+    def test_start_before_end(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 8))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 5))
+        assert not target.is_between(start, end)
+
+    def test_exclusive_exclusive_bounds(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 5, 12, 30, 27))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 5, 12, 30, 10))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 5, 12, 30, 36))
+        assert target.is_between(start, end, "()")
+
+    def test_exclusive_exclusive_bounds_same_date(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        assert not target.is_between(start, end, "()")
+
+    def test_inclusive_exclusive_bounds(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 6))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 4))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 6))
+        assert not target.is_between(start, end, "[)")
+
+    def test_exclusive_inclusive_bounds(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 5))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        assert target.is_between(start, end, "(]")
+
+    def test_inclusive_inclusive_bounds_same_date(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        assert target.is_between(start, end, "[]")
+
+    def test_inclusive_inclusive_bounds_target_before_start(self):
+        target = arrow.Arrow.fromdatetime(datetime(2020, 12, 24))
+        start = arrow.Arrow.fromdatetime(datetime(2020, 12, 25))
+        end = arrow.Arrow.fromdatetime(datetime(2020, 12, 26))
+        assert not target.is_between(start, end, "[]")
+
+    def test_type_error_exception(self):
+        with pytest.raises(TypeError):
+            target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+            start = datetime(2013, 5, 5)
+            end = arrow.Arrow.fromdatetime(datetime(2013, 5, 8))
+            target.is_between(start, end)
+
+        with pytest.raises(TypeError):
+            target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+            start = arrow.Arrow.fromdatetime(datetime(2013, 5, 5))
+            end = datetime(2013, 5, 8)
+            target.is_between(start, end)
+
+        with pytest.raises(TypeError):
+            target.is_between(None, None)
+
+    def test_value_error_exception(self):
+        target = arrow.Arrow.fromdatetime(datetime(2013, 5, 7))
+        start = arrow.Arrow.fromdatetime(datetime(2013, 5, 5))
+        end = arrow.Arrow.fromdatetime(datetime(2013, 5, 8))
+        with pytest.raises(ValueError):
+            target.is_between(start, end, "][")
+        with pytest.raises(ValueError):
+            target.is_between(start, end, "")
+        with pytest.raises(ValueError):
+            target.is_between(start, end, "]")
+        with pytest.raises(ValueError):
+            target.is_between(start, end, "[")
+        with pytest.raises(ValueError):
+            target.is_between(start, end, "hello")
+        with pytest.raises(ValueError):
+            target.span("week", week_start=55)
+
+
+class TestArrowUtil:
+    def test_get_datetime(self):
+
+        get_datetime = arrow.Arrow._get_datetime
+
+        arw = arrow.Arrow.utcnow()
+        dt = datetime.utcnow()
+        timestamp = time.time()
+
+        assert get_datetime(arw) == arw.datetime
+        assert get_datetime(dt) == dt
+        assert (
+            get_datetime(timestamp) == arrow.Arrow.utcfromtimestamp(timestamp).datetime
+        )
+
+        with pytest.raises(ValueError) as raise_ctx:
+            get_datetime("abc")
+        assert "not recognized as a datetime or timestamp" in str(raise_ctx.value)
+
+    def test_get_tzinfo(self):
+
+        get_tzinfo = arrow.Arrow._get_tzinfo
+
+        with pytest.raises(ValueError) as raise_ctx:
+            get_tzinfo("abc")
+        assert "not recognized as a timezone" in str(raise_ctx.value)
+
+    def test_get_iteration_params(self):
+
+        assert arrow.Arrow._get_iteration_params("end", None) == ("end", sys.maxsize)
+        assert arrow.Arrow._get_iteration_params(None, 100) == (arrow.Arrow.max, 100)
+        assert arrow.Arrow._get_iteration_params(100, 120) == (100, 120)
+
+        with pytest.raises(ValueError):
+            arrow.Arrow._get_iteration_params(None, None)
diff --git b/tests/test_factory.py a/tests/test_factory.py
new file mode 100644
index 0000000..53bba20
--- /dev/null
+++ a/tests/test_factory.py
@@ -0,0 +1,436 @@
+import time
+from datetime import date, datetime
+from decimal import Decimal
+
+import pytest
+from dateutil import tz
+
+from arrow import Arrow
+from arrow.parser import ParserError
+
+from .utils import assert_datetime_equality
+
+
+@pytest.mark.usefixtures("arrow_factory")
+class TestGet:
+    def test_no_args(self):
+
+        assert_datetime_equality(
+            self.factory.get(), datetime.utcnow().replace(tzinfo=tz.tzutc())
+        )
+
+    def test_timestamp_one_arg_no_arg(self):
+
+        no_arg = self.factory.get(1406430900).timestamp()
+        one_arg = self.factory.get("1406430900", "X").timestamp()
+
+        assert no_arg == one_arg
+
+    def test_one_arg_none(self):
+        with pytest.raises(TypeError):
+            self.factory.get(None)
+
+    def test_struct_time(self):
+
+        assert_datetime_equality(
+            self.factory.get(time.gmtime()),
+            datetime.utcnow().replace(tzinfo=tz.tzutc()),
+        )
+
+    def test_one_arg_timestamp(self):
+
+        int_timestamp = int(time.time())
+        timestamp_dt = datetime.utcfromtimestamp(int_timestamp).replace(
+            tzinfo=tz.tzutc()
+        )
+
+        assert self.factory.get(int_timestamp) == timestamp_dt
+
+        with pytest.raises(ParserError):
+            self.factory.get(str(int_timestamp))
+
+        float_timestamp = time.time()
+        timestamp_dt = datetime.utcfromtimestamp(float_timestamp).replace(
+            tzinfo=tz.tzutc()
+        )
+
+        assert self.factory.get(float_timestamp) == timestamp_dt
+
+        with pytest.raises(ParserError):
+            self.factory.get(str(float_timestamp))
+
+        # Regression test for issue #216
+        # Python 3 raises OverflowError, Python 2 raises ValueError
+        timestamp = 99999999999999999999999999.99999999999999999999999999
+        with pytest.raises((OverflowError, ValueError)):
+            self.factory.get(timestamp)
+
+    def test_one_arg_expanded_timestamp(self):
+
+        millisecond_timestamp = 1591328104308
+        microsecond_timestamp = 1591328104308505
+
+        # Regression test for issue #796
+        assert self.factory.get(millisecond_timestamp) == datetime.utcfromtimestamp(
+            1591328104.308
+        ).replace(tzinfo=tz.tzutc())
+        assert self.factory.get(microsecond_timestamp) == datetime.utcfromtimestamp(
+            1591328104.308505
+        ).replace(tzinfo=tz.tzutc())
+
+    def test_one_arg_timestamp_with_tzinfo(self):
+
+        timestamp = time.time()
+        timestamp_dt = datetime.fromtimestamp(timestamp, tz=tz.tzutc()).astimezone(
+            tz.gettz("US/Pacific")
+        )
+        timezone = tz.gettz("US/Pacific")
+
+        assert_datetime_equality(
+            self.factory.get(timestamp, tzinfo=timezone), timestamp_dt
+        )
+
+    def test_one_arg_arrow(self):
+
+        arw = self.factory.utcnow()
+        result = self.factory.get(arw)
+
+        assert arw == result
+
+    def test_one_arg_datetime(self):
+
+        dt = datetime.utcnow().replace(tzinfo=tz.tzutc())
+
+        assert self.factory.get(dt) == dt
+
+    def test_one_arg_date(self):
+
+        d = date.today()
+        dt = datetime(d.year, d.month, d.day, tzinfo=tz.tzutc())
+
+        assert self.factory.get(d) == dt
+
+    def test_one_arg_tzinfo(self):
+
+        self.expected = (
+            datetime.utcnow()
+            .replace(tzinfo=tz.tzutc())
+            .astimezone(tz.gettz("US/Pacific"))
+        )
+
+        assert_datetime_equality(
+            self.factory.get(tz.gettz("US/Pacific")), self.expected
+        )
+
+    # regression test for issue #658
+    def test_one_arg_dateparser_datetime(self):
+        dateparser = pytest.importorskip("dateparser")
+        expected = datetime(1990, 1, 1).replace(tzinfo=tz.tzutc())
+        # dateparser outputs: datetime.datetime(1990, 1, 1, 0, 0, tzinfo=<StaticTzInfo 'UTC\+00:00'>)
+        parsed_date = dateparser.parse("1990-01-01T00:00:00+00:00")
+        dt_output = self.factory.get(parsed_date)._datetime.replace(tzinfo=tz.tzutc())
+        assert dt_output == expected
+
+    def test_kwarg_tzinfo(self):
+
+        self.expected = (
+            datetime.utcnow()
+            .replace(tzinfo=tz.tzutc())
+            .astimezone(tz.gettz("US/Pacific"))
+        )
+
+        assert_datetime_equality(
+            self.factory.get(tzinfo=tz.gettz("US/Pacific")), self.expected
+        )
+
+    def test_kwarg_tzinfo_string(self):
+
+        self.expected = (
+            datetime.utcnow()
+            .replace(tzinfo=tz.tzutc())
+            .astimezone(tz.gettz("US/Pacific"))
+        )
+
+        assert_datetime_equality(self.factory.get(tzinfo="US/Pacific"), self.expected)
+
+        with pytest.raises(ParserError):
+            self.factory.get(tzinfo="US/PacificInvalidTzinfo")
+
+    def test_kwarg_normalize_whitespace(self):
+        result = self.factory.get(
+            "Jun 1 2005  1:33PM",
+            "MMM D YYYY H:mmA",
+            tzinfo=tz.tzutc(),
+            normalize_whitespace=True,
+        )
+        assert result._datetime == datetime(2005, 6, 1, 13, 33, tzinfo=tz.tzutc())
+
+        result = self.factory.get(
+            "\t 2013-05-05T12:30:45.123456 \t \n",
+            tzinfo=tz.tzutc(),
+            normalize_whitespace=True,
+        )
+        assert result._datetime == datetime(
+            2013, 5, 5, 12, 30, 45, 123456, tzinfo=tz.tzutc()
+        )
+
+    # regression test for #944
+    def test_one_arg_datetime_tzinfo_kwarg(self):
+
+        dt = datetime(2021, 4, 29, 6)
+
+        result = self.factory.get(dt, tzinfo="America/Chicago")
+
+        expected = datetime(2021, 4, 29, 6, tzinfo=tz.gettz("America/Chicago"))
+
+        assert_datetime_equality(result._datetime, expected)
+
+    def test_one_arg_arrow_tzinfo_kwarg(self):
+
+        arw = Arrow(2021, 4, 29, 6)
+
+        result = self.factory.get(arw, tzinfo="America/Chicago")
+
+        expected = datetime(2021, 4, 29, 6, tzinfo=tz.gettz("America/Chicago"))
+
+        assert_datetime_equality(result._datetime, expected)
+
+    def test_one_arg_date_tzinfo_kwarg(self):
+
+        da = date(2021, 4, 29)
+
+        result = self.factory.get(da, tzinfo="America/Chicago")
+
+        expected = Arrow(2021, 4, 29, tzinfo=tz.gettz("America/Chicago"))
+
+        assert result.date() == expected.date()
+        assert result.tzinfo == expected.tzinfo
+
+    def test_one_arg_iso_calendar_tzinfo_kwarg(self):
+
+        result = self.factory.get((2004, 1, 7), tzinfo="America/Chicago")
+
+        expected = Arrow(2004, 1, 4, tzinfo="America/Chicago")
+
+        assert_datetime_equality(result, expected)
+
+    def test_one_arg_iso_str(self):
+
+        dt = datetime.utcnow()
+
+        assert_datetime_equality(
+            self.factory.get(dt.isoformat()), dt.replace(tzinfo=tz.tzutc())
+        )
+
+    def test_one_arg_iso_calendar(self):
+
+        pairs = [
+            (datetime(2004, 1, 4), (2004, 1, 7)),
+            (datetime(2008, 12, 30), (2009, 1, 2)),
+            (datetime(2010, 1, 2), (2009, 53, 6)),
+            (datetime(2000, 2, 29), (2000, 9, 2)),
+            (datetime(2005, 1, 1), (2004, 53, 6)),
+            (datetime(2010, 1, 4), (2010, 1, 1)),
+            (datetime(2010, 1, 3), (2009, 53, 7)),
+            (datetime(2003, 12, 29), (2004, 1, 1)),
+        ]
+
+        for pair in pairs:
+            dt, iso = pair
+            assert self.factory.get(iso) == self.factory.get(dt)
+
+        with pytest.raises(TypeError):
+            self.factory.get((2014, 7, 1, 4))
+
+        with pytest.raises(TypeError):
+            self.factory.get((2014, 7))
+
+        with pytest.raises(ValueError):
+            self.factory.get((2014, 70, 1))
+
+        with pytest.raises(ValueError):
+            self.factory.get((2014, 7, 10))
+
+    def test_one_arg_other(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(object())
+
+    def test_one_arg_bool(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(False)
+
+        with pytest.raises(TypeError):
+            self.factory.get(True)
+
+    def test_one_arg_decimal(self):
+        result = self.factory.get(Decimal(1577836800.26843))
+
+        assert result._datetime == datetime(
+            2020, 1, 1, 0, 0, 0, 268430, tzinfo=tz.tzutc()
+        )
+
+    def test_two_args_datetime_tzinfo(self):
+
+        result = self.factory.get(datetime(2013, 1, 1), tz.gettz("US/Pacific"))
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.gettz("US/Pacific"))
+
+    def test_two_args_datetime_tz_str(self):
+
+        result = self.factory.get(datetime(2013, 1, 1), "US/Pacific")
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.gettz("US/Pacific"))
+
+    def test_two_args_date_tzinfo(self):
+
+        result = self.factory.get(date(2013, 1, 1), tz.gettz("US/Pacific"))
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.gettz("US/Pacific"))
+
+    def test_two_args_date_tz_str(self):
+
+        result = self.factory.get(date(2013, 1, 1), "US/Pacific")
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.gettz("US/Pacific"))
+
+    def test_two_args_datetime_other(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(datetime.utcnow(), object())
+
+    def test_two_args_date_other(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(date.today(), object())
+
+    def test_two_args_str_str(self):
+
+        result = self.factory.get("2013-01-01", "YYYY-MM-DD")
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+
+    def test_two_args_str_tzinfo(self):
+
+        result = self.factory.get("2013-01-01", tzinfo=tz.gettz("US/Pacific"))
+
+        assert_datetime_equality(
+            result._datetime, datetime(2013, 1, 1, tzinfo=tz.gettz("US/Pacific"))
+        )
+
+    def test_two_args_twitter_format(self):
+
+        # format returned by twitter API for created_at:
+        twitter_date = "Fri Apr 08 21:08:54 +0000 2016"
+        result = self.factory.get(twitter_date, "ddd MMM DD HH:mm:ss Z YYYY")
+
+        assert result._datetime == datetime(2016, 4, 8, 21, 8, 54, tzinfo=tz.tzutc())
+
+    def test_two_args_str_list(self):
+
+        result = self.factory.get("2013-01-01", ["MM/DD/YYYY", "YYYY-MM-DD"])
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+
+    def test_two_args_unicode_unicode(self):
+
+        result = self.factory.get("2013-01-01", "YYYY-MM-DD")
+
+        assert result._datetime == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+
+    def test_two_args_other(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(object(), object())
+
+    def test_three_args_with_tzinfo(self):
+
+        timefmt = "YYYYMMDD"
+        d = "20150514"
+
+        assert self.factory.get(d, timefmt, tzinfo=tz.tzlocal()) == datetime(
+            2015, 5, 14, tzinfo=tz.tzlocal()
+        )
+
+    def test_three_args(self):
+
+        assert self.factory.get(2013, 1, 1) == datetime(2013, 1, 1, tzinfo=tz.tzutc())
+
+    def test_full_kwargs(self):
+
+        assert (
+            self.factory.get(
+                year=2016,
+                month=7,
+                day=14,
+                hour=7,
+                minute=16,
+                second=45,
+                microsecond=631092,
+            )
+            == datetime(2016, 7, 14, 7, 16, 45, 631092, tzinfo=tz.tzutc())
+        )
+
+    def test_three_kwargs(self):
+
+        assert self.factory.get(year=2016, month=7, day=14) == datetime(
+            2016, 7, 14, 0, 0, tzinfo=tz.tzutc()
+        )
+
+    def test_tzinfo_string_kwargs(self):
+        result = self.factory.get("2019072807", "YYYYMMDDHH", tzinfo="UTC")
+        assert result._datetime == datetime(2019, 7, 28, 7, 0, 0, 0, tzinfo=tz.tzutc())
+
+    def test_insufficient_kwargs(self):
+
+        with pytest.raises(TypeError):
+            self.factory.get(year=2016)
+
+        with pytest.raises(TypeError):
+            self.factory.get(year=2016, month=7)
+
+    def test_locale(self):
+        result = self.factory.get("2010", "YYYY", locale="ja")
+        assert result._datetime == datetime(2010, 1, 1, 0, 0, 0, 0, tzinfo=tz.tzutc())
+
+        # regression test for issue #701
+        result = self.factory.get(
+            "Montag, 9. September 2019, 16:15-20:00", "dddd, D. MMMM YYYY", locale="de"
+        )
+        assert result._datetime == datetime(2019, 9, 9, 0, 0, 0, 0, tzinfo=tz.tzutc())
+
+    def test_locale_kwarg_only(self):
+        res = self.factory.get(locale="ja")
+        assert res.tzinfo == tz.tzutc()
+
+    def test_locale_with_tzinfo(self):
+        res = self.factory.get(locale="ja", tzinfo=tz.gettz("Asia/Tokyo"))
+        assert res.tzinfo == tz.gettz("Asia/Tokyo")
+
+
+@pytest.mark.usefixtures("arrow_factory")
+class TestUtcNow:
+    def test_utcnow(self):
+
+        assert_datetime_equality(
+            self.factory.utcnow()._datetime,
+            datetime.utcnow().replace(tzinfo=tz.tzutc()),
+        )
+
+
+@pytest.mark.usefixtures("arrow_factory")
+class TestNow:
+    def test_no_tz(self):
+
+        assert_datetime_equality(self.factory.now(), datetime.now(tz.tzlocal()))
+
+    def test_tzinfo(self):
+
+        assert_datetime_equality(
+            self.factory.now(tz.gettz("EST")), datetime.now(tz.gettz("EST"))
+        )
+
+    def test_tz_str(self):
+
+        assert_datetime_equality(self.factory.now("EST"), datetime.now(tz.gettz("EST")))
diff --git b/tests/test_formatter.py a/tests/test_formatter.py
new file mode 100644
index 0000000..06831f1
--- /dev/null
+++ a/tests/test_formatter.py
@@ -0,0 +1,280 @@
+from datetime import datetime
+
+import pytest
+import pytz
+from dateutil import tz as dateutil_tz
+
+from arrow import (
+    FORMAT_ATOM,
+    FORMAT_COOKIE,
+    FORMAT_RFC822,
+    FORMAT_RFC850,
+    FORMAT_RFC1036,
+    FORMAT_RFC1123,
+    FORMAT_RFC2822,
+    FORMAT_RFC3339,
+    FORMAT_RSS,
+    FORMAT_W3C,
+)
+
+from .utils import make_full_tz_list
+
+
+@pytest.mark.usefixtures("arrow_formatter")
+class TestFormatterFormatToken:
+    def test_format(self):
+
+        dt = datetime(2013, 2, 5, 12, 32, 51)
+
+        result = self.formatter.format(dt, "MM-DD-YYYY hh:mm:ss a")
+
+        assert result == "02-05-2013 12:32:51 pm"
+
+    def test_year(self):
+
+        dt = datetime(2013, 1, 1)
+        assert self.formatter._format_token(dt, "YYYY") == "2013"
+        assert self.formatter._format_token(dt, "YY") == "13"
+
+    def test_month(self):
+
+        dt = datetime(2013, 1, 1)
+        assert self.formatter._format_token(dt, "MMMM") == "January"
+        assert self.formatter._format_token(dt, "MMM") == "Jan"
+        assert self.formatter._format_token(dt, "MM") == "01"
+        assert self.formatter._format_token(dt, "M") == "1"
+
+    def test_day(self):
+
+        dt = datetime(2013, 2, 1)
+        assert self.formatter._format_token(dt, "DDDD") == "032"
+        assert self.formatter._format_token(dt, "DDD") == "32"
+        assert self.formatter._format_token(dt, "DD") == "01"
+        assert self.formatter._format_token(dt, "D") == "1"
+        assert self.formatter._format_token(dt, "Do") == "1st"
+
+        assert self.formatter._format_token(dt, "dddd") == "Friday"
+        assert self.formatter._format_token(dt, "ddd") == "Fri"
+        assert self.formatter._format_token(dt, "d") == "5"
+
+    def test_hour(self):
+
+        dt = datetime(2013, 1, 1, 2)
+        assert self.formatter._format_token(dt, "HH") == "02"
+        assert self.formatter._format_token(dt, "H") == "2"
+
+        dt = datetime(2013, 1, 1, 13)
+        assert self.formatter._format_token(dt, "HH") == "13"
+        assert self.formatter._format_token(dt, "H") == "13"
+
+        dt = datetime(2013, 1, 1, 2)
+        assert self.formatter._format_token(dt, "hh") == "02"
+        assert self.formatter._format_token(dt, "h") == "2"
+
+        dt = datetime(2013, 1, 1, 13)
+        assert self.formatter._format_token(dt, "hh") == "01"
+        assert self.formatter._format_token(dt, "h") == "1"
+
+        # test that 12-hour time converts to '12' at midnight
+        dt = datetime(2013, 1, 1, 0)
+        assert self.formatter._format_token(dt, "hh") == "12"
+        assert self.formatter._format_token(dt, "h") == "12"
+
+    def test_minute(self):
+
+        dt = datetime(2013, 1, 1, 0, 1)
+        assert self.formatter._format_token(dt, "mm") == "01"
+        assert self.formatter._format_token(dt, "m") == "1"
+
+    def test_second(self):
+
+        dt = datetime(2013, 1, 1, 0, 0, 1)
+        assert self.formatter._format_token(dt, "ss") == "01"
+        assert self.formatter._format_token(dt, "s") == "1"
+
+    def test_sub_second(self):
+
+        dt = datetime(2013, 1, 1, 0, 0, 0, 123456)
+        assert self.formatter._format_token(dt, "SSSSSS") == "123456"
+        assert self.formatter._format_token(dt, "SSSSS") == "12345"
+        assert self.formatter._format_token(dt, "SSSS") == "1234"
+        assert self.formatter._format_token(dt, "SSS") == "123"
+        assert self.formatter._format_token(dt, "SS") == "12"
+        assert self.formatter._format_token(dt, "S") == "1"
+
+        dt = datetime(2013, 1, 1, 0, 0, 0, 2000)
+        assert self.formatter._format_token(dt, "SSSSSS") == "002000"
+        assert self.formatter._format_token(dt, "SSSSS") == "00200"
+        assert self.formatter._format_token(dt, "SSSS") == "0020"
+        assert self.formatter._format_token(dt, "SSS") == "002"
+        assert self.formatter._format_token(dt, "SS") == "00"
+        assert self.formatter._format_token(dt, "S") == "0"
+
+    def test_timestamp(self):
+
+        dt = datetime.now(tz=dateutil_tz.UTC)
+        expected = str(dt.timestamp())
+        assert self.formatter._format_token(dt, "X") == expected
+
+        # Must round because time.time() may return a float with greater
+        # than 6 digits of precision
+        expected = str(int(dt.timestamp() * 1000000))
+        assert self.formatter._format_token(dt, "x") == expected
+
+    def test_timezone(self):
+
+        dt = datetime.utcnow().replace(tzinfo=dateutil_tz.gettz("US/Pacific"))
+
+        result = self.formatter._format_token(dt, "ZZ")
+        assert result == "-07:00" or result == "-08:00"
+
+        result = self.formatter._format_token(dt, "Z")
+        assert result == "-0700" or result == "-0800"
+
+    @pytest.mark.parametrize("full_tz_name", make_full_tz_list())
+    def test_timezone_formatter(self, full_tz_name):
+
+        # This test will fail if we use "now" as date as soon as we change from/to DST
+        dt = datetime(1986, 2, 14, tzinfo=pytz.timezone("UTC")).replace(
+            tzinfo=dateutil_tz.gettz(full_tz_name)
+        )
+        abbreviation = dt.tzname()
+
+        result = self.formatter._format_token(dt, "ZZZ")
+        assert result == abbreviation
+
+    def test_am_pm(self):
+
+        dt = datetime(2012, 1, 1, 11)
+        assert self.formatter._format_token(dt, "a") == "am"
+        assert self.formatter._format_token(dt, "A") == "AM"
+
+        dt = datetime(2012, 1, 1, 13)
+        assert self.formatter._format_token(dt, "a") == "pm"
+        assert self.formatter._format_token(dt, "A") == "PM"
+
+    def test_week(self):
+        dt = datetime(2017, 5, 19)
+        assert self.formatter._format_token(dt, "W") == "2017-W20-5"
+
+        # make sure week is zero padded when needed
+        dt_early = datetime(2011, 1, 20)
+        assert self.formatter._format_token(dt_early, "W") == "2011-W03-4"
+
+    def test_nonsense(self):
+        dt = datetime(2012, 1, 1, 11)
+        assert self.formatter._format_token(dt, None) is None
+        assert self.formatter._format_token(dt, "NONSENSE") is None
+
+    def test_escape(self):
+
+        assert (
+            self.formatter.format(
+                datetime(2015, 12, 10, 17, 9), "MMMM D, YYYY [at] h:mma"
+            )
+            == "December 10, 2015 at 5:09pm"
+        )
+
+        assert (
+            self.formatter.format(
+                datetime(2015, 12, 10, 17, 9), "[MMMM] M D, YYYY [at] h:mma"
+            )
+            == "MMMM 12 10, 2015 at 5:09pm"
+        )
+
+        assert (
+            self.formatter.format(
+                datetime(1990, 11, 25),
+                "[It happened on] MMMM Do [in the year] YYYY [a long time ago]",
+            )
+            == "It happened on November 25th in the year 1990 a long time ago"
+        )
+
+        assert (
+            self.formatter.format(
+                datetime(1990, 11, 25),
+                "[It happened on] MMMM Do [in the][ year] YYYY [a long time ago]",
+            )
+            == "It happened on November 25th in the year 1990 a long time ago"
+        )
+
+        assert (
+            self.formatter.format(
+                datetime(1, 1, 1), "[I'm][ entirely][ escaped,][ weee!]"
+            )
+            == "I'm entirely escaped, weee!"
+        )
+
+        # Special RegEx characters
+        assert (
+            self.formatter.format(
+                datetime(2017, 12, 31, 2, 0), "MMM DD, YYYY |^${}().*+?<>-& h:mm A"
+            )
+            == "Dec 31, 2017 |^${}().*+?<>-& 2:00 AM"
+        )
+
+        # Escaping is atomic: brackets inside brackets are treated literally
+        assert self.formatter.format(datetime(1, 1, 1), "[[[ ]]") == "[[ ]"
+
+
+@pytest.mark.usefixtures("arrow_formatter", "time_1975_12_25")
+class TestFormatterBuiltinFormats:
+    def test_atom(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_ATOM)
+            == "1975-12-25 14:15:16-05:00"
+        )
+
+    def test_cookie(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_COOKIE)
+            == "Thursday, 25-Dec-1975 14:15:16 EST"
+        )
+
+    def test_rfc_822(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC822)
+            == "Thu, 25 Dec 75 14:15:16 -0500"
+        )
+
+    def test_rfc_850(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC850)
+            == "Thursday, 25-Dec-75 14:15:16 EST"
+        )
+
+    def test_rfc_1036(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC1036)
+            == "Thu, 25 Dec 75 14:15:16 -0500"
+        )
+
+    def test_rfc_1123(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC1123)
+            == "Thu, 25 Dec 1975 14:15:16 -0500"
+        )
+
+    def test_rfc_2822(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC2822)
+            == "Thu, 25 Dec 1975 14:15:16 -0500"
+        )
+
+    def test_rfc3339(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RFC3339)
+            == "1975-12-25 14:15:16-05:00"
+        )
+
+    def test_rss(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_RSS)
+            == "Thu, 25 Dec 1975 14:15:16 -0500"
+        )
+
+    def test_w3c(self):
+        assert (
+            self.formatter.format(self.datetime, FORMAT_W3C)
+            == "1975-12-25 14:15:16-05:00"
+        )
diff --git b/tests/test_parser.py a/tests/test_parser.py
new file mode 100644
index 0000000..4a4cfe4
--- /dev/null
+++ a/tests/test_parser.py
@@ -0,0 +1,1671 @@
+import calendar
+import os
+import time
+from datetime import datetime
+
+import pytest
+from dateutil import tz
+
+import arrow
+from arrow import formatter, parser
+from arrow.constants import MAX_TIMESTAMP_US
+from arrow.parser import DateTimeParser, ParserError, ParserMatchError
+
+from .utils import make_full_tz_list
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParser:
+    def test_parse_multiformat(self, mocker):
+        mocker.patch(
+            "arrow.parser.DateTimeParser.parse",
+            string="str",
+            fmt="fmt_a",
+            side_effect=parser.ParserError,
+        )
+
+        with pytest.raises(parser.ParserError):
+            self.parser._parse_multiformat("str", ["fmt_a"])
+
+        mock_datetime = mocker.Mock()
+        mocker.patch(
+            "arrow.parser.DateTimeParser.parse",
+            string="str",
+            fmt="fmt_b",
+            return_value=mock_datetime,
+        )
+
+        result = self.parser._parse_multiformat("str", ["fmt_a", "fmt_b"])
+        assert result == mock_datetime
+
+    def test_parse_multiformat_all_fail(self, mocker):
+        mocker.patch(
+            "arrow.parser.DateTimeParser.parse",
+            string="str",
+            fmt="fmt_a",
+            side_effect=parser.ParserError,
+        )
+
+        mocker.patch(
+            "arrow.parser.DateTimeParser.parse",
+            string="str",
+            fmt="fmt_b",
+            side_effect=parser.ParserError,
+        )
+
+        with pytest.raises(parser.ParserError):
+            self.parser._parse_multiformat("str", ["fmt_a", "fmt_b"])
+
+    def test_parse_multiformat_unself_expected_fail(self, mocker):
+        class UnselfExpectedError(Exception):
+            pass
+
+        mocker.patch(
+            "arrow.parser.DateTimeParser.parse",
+            string="str",
+            fmt="fmt_a",
+            side_effect=UnselfExpectedError,
+        )
+
+        with pytest.raises(UnselfExpectedError):
+            self.parser._parse_multiformat("str", ["fmt_a", "fmt_b"])
+
+    def test_parse_token_nonsense(self):
+        parts = {}
+        self.parser._parse_token("NONSENSE", "1900", parts)
+        assert parts == {}
+
+    def test_parse_token_invalid_meridians(self):
+        parts = {}
+        self.parser._parse_token("A", "a..m", parts)
+        assert parts == {}
+        self.parser._parse_token("a", "p..m", parts)
+        assert parts == {}
+
+    def test_parser_no_caching(self, mocker):
+
+        mocked_parser = mocker.patch(
+            "arrow.parser.DateTimeParser._generate_pattern_re", fmt="fmt_a"
+        )
+        self.parser = parser.DateTimeParser(cache_size=0)
+        for _ in range(100):
+            self.parser._generate_pattern_re("fmt_a")
+        assert mocked_parser.call_count == 100
+
+    def test_parser_1_line_caching(self, mocker):
+        mocked_parser = mocker.patch("arrow.parser.DateTimeParser._generate_pattern_re")
+        self.parser = parser.DateTimeParser(cache_size=1)
+
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_a")
+        assert mocked_parser.call_count == 1
+        assert mocked_parser.call_args_list[0] == mocker.call(fmt="fmt_a")
+
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_b")
+        assert mocked_parser.call_count == 2
+        assert mocked_parser.call_args_list[1] == mocker.call(fmt="fmt_b")
+
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_a")
+        assert mocked_parser.call_count == 3
+        assert mocked_parser.call_args_list[2] == mocker.call(fmt="fmt_a")
+
+    def test_parser_multiple_line_caching(self, mocker):
+        mocked_parser = mocker.patch("arrow.parser.DateTimeParser._generate_pattern_re")
+        self.parser = parser.DateTimeParser(cache_size=2)
+
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_a")
+        assert mocked_parser.call_count == 1
+        assert mocked_parser.call_args_list[0] == mocker.call(fmt="fmt_a")
+
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_b")
+        assert mocked_parser.call_count == 2
+        assert mocked_parser.call_args_list[1] == mocker.call(fmt="fmt_b")
+
+        # fmt_a and fmt_b are in the cache, so no new calls should be made
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_a")
+        for _ in range(100):
+            self.parser._generate_pattern_re(fmt="fmt_b")
+        assert mocked_parser.call_count == 2
+        assert mocked_parser.call_args_list[0] == mocker.call(fmt="fmt_a")
+        assert mocked_parser.call_args_list[1] == mocker.call(fmt="fmt_b")
+
+    def test_YY_and_YYYY_format_list(self):
+
+        assert self.parser.parse("15/01/19", ["DD/MM/YY", "DD/MM/YYYY"]) == datetime(
+            2019, 1, 15
+        )
+
+        # Regression test for issue #580
+        assert self.parser.parse("15/01/2019", ["DD/MM/YY", "DD/MM/YYYY"]) == datetime(
+            2019, 1, 15
+        )
+
+        assert (
+            self.parser.parse(
+                "15/01/2019T04:05:06.789120Z",
+                ["D/M/YYThh:mm:ss.SZ", "D/M/YYYYThh:mm:ss.SZ"],
+            )
+            == datetime(2019, 1, 15, 4, 5, 6, 789120, tzinfo=tz.tzutc())
+        )
+
+    # regression test for issue #447
+    def test_timestamp_format_list(self):
+        # should not match on the "X" token
+        assert (
+            self.parser.parse(
+                "15 Jul 2000",
+                ["MM/DD/YYYY", "YYYY-MM-DD", "X", "DD-MMMM-YYYY", "D MMM YYYY"],
+            )
+            == datetime(2000, 7, 15)
+        )
+
+        with pytest.raises(ParserError):
+            self.parser.parse("15 Jul", "X")
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserParse:
+    def test_parse_list(self, mocker):
+
+        mocker.patch(
+            "arrow.parser.DateTimeParser._parse_multiformat",
+            string="str",
+            formats=["fmt_a", "fmt_b"],
+            return_value="result",
+        )
+
+        result = self.parser.parse("str", ["fmt_a", "fmt_b"])
+        assert result == "result"
+
+    def test_parse_unrecognized_token(self, mocker):
+
+        mocker.patch.dict("arrow.parser.DateTimeParser._BASE_INPUT_RE_MAP")
+        del arrow.parser.DateTimeParser._BASE_INPUT_RE_MAP["YYYY"]
+
+        # need to make another local parser to apply patch changes
+        _parser = parser.DateTimeParser()
+        with pytest.raises(parser.ParserError):
+            _parser.parse("2013-01-01", "YYYY-MM-DD")
+
+    def test_parse_parse_no_match(self):
+
+        with pytest.raises(ParserError):
+            self.parser.parse("01-01", "YYYY-MM-DD")
+
+    def test_parse_separators(self):
+
+        with pytest.raises(ParserError):
+            self.parser.parse("1403549231", "YYYY-MM-DD")
+
+    def test_parse_numbers(self):
+
+        self.expected = datetime(2012, 1, 1, 12, 5, 10)
+        assert (
+            self.parser.parse("2012-01-01 12:05:10", "YYYY-MM-DD HH:mm:ss")
+            == self.expected
+        )
+
+    def test_parse_am(self):
+
+        with pytest.raises(ParserMatchError):
+            self.parser.parse("2021-01-30 14:00:00 AM", "YYYY-MM-DD HH:mm:ss A")
+
+    def test_parse_year_two_digit(self):
+
+        self.expected = datetime(1979, 1, 1, 12, 5, 10)
+        assert (
+            self.parser.parse("79-01-01 12:05:10", "YY-MM-DD HH:mm:ss") == self.expected
+        )
+
+    def test_parse_timestamp(self):
+
+        tz_utc = tz.tzutc()
+        float_timestamp = time.time()
+        int_timestamp = int(float_timestamp)
+        self.expected = datetime.fromtimestamp(int_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{int_timestamp:d}", "X") == self.expected
+
+        self.expected = datetime.fromtimestamp(float_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{float_timestamp:f}", "X") == self.expected
+
+        # test handling of ns timestamp (arrow will round to 6 digits regardless)
+        self.expected = datetime.fromtimestamp(float_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{float_timestamp:f}123", "X") == self.expected
+
+        # test ps timestamp (arrow will round to 6 digits regardless)
+        self.expected = datetime.fromtimestamp(float_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{float_timestamp:f}123456", "X") == self.expected
+
+        # NOTE: timestamps cannot be parsed from natural language strings (by removing the ^...$) because it will
+        # break cases like "15 Jul 2000" and a format list (see issue #447)
+        with pytest.raises(ParserError):
+            natural_lang_string = "Meet me at {} at the restaurant.".format(
+                float_timestamp
+            )
+            self.parser.parse(natural_lang_string, "X")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("1565982019.", "X")
+
+        with pytest.raises(ParserError):
+            self.parser.parse(".1565982019", "X")
+
+    # NOTE: negative timestamps cannot be handled by datetime on Windows
+    # Must use timedelta to handle them: https://stackoverflow.com/questions/36179914
+    @pytest.mark.skipif(
+        os.name == "nt", reason="negative timestamps are not supported on Windows"
+    )
+    def test_parse_negative_timestamp(self):
+        # regression test for issue #662
+        tz_utc = tz.tzutc()
+        float_timestamp = time.time()
+        int_timestamp = int(float_timestamp)
+        negative_int_timestamp = -int_timestamp
+        self.expected = datetime.fromtimestamp(negative_int_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{negative_int_timestamp:d}", "X") == self.expected
+
+        negative_float_timestamp = -float_timestamp
+        self.expected = datetime.fromtimestamp(negative_float_timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{negative_float_timestamp:f}", "X") == self.expected
+
+    def test_parse_expanded_timestamp(self):
+        # test expanded timestamps that include milliseconds
+        # and microseconds as multiples rather than decimals
+        # requested in issue #357
+
+        tz_utc = tz.tzutc()
+        timestamp = 1569982581.413132
+        timestamp_milli = round(timestamp * 1000)
+        timestamp_micro = round(timestamp * 1_000_000)
+
+        # "x" token should parse integer timestamps below MAX_TIMESTAMP normally
+        self.expected = datetime.fromtimestamp(int(timestamp), tz=tz_utc)
+        assert self.parser.parse(f"{int(timestamp):d}", "x") == self.expected
+
+        self.expected = datetime.fromtimestamp(round(timestamp, 3), tz=tz_utc)
+        assert self.parser.parse(f"{timestamp_milli:d}", "x") == self.expected
+
+        self.expected = datetime.fromtimestamp(timestamp, tz=tz_utc)
+        assert self.parser.parse(f"{timestamp_micro:d}", "x") == self.expected
+
+        # anything above max -s timestamp should fail
+        with pytest.raises(ValueError):
+            self.parser.parse(f"{int(MAX_TIMESTAMP_US) + 1:d}", "x")
+
+        # floats are not allowed with the "x" token
+        with pytest.raises(ParserMatchError):
+            self.parser.parse(f"{timestamp:f}", "x")
+
+    def test_parse_names(self):
+
+        self.expected = datetime(2012, 1, 1)
+
+        assert self.parser.parse("January 1, 2012", "MMMM D, YYYY") == self.expected
+        assert self.parser.parse("Jan 1, 2012", "MMM D, YYYY") == self.expected
+
+    def test_parse_pm(self):
+
+        self.expected = datetime(1, 1, 1, 13, 0, 0)
+        assert self.parser.parse("1 pm", "H a") == self.expected
+        assert self.parser.parse("1 pm", "h a") == self.expected
+
+        self.expected = datetime(1, 1, 1, 1, 0, 0)
+        assert self.parser.parse("1 am", "H A") == self.expected
+        assert self.parser.parse("1 am", "h A") == self.expected
+
+        self.expected = datetime(1, 1, 1, 0, 0, 0)
+        assert self.parser.parse("12 am", "H A") == self.expected
+        assert self.parser.parse("12 am", "h A") == self.expected
+
+        self.expected = datetime(1, 1, 1, 12, 0, 0)
+        assert self.parser.parse("12 pm", "H A") == self.expected
+        assert self.parser.parse("12 pm", "h A") == self.expected
+
+    def test_parse_tz_hours_only(self):
+
+        self.expected = datetime(2025, 10, 17, 5, 30, 10, tzinfo=tz.tzoffset(None, 0))
+        parsed = self.parser.parse("2025-10-17 05:30:10+00", "YYYY-MM-DD HH:mm:ssZ")
+        assert parsed == self.expected
+
+    def test_parse_tz_zz(self):
+
+        self.expected = datetime(2013, 1, 1, tzinfo=tz.tzoffset(None, -7 * 3600))
+        assert self.parser.parse("2013-01-01 -07:00", "YYYY-MM-DD ZZ") == self.expected
+
+    @pytest.mark.parametrize("full_tz_name", make_full_tz_list())
+    def test_parse_tz_name_zzz(self, full_tz_name):
+
+        self.expected = datetime(2013, 1, 1, tzinfo=tz.gettz(full_tz_name))
+        assert (
+            self.parser.parse(f"2013-01-01 {full_tz_name}", "YYYY-MM-DD ZZZ")
+            == self.expected
+        )
+
+        # note that offsets are not timezones
+        with pytest.raises(ParserError):
+            self.parser.parse("2013-01-01 12:30:45.9+1000", "YYYY-MM-DDZZZ")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2013-01-01 12:30:45.9+10:00", "YYYY-MM-DDZZZ")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2013-01-01 12:30:45.9-10", "YYYY-MM-DDZZZ")
+
+    def test_parse_subsecond(self):
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 900000)
+        assert (
+            self.parser.parse("2013-01-01 12:30:45.9", "YYYY-MM-DD HH:mm:ss.S")
+            == self.expected
+        )
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 980000)
+        assert (
+            self.parser.parse("2013-01-01 12:30:45.98", "YYYY-MM-DD HH:mm:ss.SS")
+            == self.expected
+        )
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987000)
+        assert (
+            self.parser.parse("2013-01-01 12:30:45.987", "YYYY-MM-DD HH:mm:ss.SSS")
+            == self.expected
+        )
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987600)
+        assert (
+            self.parser.parse("2013-01-01 12:30:45.9876", "YYYY-MM-DD HH:mm:ss.SSSS")
+            == self.expected
+        )
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987650)
+        assert (
+            self.parser.parse("2013-01-01 12:30:45.98765", "YYYY-MM-DD HH:mm:ss.SSSSS")
+            == self.expected
+        )
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987654)
+        assert (
+            self.parser.parse(
+                "2013-01-01 12:30:45.987654", "YYYY-MM-DD HH:mm:ss.SSSSSS"
+            )
+            == self.expected
+        )
+
+    def test_parse_subsecond_rounding(self):
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987654)
+        datetime_format = "YYYY-MM-DD HH:mm:ss.S"
+
+        # round up
+        string = "2013-01-01 12:30:45.9876539"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        # round down
+        string = "2013-01-01 12:30:45.98765432"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        # round half-up
+        string = "2013-01-01 12:30:45.987653521"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        # round half-down
+        string = "2013-01-01 12:30:45.9876545210"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+    # overflow (zero out the subseconds and increment the seconds)
+    # regression tests for issue #636
+    def test_parse_subsecond_rounding_overflow(self):
+        datetime_format = "YYYY-MM-DD HH:mm:ss.S"
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 46)
+        string = "2013-01-01 12:30:45.9999995"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 31, 0)
+        string = "2013-01-01 12:30:59.9999999"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        self.expected = datetime(2013, 1, 2, 0, 0, 0)
+        string = "2013-01-01 23:59:59.9999999"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+        # 6 digits should remain unrounded
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 999999)
+        string = "2013-01-01 12:30:45.999999"
+        assert self.parser.parse(string, datetime_format) == self.expected
+        assert self.parser.parse_iso(string) == self.expected
+
+    # Regression tests for issue #560
+    def test_parse_long_year(self):
+        with pytest.raises(ParserError):
+            self.parser.parse("09 January 123456789101112", "DD MMMM YYYY")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("123456789101112 09 January", "YYYY DD MMMM")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("68096653015/01/19", "YY/M/DD")
+
+    def test_parse_with_extra_words_at_start_and_end_invalid(self):
+        input_format_pairs = [
+            ("blah2016", "YYYY"),
+            ("blah2016blah", "YYYY"),
+            ("2016blah", "YYYY"),
+            ("2016-05blah", "YYYY-MM"),
+            ("2016-05-16blah", "YYYY-MM-DD"),
+            ("2016-05-16T04:05:06.789120blah", "YYYY-MM-DDThh:mm:ss.S"),
+            ("2016-05-16T04:05:06.789120ZblahZ", "YYYY-MM-DDThh:mm:ss.SZ"),
+            ("2016-05-16T04:05:06.789120Zblah", "YYYY-MM-DDThh:mm:ss.SZ"),
+            ("2016-05-16T04:05:06.789120blahZ", "YYYY-MM-DDThh:mm:ss.SZ"),
+        ]
+
+        for pair in input_format_pairs:
+            with pytest.raises(ParserError):
+                self.parser.parse(pair[0], pair[1])
+
+    def test_parse_with_extra_words_at_start_and_end_valid(self):
+        # Spaces surrounding the parsable date are ok because we
+        # allow the parsing of natural language input. Additionally, a single
+        # character of specific punctuation before or after the date is okay.
+        # See docs for full list of valid punctuation.
+
+        assert self.parser.parse("blah 2016 blah", "YYYY") == datetime(2016, 1, 1)
+
+        assert self.parser.parse("blah 2016", "YYYY") == datetime(2016, 1, 1)
+
+        assert self.parser.parse("2016 blah", "YYYY") == datetime(2016, 1, 1)
+
+        # test one additional space along with space divider
+        assert self.parser.parse(
+            "blah 2016-05-16 04:05:06.789120", "YYYY-MM-DD hh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+        assert self.parser.parse(
+            "2016-05-16 04:05:06.789120 blah", "YYYY-MM-DD hh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+        # test one additional space along with T divider
+        assert self.parser.parse(
+            "blah 2016-05-16T04:05:06.789120", "YYYY-MM-DDThh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+        assert self.parser.parse(
+            "2016-05-16T04:05:06.789120 blah", "YYYY-MM-DDThh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+        assert (
+            self.parser.parse(
+                "Meet me at 2016-05-16T04:05:06.789120 at the restaurant.",
+                "YYYY-MM-DDThh:mm:ss.S",
+            )
+            == datetime(2016, 5, 16, 4, 5, 6, 789120)
+        )
+
+        assert (
+            self.parser.parse(
+                "Meet me at 2016-05-16 04:05:06.789120 at the restaurant.",
+                "YYYY-MM-DD hh:mm:ss.S",
+            )
+            == datetime(2016, 5, 16, 4, 5, 6, 789120)
+        )
+
+    # regression test for issue #701
+    # tests cases of a partial match surrounded by punctuation
+    # for the list of valid punctuation, see documentation
+    def test_parse_with_punctuation_fences(self):
+        assert self.parser.parse(
+            "Meet me at my house on Halloween (2019-31-10)", "YYYY-DD-MM"
+        ) == datetime(2019, 10, 31)
+
+        assert self.parser.parse(
+            "Monday, 9. September 2019, 16:15-20:00", "dddd, D. MMMM YYYY"
+        ) == datetime(2019, 9, 9)
+
+        assert self.parser.parse("A date is 11.11.2011.", "DD.MM.YYYY") == datetime(
+            2011, 11, 11
+        )
+
+        with pytest.raises(ParserMatchError):
+            self.parser.parse("11.11.2011.1 is not a valid date.", "DD.MM.YYYY")
+
+        with pytest.raises(ParserMatchError):
+            self.parser.parse(
+                "This date has too many punctuation marks following it (11.11.2011).",
+                "DD.MM.YYYY",
+            )
+
+    def test_parse_with_leading_and_trailing_whitespace(self):
+        assert self.parser.parse("      2016", "YYYY") == datetime(2016, 1, 1)
+
+        assert self.parser.parse("2016      ", "YYYY") == datetime(2016, 1, 1)
+
+        assert self.parser.parse("      2016      ", "YYYY") == datetime(2016, 1, 1)
+
+        assert self.parser.parse(
+            "      2016-05-16 04:05:06.789120      ", "YYYY-MM-DD hh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+        assert self.parser.parse(
+            "      2016-05-16T04:05:06.789120      ", "YYYY-MM-DDThh:mm:ss.S"
+        ) == datetime(2016, 5, 16, 4, 5, 6, 789120)
+
+    def test_parse_YYYY_DDDD(self):
+        assert self.parser.parse("1998-136", "YYYY-DDDD") == datetime(1998, 5, 16)
+
+        assert self.parser.parse("1998-006", "YYYY-DDDD") == datetime(1998, 1, 6)
+
+        with pytest.raises(ParserError):
+            self.parser.parse("1998-456", "YYYY-DDDD")
+
+    def test_parse_YYYY_DDD(self):
+        assert self.parser.parse("1998-6", "YYYY-DDD") == datetime(1998, 1, 6)
+
+        assert self.parser.parse("1998-136", "YYYY-DDD") == datetime(1998, 5, 16)
+
+        with pytest.raises(ParserError):
+            self.parser.parse("1998-756", "YYYY-DDD")
+
+    # month cannot be passed with DDD and DDDD tokens
+    def test_parse_YYYY_MM_DDDD(self):
+        with pytest.raises(ParserError):
+            self.parser.parse("2015-01-009", "YYYY-MM-DDDD")
+
+    # year is required with the DDD and DDDD tokens
+    def test_parse_DDD_only(self):
+        with pytest.raises(ParserError):
+            self.parser.parse("5", "DDD")
+
+    def test_parse_DDDD_only(self):
+        with pytest.raises(ParserError):
+            self.parser.parse("145", "DDDD")
+
+    def test_parse_ddd_and_dddd(self):
+        fr_parser = parser.DateTimeParser("fr")
+
+        # Day of week should be ignored when a day is passed
+        # 2019-10-17 is a Thursday, so we know day of week
+        # is ignored if the same date is outputted
+        expected = datetime(2019, 10, 17)
+        assert self.parser.parse("Tue 2019-10-17", "ddd YYYY-MM-DD") == expected
+        assert fr_parser.parse("mar 2019-10-17", "ddd YYYY-MM-DD") == expected
+        assert self.parser.parse("Tuesday 2019-10-17", "dddd YYYY-MM-DD") == expected
+        assert fr_parser.parse("mardi 2019-10-17", "dddd YYYY-MM-DD") == expected
+
+        # Get first Tuesday after epoch
+        expected = datetime(1970, 1, 6)
+        assert self.parser.parse("Tue", "ddd") == expected
+        assert fr_parser.parse("mar", "ddd") == expected
+        assert self.parser.parse("Tuesday", "dddd") == expected
+        assert fr_parser.parse("mardi", "dddd") == expected
+
+        # Get first Tuesday in 2020
+        expected = datetime(2020, 1, 7)
+        assert self.parser.parse("Tue 2020", "ddd YYYY") == expected
+        assert fr_parser.parse("mar 2020", "ddd YYYY") == expected
+        assert self.parser.parse("Tuesday 2020", "dddd YYYY") == expected
+        assert fr_parser.parse("mardi 2020", "dddd YYYY") == expected
+
+        # Get first Tuesday in February 2020
+        expected = datetime(2020, 2, 4)
+        assert self.parser.parse("Tue 02 2020", "ddd MM YYYY") == expected
+        assert fr_parser.parse("mar 02 2020", "ddd MM YYYY") == expected
+        assert self.parser.parse("Tuesday 02 2020", "dddd MM YYYY") == expected
+        assert fr_parser.parse("mardi 02 2020", "dddd MM YYYY") == expected
+
+        # Get first Tuesday in February after epoch
+        expected = datetime(1970, 2, 3)
+        assert self.parser.parse("Tue 02", "ddd MM") == expected
+        assert fr_parser.parse("mar 02", "ddd MM") == expected
+        assert self.parser.parse("Tuesday 02", "dddd MM") == expected
+        assert fr_parser.parse("mardi 02", "dddd MM") == expected
+
+        # Times remain intact
+        expected = datetime(2020, 2, 4, 10, 25, 54, 123456, tz.tzoffset(None, -3600))
+        assert (
+            self.parser.parse(
+                "Tue 02 2020 10:25:54.123456-01:00", "ddd MM YYYY HH:mm:ss.SZZ"
+            )
+            == expected
+        )
+        assert (
+            fr_parser.parse(
+                "mar 02 2020 10:25:54.123456-01:00", "ddd MM YYYY HH:mm:ss.SZZ"
+            )
+            == expected
+        )
+        assert (
+            self.parser.parse(
+                "Tuesday 02 2020 10:25:54.123456-01:00", "dddd MM YYYY HH:mm:ss.SZZ"
+            )
+            == expected
+        )
+        assert (
+            fr_parser.parse(
+                "mardi 02 2020 10:25:54.123456-01:00", "dddd MM YYYY HH:mm:ss.SZZ"
+            )
+            == expected
+        )
+
+    def test_parse_ddd_and_dddd_ignore_case(self):
+        # Regression test for issue #851
+        expected = datetime(2019, 6, 24)
+        assert (
+            self.parser.parse("MONDAY, June 24, 2019", "dddd, MMMM DD, YYYY")
+            == expected
+        )
+
+    def test_parse_ddd_and_dddd_then_format(self):
+        # Regression test for issue #446
+        arw_formatter = formatter.DateTimeFormatter()
+        assert arw_formatter.format(self.parser.parse("Mon", "ddd"), "ddd") == "Mon"
+        assert (
+            arw_formatter.format(self.parser.parse("Monday", "dddd"), "dddd")
+            == "Monday"
+        )
+        assert arw_formatter.format(self.parser.parse("Tue", "ddd"), "ddd") == "Tue"
+        assert (
+            arw_formatter.format(self.parser.parse("Tuesday", "dddd"), "dddd")
+            == "Tuesday"
+        )
+        assert arw_formatter.format(self.parser.parse("Wed", "ddd"), "ddd") == "Wed"
+        assert (
+            arw_formatter.format(self.parser.parse("Wednesday", "dddd"), "dddd")
+            == "Wednesday"
+        )
+        assert arw_formatter.format(self.parser.parse("Thu", "ddd"), "ddd") == "Thu"
+        assert (
+            arw_formatter.format(self.parser.parse("Thursday", "dddd"), "dddd")
+            == "Thursday"
+        )
+        assert arw_formatter.format(self.parser.parse("Fri", "ddd"), "ddd") == "Fri"
+        assert (
+            arw_formatter.format(self.parser.parse("Friday", "dddd"), "dddd")
+            == "Friday"
+        )
+        assert arw_formatter.format(self.parser.parse("Sat", "ddd"), "ddd") == "Sat"
+        assert (
+            arw_formatter.format(self.parser.parse("Saturday", "dddd"), "dddd")
+            == "Saturday"
+        )
+        assert arw_formatter.format(self.parser.parse("Sun", "ddd"), "ddd") == "Sun"
+        assert (
+            arw_formatter.format(self.parser.parse("Sunday", "dddd"), "dddd")
+            == "Sunday"
+        )
+
+    def test_parse_HH_24(self):
+        assert self.parser.parse(
+            "2019-10-30T24:00:00", "YYYY-MM-DDTHH:mm:ss"
+        ) == datetime(2019, 10, 31, 0, 0, 0, 0)
+        assert self.parser.parse("2019-10-30T24:00", "YYYY-MM-DDTHH:mm") == datetime(
+            2019, 10, 31, 0, 0, 0, 0
+        )
+        assert self.parser.parse("2019-10-30T24", "YYYY-MM-DDTHH") == datetime(
+            2019, 10, 31, 0, 0, 0, 0
+        )
+        assert self.parser.parse(
+            "2019-10-30T24:00:00.0", "YYYY-MM-DDTHH:mm:ss.S"
+        ) == datetime(2019, 10, 31, 0, 0, 0, 0)
+        assert self.parser.parse(
+            "2019-10-31T24:00:00", "YYYY-MM-DDTHH:mm:ss"
+        ) == datetime(2019, 11, 1, 0, 0, 0, 0)
+        assert self.parser.parse(
+            "2019-12-31T24:00:00", "YYYY-MM-DDTHH:mm:ss"
+        ) == datetime(2020, 1, 1, 0, 0, 0, 0)
+        assert self.parser.parse(
+            "2019-12-31T23:59:59.9999999", "YYYY-MM-DDTHH:mm:ss.S"
+        ) == datetime(2020, 1, 1, 0, 0, 0, 0)
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2019-12-31T24:01:00", "YYYY-MM-DDTHH:mm:ss")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2019-12-31T24:00:01", "YYYY-MM-DDTHH:mm:ss")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2019-12-31T24:00:00.1", "YYYY-MM-DDTHH:mm:ss.S")
+
+        with pytest.raises(ParserError):
+            self.parser.parse("2019-12-31T24:00:00.999999", "YYYY-MM-DDTHH:mm:ss.S")
+
+    def test_parse_W(self):
+
+        assert self.parser.parse("2011-W05-4", "W") == datetime(2011, 2, 3)
+        assert self.parser.parse("2011W054", "W") == datetime(2011, 2, 3)
+        assert self.parser.parse("2011-W05", "W") == datetime(2011, 1, 31)
+        assert self.parser.parse("2011W05", "W") == datetime(2011, 1, 31)
+        assert self.parser.parse("2011-W05-4T14:17:01", "WTHH:mm:ss") == datetime(
+            2011, 2, 3, 14, 17, 1
+        )
+        assert self.parser.parse("2011W054T14:17:01", "WTHH:mm:ss") == datetime(
+            2011, 2, 3, 14, 17, 1
+        )
+        assert self.parser.parse("2011-W05T14:17:01", "WTHH:mm:ss") == datetime(
+            2011, 1, 31, 14, 17, 1
+        )
+        assert self.parser.parse("2011W05T141701", "WTHHmmss") == datetime(
+            2011, 1, 31, 14, 17, 1
+        )
+        assert self.parser.parse("2011W054T141701", "WTHHmmss") == datetime(
+            2011, 2, 3, 14, 17, 1
+        )
+
+        bad_formats = [
+            "201W22",
+            "1995-W1-4",
+            "2001-W34-90",
+            "2001--W34",
+            "2011-W03--3",
+            "thstrdjtrsrd676776r65",
+            "2002-W66-1T14:17:01",
+            "2002-W23-03T14:17:01",
+        ]
+
+        for fmt in bad_formats:
+            with pytest.raises(ParserError):
+                self.parser.parse(fmt, "W")
+
+    def test_parse_normalize_whitespace(self):
+        assert self.parser.parse(
+            "Jun 1 2005  1:33PM", "MMM D YYYY H:mmA", normalize_whitespace=True
+        ) == datetime(2005, 6, 1, 13, 33)
+
+        with pytest.raises(ParserError):
+            self.parser.parse("Jun 1 2005  1:33PM", "MMM D YYYY H:mmA")
+
+        assert (
+            self.parser.parse(
+                "\t 2013-05-05  T \n   12:30:45\t123456 \t \n",
+                "YYYY-MM-DD T HH:mm:ss S",
+                normalize_whitespace=True,
+            )
+            == datetime(2013, 5, 5, 12, 30, 45, 123456)
+        )
+
+        with pytest.raises(ParserError):
+            self.parser.parse(
+                "\t 2013-05-05  T \n   12:30:45\t123456 \t \n",
+                "YYYY-MM-DD T HH:mm:ss S",
+            )
+
+        assert self.parser.parse(
+            "  \n Jun   1\t 2005\n ", "MMM D YYYY", normalize_whitespace=True
+        ) == datetime(2005, 6, 1)
+
+        with pytest.raises(ParserError):
+            self.parser.parse("  \n Jun   1\t 2005\n ", "MMM D YYYY")
+
+
+@pytest.mark.usefixtures("dt_parser_regex")
+class TestDateTimeParserRegex:
+    def test_format_year(self):
+
+        assert self.format_regex.findall("YYYY-YY") == ["YYYY", "YY"]
+
+    def test_format_month(self):
+
+        assert self.format_regex.findall("MMMM-MMM-MM-M") == ["MMMM", "MMM", "MM", "M"]
+
+    def test_format_day(self):
+
+        assert self.format_regex.findall("DDDD-DDD-DD-D") == ["DDDD", "DDD", "DD", "D"]
+
+    def test_format_hour(self):
+
+        assert self.format_regex.findall("HH-H-hh-h") == ["HH", "H", "hh", "h"]
+
+    def test_format_minute(self):
+
+        assert self.format_regex.findall("mm-m") == ["mm", "m"]
+
+    def test_format_second(self):
+
+        assert self.format_regex.findall("ss-s") == ["ss", "s"]
+
+    def test_format_subsecond(self):
+
+        assert self.format_regex.findall("SSSSSS-SSSSS-SSSS-SSS-SS-S") == [
+            "SSSSSS",
+            "SSSSS",
+            "SSSS",
+            "SSS",
+            "SS",
+            "S",
+        ]
+
+    def test_format_tz(self):
+
+        assert self.format_regex.findall("ZZZ-ZZ-Z") == ["ZZZ", "ZZ", "Z"]
+
+    def test_format_am_pm(self):
+
+        assert self.format_regex.findall("A-a") == ["A", "a"]
+
+    def test_format_timestamp(self):
+
+        assert self.format_regex.findall("X") == ["X"]
+
+    def test_format_timestamp_milli(self):
+
+        assert self.format_regex.findall("x") == ["x"]
+
+    def test_escape(self):
+
+        escape_regex = parser.DateTimeParser._ESCAPE_RE
+
+        assert escape_regex.findall("2018-03-09 8 [h] 40 [hello]") == ["[h]", "[hello]"]
+
+    def test_month_names(self):
+        p = parser.DateTimeParser("en-us")
+
+        text = "_".join(calendar.month_name[1:])
+
+        result = p._input_re_map["MMMM"].findall(text)
+
+        assert result == calendar.month_name[1:]
+
+    def test_month_abbreviations(self):
+        p = parser.DateTimeParser("en-us")
+
+        text = "_".join(calendar.month_abbr[1:])
+
+        result = p._input_re_map["MMM"].findall(text)
+
+        assert result == calendar.month_abbr[1:]
+
+    def test_digits(self):
+
+        assert parser.DateTimeParser._ONE_OR_TWO_DIGIT_RE.findall("4-56") == ["4", "56"]
+        assert parser.DateTimeParser._ONE_OR_TWO_OR_THREE_DIGIT_RE.findall(
+            "4-56-789"
+        ) == ["4", "56", "789"]
+        assert parser.DateTimeParser._ONE_OR_MORE_DIGIT_RE.findall(
+            "4-56-789-1234-12345"
+        ) == ["4", "56", "789", "1234", "12345"]
+        assert parser.DateTimeParser._TWO_DIGIT_RE.findall("12-3-45") == ["12", "45"]
+        assert parser.DateTimeParser._THREE_DIGIT_RE.findall("123-4-56") == ["123"]
+        assert parser.DateTimeParser._FOUR_DIGIT_RE.findall("1234-56") == ["1234"]
+
+    def test_tz(self):
+        tz_z_re = parser.DateTimeParser._TZ_Z_RE
+        assert tz_z_re.findall("-0700") == [("-", "07", "00")]
+        assert tz_z_re.findall("+07") == [("+", "07", "")]
+        assert tz_z_re.search("15/01/2019T04:05:06.789120Z") is not None
+        assert tz_z_re.search("15/01/2019T04:05:06.789120") is None
+
+        tz_zz_re = parser.DateTimeParser._TZ_ZZ_RE
+        assert tz_zz_re.findall("-07:00") == [("-", "07", "00")]
+        assert tz_zz_re.findall("+07") == [("+", "07", "")]
+        assert tz_zz_re.search("15/01/2019T04:05:06.789120Z") is not None
+        assert tz_zz_re.search("15/01/2019T04:05:06.789120") is None
+
+        tz_name_re = parser.DateTimeParser._TZ_NAME_RE
+        assert tz_name_re.findall("Europe/Warsaw") == ["Europe/Warsaw"]
+        assert tz_name_re.findall("GMT") == ["GMT"]
+
+    def test_timestamp(self):
+        timestamp_re = parser.DateTimeParser._TIMESTAMP_RE
+        assert timestamp_re.findall("1565707550.452729") == ["1565707550.452729"]
+        assert timestamp_re.findall("-1565707550.452729") == ["-1565707550.452729"]
+        assert timestamp_re.findall("-1565707550") == ["-1565707550"]
+        assert timestamp_re.findall("1565707550") == ["1565707550"]
+        assert timestamp_re.findall("1565707550.") == []
+        assert timestamp_re.findall(".1565707550") == []
+
+    def test_timestamp_milli(self):
+        timestamp_expanded_re = parser.DateTimeParser._TIMESTAMP_EXPANDED_RE
+        assert timestamp_expanded_re.findall("-1565707550") == ["-1565707550"]
+        assert timestamp_expanded_re.findall("1565707550") == ["1565707550"]
+        assert timestamp_expanded_re.findall("1565707550.452729") == []
+        assert timestamp_expanded_re.findall("1565707550.") == []
+        assert timestamp_expanded_re.findall(".1565707550") == []
+
+    def test_time(self):
+        time_re = parser.DateTimeParser._TIME_RE
+        time_seperators = [":", ""]
+
+        for sep in time_seperators:
+            assert time_re.findall("12") == [("12", "", "", "", "")]
+            assert time_re.findall(f"12{sep}35") == [("12", "35", "", "", "")]
+            assert time_re.findall("12{sep}35{sep}46".format(sep=sep)) == [
+                ("12", "35", "46", "", "")
+            ]
+            assert time_re.findall("12{sep}35{sep}46.952313".format(sep=sep)) == [
+                ("12", "35", "46", ".", "952313")
+            ]
+            assert time_re.findall("12{sep}35{sep}46,952313".format(sep=sep)) == [
+                ("12", "35", "46", ",", "952313")
+            ]
+
+        assert time_re.findall("12:") == []
+        assert time_re.findall("12:35:46.") == []
+        assert time_re.findall("12:35:46,") == []
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserISO:
+    def test_YYYY(self):
+
+        assert self.parser.parse_iso("2013") == datetime(2013, 1, 1)
+
+    def test_YYYY_DDDD(self):
+        assert self.parser.parse_iso("1998-136") == datetime(1998, 5, 16)
+
+        assert self.parser.parse_iso("1998-006") == datetime(1998, 1, 6)
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("1998-456")
+
+        # 2016 is a leap year, so Feb 29 exists (leap day)
+        assert self.parser.parse_iso("2016-059") == datetime(2016, 2, 28)
+        assert self.parser.parse_iso("2016-060") == datetime(2016, 2, 29)
+        assert self.parser.parse_iso("2016-061") == datetime(2016, 3, 1)
+
+        # 2017 is not a leap year, so Feb 29 does not exist
+        assert self.parser.parse_iso("2017-059") == datetime(2017, 2, 28)
+        assert self.parser.parse_iso("2017-060") == datetime(2017, 3, 1)
+        assert self.parser.parse_iso("2017-061") == datetime(2017, 3, 2)
+
+        # Since 2016 is a leap year, the 366th day falls in the same year
+        assert self.parser.parse_iso("2016-366") == datetime(2016, 12, 31)
+
+        # Since 2017 is not a leap year, the 366th day falls in the next year
+        assert self.parser.parse_iso("2017-366") == datetime(2018, 1, 1)
+
+    def test_YYYY_DDDD_HH_mm_ssZ(self):
+
+        assert self.parser.parse_iso("2013-036 04:05:06+01:00") == datetime(
+            2013, 2, 5, 4, 5, 6, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-036 04:05:06Z") == datetime(
+            2013, 2, 5, 4, 5, 6, tzinfo=tz.tzutc()
+        )
+
+    def test_YYYY_MM_DDDD(self):
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2014-05-125")
+
+    def test_YYYY_MM(self):
+
+        for separator in DateTimeParser.SEPARATORS:
+            assert self.parser.parse_iso(separator.join(("2013", "02"))) == datetime(
+                2013, 2, 1
+            )
+
+    def test_YYYY_MM_DD(self):
+
+        for separator in DateTimeParser.SEPARATORS:
+            assert self.parser.parse_iso(
+                separator.join(("2013", "02", "03"))
+            ) == datetime(2013, 2, 3)
+
+    def test_YYYY_MM_DDTHH_mmZ(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05+01:00") == datetime(
+            2013, 2, 3, 4, 5, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+    def test_YYYY_MM_DDTHH_mm(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05") == datetime(2013, 2, 3, 4, 5)
+
+    def test_YYYY_MM_DDTHH(self):
+
+        assert self.parser.parse_iso("2013-02-03T04") == datetime(2013, 2, 3, 4)
+
+    def test_YYYY_MM_DDTHHZ(self):
+
+        assert self.parser.parse_iso("2013-02-03T04+01:00") == datetime(
+            2013, 2, 3, 4, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+    def test_YYYY_MM_DDTHH_mm_ssZ(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+    def test_YYYY_MM_DDTHH_mm_ss(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06") == datetime(
+            2013, 2, 3, 4, 5, 6
+        )
+
+    def test_YYYY_MM_DD_HH_mmZ(self):
+
+        assert self.parser.parse_iso("2013-02-03 04:05+01:00") == datetime(
+            2013, 2, 3, 4, 5, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+    def test_YYYY_MM_DD_HH_mm(self):
+
+        assert self.parser.parse_iso("2013-02-03 04:05") == datetime(2013, 2, 3, 4, 5)
+
+    def test_YYYY_MM_DD_HH(self):
+
+        assert self.parser.parse_iso("2013-02-03 04") == datetime(2013, 2, 3, 4)
+
+    def test_invalid_time(self):
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03 044")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03 04:05:06.")
+
+    def test_YYYY_MM_DD_HH_mm_ssZ(self):
+
+        assert self.parser.parse_iso("2013-02-03 04:05:06+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+    def test_YYYY_MM_DD_HH_mm_ss(self):
+
+        assert self.parser.parse_iso("2013-02-03 04:05:06") == datetime(
+            2013, 2, 3, 4, 5, 6
+        )
+
+    def test_YYYY_MM_DDTHH_mm_ss_S(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.7") == datetime(
+            2013, 2, 3, 4, 5, 6, 700000
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.78") == datetime(
+            2013, 2, 3, 4, 5, 6, 780000
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.789") == datetime(
+            2013, 2, 3, 4, 5, 6, 789000
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.7891") == datetime(
+            2013, 2, 3, 4, 5, 6, 789100
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.78912") == datetime(
+            2013, 2, 3, 4, 5, 6, 789120
+        )
+
+        # ISO 8601:2004(E), ISO, 2004-12-01, 4.2.2.4 ... the decimal fraction
+        # shall be divided from the integer part by the decimal sign specified
+        # in ISO 31-0, i.e. the comma [,] or full stop [.]. Of these, the comma
+        # is the preferred sign.
+        assert self.parser.parse_iso("2013-02-03T04:05:06,789123678") == datetime(
+            2013, 2, 3, 4, 5, 6, 789124
+        )
+
+        # there is no limit on the number of decimal places
+        assert self.parser.parse_iso("2013-02-03T04:05:06.789123678") == datetime(
+            2013, 2, 3, 4, 5, 6, 789124
+        )
+
+    def test_YYYY_MM_DDTHH_mm_ss_SZ(self):
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.7+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, 700000, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.78+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, 780000, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.789+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, 789000, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.7891+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, 789100, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-02-03T04:05:06.78912+01:00") == datetime(
+            2013, 2, 3, 4, 5, 6, 789120, tzinfo=tz.tzoffset(None, 3600)
+        )
+
+        assert self.parser.parse_iso("2013-02-03 04:05:06.78912Z") == datetime(
+            2013, 2, 3, 4, 5, 6, 789120, tzinfo=tz.tzutc()
+        )
+
+    def test_W(self):
+
+        assert self.parser.parse_iso("2011-W05-4") == datetime(2011, 2, 3)
+
+        assert self.parser.parse_iso("2011-W05-4T14:17:01") == datetime(
+            2011, 2, 3, 14, 17, 1
+        )
+
+        assert self.parser.parse_iso("2011W054") == datetime(2011, 2, 3)
+
+        assert self.parser.parse_iso("2011W054T141701") == datetime(
+            2011, 2, 3, 14, 17, 1
+        )
+
+    def test_invalid_Z(self):
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912z")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912zz")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912Zz")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912ZZ")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912+Z")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912-Z")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-02-03T04:05:06.78912 Z")
+
+    def test_parse_subsecond(self):
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 900000)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.9") == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 980000)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.98") == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987000)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.987") == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987600)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.9876") == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987650)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.98765") == self.expected
+
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987654)
+        assert self.parser.parse_iso("2013-01-01 12:30:45.987654") == self.expected
+
+        # use comma as subsecond separator
+        self.expected = datetime(2013, 1, 1, 12, 30, 45, 987654)
+        assert self.parser.parse_iso("2013-01-01 12:30:45,987654") == self.expected
+
+    def test_gnu_date(self):
+        """Regression tests for parsing output from GNU date."""
+        # date -Ins
+        assert self.parser.parse_iso("2016-11-16T09:46:30,895636557-0800") == datetime(
+            2016, 11, 16, 9, 46, 30, 895636, tzinfo=tz.tzoffset(None, -3600 * 8)
+        )
+
+        # date --rfc-3339=ns
+        assert self.parser.parse_iso("2016-11-16 09:51:14.682141526-08:00") == datetime(
+            2016, 11, 16, 9, 51, 14, 682142, tzinfo=tz.tzoffset(None, -3600 * 8)
+        )
+
+    def test_isoformat(self):
+
+        dt = datetime.utcnow()
+
+        assert self.parser.parse_iso(dt.isoformat()) == dt
+
+    def test_parse_iso_normalize_whitespace(self):
+        assert self.parser.parse_iso(
+            "2013-036 \t  04:05:06Z", normalize_whitespace=True
+        ) == datetime(2013, 2, 5, 4, 5, 6, tzinfo=tz.tzutc())
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2013-036 \t  04:05:06Z")
+
+        assert self.parser.parse_iso(
+            "\t 2013-05-05T12:30:45.123456 \t \n", normalize_whitespace=True
+        ) == datetime(2013, 5, 5, 12, 30, 45, 123456)
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("\t 2013-05-05T12:30:45.123456 \t \n")
+
+    def test_parse_iso_with_leading_and_trailing_whitespace(self):
+        datetime_string = "    2016-11-15T06:37:19.123456"
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        datetime_string = "    2016-11-15T06:37:19.123456     "
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        datetime_string = "2016-11-15T06:37:19.123456 "
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        datetime_string = "2016-11-15T 06:37:19.123456"
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        # leading whitespace
+        datetime_string = "    2016-11-15 06:37:19.123456"
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        # trailing whitespace
+        datetime_string = "2016-11-15 06:37:19.123456    "
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        datetime_string = "    2016-11-15 06:37:19.123456    "
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+        # two dividing spaces
+        datetime_string = "2016-11-15  06:37:19.123456"
+        with pytest.raises(ParserError):
+            self.parser.parse_iso(datetime_string)
+
+    def test_parse_iso_with_extra_words_at_start_and_end_invalid(self):
+        test_inputs = [
+            "blah2016",
+            "blah2016blah",
+            "blah 2016 blah",
+            "blah 2016",
+            "2016 blah",
+            "blah 2016-05-16 04:05:06.789120",
+            "2016-05-16 04:05:06.789120 blah",
+            "blah 2016-05-16T04:05:06.789120",
+            "2016-05-16T04:05:06.789120 blah",
+            "2016blah",
+            "2016-05blah",
+            "2016-05-16blah",
+            "2016-05-16T04:05:06.789120blah",
+            "2016-05-16T04:05:06.789120ZblahZ",
+            "2016-05-16T04:05:06.789120Zblah",
+            "2016-05-16T04:05:06.789120blahZ",
+            "Meet me at 2016-05-16T04:05:06.789120 at the restaurant.",
+            "Meet me at 2016-05-16 04:05:06.789120 at the restaurant.",
+        ]
+
+        for ti in test_inputs:
+            with pytest.raises(ParserError):
+                self.parser.parse_iso(ti)
+
+    def test_iso8601_basic_format(self):
+        assert self.parser.parse_iso("20180517") == datetime(2018, 5, 17)
+
+        assert self.parser.parse_iso("20180517T10") == datetime(2018, 5, 17, 10)
+
+        assert self.parser.parse_iso("20180517T105513.843456") == datetime(
+            2018, 5, 17, 10, 55, 13, 843456
+        )
+
+        assert self.parser.parse_iso("20180517T105513Z") == datetime(
+            2018, 5, 17, 10, 55, 13, tzinfo=tz.tzutc()
+        )
+
+        assert self.parser.parse_iso("20180517T105513.843456-0700") == datetime(
+            2018, 5, 17, 10, 55, 13, 843456, tzinfo=tz.tzoffset(None, -25200)
+        )
+
+        assert self.parser.parse_iso("20180517T105513-0700") == datetime(
+            2018, 5, 17, 10, 55, 13, tzinfo=tz.tzoffset(None, -25200)
+        )
+
+        assert self.parser.parse_iso("20180517T105513-07") == datetime(
+            2018, 5, 17, 10, 55, 13, tzinfo=tz.tzoffset(None, -25200)
+        )
+
+        # ordinal in basic format: YYYYDDDD
+        assert self.parser.parse_iso("1998136") == datetime(1998, 5, 16)
+
+        # timezone requires +- separator
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("20180517T1055130700")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("20180517T10551307")
+
+        # too many digits in date
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("201860517T105513Z")
+
+        # too many digits in time
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("20180517T1055213Z")
+
+    def test_midnight_end_day(self):
+        assert self.parser.parse_iso("2019-10-30T24:00:00") == datetime(
+            2019, 10, 31, 0, 0, 0, 0
+        )
+        assert self.parser.parse_iso("2019-10-30T24:00") == datetime(
+            2019, 10, 31, 0, 0, 0, 0
+        )
+        assert self.parser.parse_iso("2019-10-30T24:00:00.0") == datetime(
+            2019, 10, 31, 0, 0, 0, 0
+        )
+        assert self.parser.parse_iso("2019-10-31T24:00:00") == datetime(
+            2019, 11, 1, 0, 0, 0, 0
+        )
+        assert self.parser.parse_iso("2019-12-31T24:00:00") == datetime(
+            2020, 1, 1, 0, 0, 0, 0
+        )
+        assert self.parser.parse_iso("2019-12-31T23:59:59.9999999") == datetime(
+            2020, 1, 1, 0, 0, 0, 0
+        )
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2019-12-31T24:01:00")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2019-12-31T24:00:01")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2019-12-31T24:00:00.1")
+
+        with pytest.raises(ParserError):
+            self.parser.parse_iso("2019-12-31T24:00:00.999999")
+
+
+@pytest.mark.usefixtures("tzinfo_parser")
+class TestTzinfoParser:
+    def test_parse_local(self):
+
+        assert self.parser.parse("local") == tz.tzlocal()
+
+    def test_parse_utc(self):
+
+        assert self.parser.parse("utc") == tz.tzutc()
+        assert self.parser.parse("UTC") == tz.tzutc()
+
+    def test_parse_iso(self):
+
+        assert self.parser.parse("01:00") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("11:35") == tz.tzoffset(None, 11 * 3600 + 2100)
+        assert self.parser.parse("+01:00") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("-01:00") == tz.tzoffset(None, -3600)
+
+        assert self.parser.parse("0100") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("+0100") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("-0100") == tz.tzoffset(None, -3600)
+
+        assert self.parser.parse("01") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("+01") == tz.tzoffset(None, 3600)
+        assert self.parser.parse("-01") == tz.tzoffset(None, -3600)
+
+    def test_parse_str(self):
+
+        assert self.parser.parse("US/Pacific") == tz.gettz("US/Pacific")
+
+    def test_parse_fails(self):
+
+        with pytest.raises(parser.ParserError):
+            self.parser.parse("fail")
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserMonthName:
+    def test_shortmonth_capitalized(self):
+
+        assert self.parser.parse("2013-Jan-01", "YYYY-MMM-DD") == datetime(2013, 1, 1)
+
+    def test_shortmonth_allupper(self):
+
+        assert self.parser.parse("2013-JAN-01", "YYYY-MMM-DD") == datetime(2013, 1, 1)
+
+    def test_shortmonth_alllower(self):
+
+        assert self.parser.parse("2013-jan-01", "YYYY-MMM-DD") == datetime(2013, 1, 1)
+
+    def test_month_capitalized(self):
+
+        assert self.parser.parse("2013-January-01", "YYYY-MMMM-DD") == datetime(
+            2013, 1, 1
+        )
+
+    def test_month_allupper(self):
+
+        assert self.parser.parse("2013-JANUARY-01", "YYYY-MMMM-DD") == datetime(
+            2013, 1, 1
+        )
+
+    def test_month_alllower(self):
+
+        assert self.parser.parse("2013-january-01", "YYYY-MMMM-DD") == datetime(
+            2013, 1, 1
+        )
+
+    def test_localized_month_name(self):
+        parser_ = parser.DateTimeParser("fr-fr")
+
+        assert parser_.parse("2013-Janvier-01", "YYYY-MMMM-DD") == datetime(2013, 1, 1)
+
+    def test_localized_month_abbreviation(self):
+        parser_ = parser.DateTimeParser("it-it")
+
+        assert parser_.parse("2013-Gen-01", "YYYY-MMM-DD") == datetime(2013, 1, 1)
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserMeridians:
+    def test_meridians_lowercase(self):
+        assert self.parser.parse("2013-01-01 5am", "YYYY-MM-DD ha") == datetime(
+            2013, 1, 1, 5
+        )
+
+        assert self.parser.parse("2013-01-01 5pm", "YYYY-MM-DD ha") == datetime(
+            2013, 1, 1, 17
+        )
+
+    def test_meridians_capitalized(self):
+        assert self.parser.parse("2013-01-01 5AM", "YYYY-MM-DD hA") == datetime(
+            2013, 1, 1, 5
+        )
+
+        assert self.parser.parse("2013-01-01 5PM", "YYYY-MM-DD hA") == datetime(
+            2013, 1, 1, 17
+        )
+
+    def test_localized_meridians_lowercase(self):
+        parser_ = parser.DateTimeParser("hu-hu")
+        assert parser_.parse("2013-01-01 5 de", "YYYY-MM-DD h a") == datetime(
+            2013, 1, 1, 5
+        )
+
+        assert parser_.parse("2013-01-01 5 du", "YYYY-MM-DD h a") == datetime(
+            2013, 1, 1, 17
+        )
+
+    def test_localized_meridians_capitalized(self):
+        parser_ = parser.DateTimeParser("hu-hu")
+        assert parser_.parse("2013-01-01 5 DE", "YYYY-MM-DD h A") == datetime(
+            2013, 1, 1, 5
+        )
+
+        assert parser_.parse("2013-01-01 5 DU", "YYYY-MM-DD h A") == datetime(
+            2013, 1, 1, 17
+        )
+
+    # regression test for issue #607
+    def test_es_meridians(self):
+        parser_ = parser.DateTimeParser("es")
+
+        assert parser_.parse(
+            "Junio 30, 2019 - 08:00 pm", "MMMM DD, YYYY - hh:mm a"
+        ) == datetime(2019, 6, 30, 20, 0)
+
+        with pytest.raises(ParserError):
+            parser_.parse(
+                "Junio 30, 2019 - 08:00 pasdfasdfm", "MMMM DD, YYYY - hh:mm a"
+            )
+
+    def test_fr_meridians(self):
+        parser_ = parser.DateTimeParser("fr")
+
+        # the French locale always uses a 24 hour clock, so it does not support meridians
+        with pytest.raises(ParserError):
+            parser_.parse("Janvier 30, 2019 - 08:00 pm", "MMMM DD, YYYY - hh:mm a")
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserMonthOrdinalDay:
+    def test_english(self):
+        parser_ = parser.DateTimeParser("en-us")
+
+        assert parser_.parse("January 1st, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 1
+        )
+        assert parser_.parse("January 2nd, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 2
+        )
+        assert parser_.parse("January 3rd, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 3
+        )
+        assert parser_.parse("January 4th, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 4
+        )
+        assert parser_.parse("January 11th, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 11
+        )
+        assert parser_.parse("January 12th, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 12
+        )
+        assert parser_.parse("January 13th, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 13
+        )
+        assert parser_.parse("January 21st, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 21
+        )
+        assert parser_.parse("January 31st, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 31
+        )
+
+        with pytest.raises(ParserError):
+            parser_.parse("January 1th, 2013", "MMMM Do, YYYY")
+
+        with pytest.raises(ParserError):
+            parser_.parse("January 11st, 2013", "MMMM Do, YYYY")
+
+    def test_italian(self):
+        parser_ = parser.DateTimeParser("it-it")
+
+        assert parser_.parse("Gennaio 1, 2013, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 1
+        )
+
+    def test_spanish(self):
+        parser_ = parser.DateTimeParser("es-es")
+
+        assert parser_.parse("Enero 1, 2013", "MMMM Do, YYYY") == datetime(2013, 1, 1)
+
+    def test_french(self):
+        parser_ = parser.DateTimeParser("fr-fr")
+
+        assert parser_.parse("Janvier 1er, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 1
+        )
+
+        assert parser_.parse("Janvier 2e, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 2
+        )
+
+        assert parser_.parse("Janvier 11e, 2013", "MMMM Do, YYYY") == datetime(
+            2013, 1, 11
+        )
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestDateTimeParserSearchDate:
+    def test_parse_search(self):
+
+        assert self.parser.parse(
+            "Today is 25 of September of 2003", "DD of MMMM of YYYY"
+        ) == datetime(2003, 9, 25)
+
+    def test_parse_search_with_numbers(self):
+
+        assert self.parser.parse(
+            "2000 people met the 2012-01-01 12:05:10", "YYYY-MM-DD HH:mm:ss"
+        ) == datetime(2012, 1, 1, 12, 5, 10)
+
+        assert self.parser.parse(
+            "Call 01-02-03 on 79-01-01 12:05:10", "YY-MM-DD HH:mm:ss"
+        ) == datetime(1979, 1, 1, 12, 5, 10)
+
+    def test_parse_search_with_names(self):
+
+        assert self.parser.parse("June was born in May 1980", "MMMM YYYY") == datetime(
+            1980, 5, 1
+        )
+
+    def test_parse_search_locale_with_names(self):
+        p = parser.DateTimeParser("sv-se")
+
+        assert p.parse("Jan f+ddes den 31 Dec 1980", "DD MMM YYYY") == datetime(
+            1980, 12, 31
+        )
+
+        assert p.parse("Jag f+ddes den 25 Augusti 1975", "DD MMMM YYYY") == datetime(
+            1975, 8, 25
+        )
+
+    def test_parse_search_fails(self):
+
+        with pytest.raises(parser.ParserError):
+            self.parser.parse("Jag f+ddes den 25 Augusti 1975", "DD MMMM YYYY")
+
+    def test_escape(self):
+
+        format = "MMMM D, YYYY [at] h:mma"
+        assert self.parser.parse(
+            "Thursday, December 10, 2015 at 5:09pm", format
+        ) == datetime(2015, 12, 10, 17, 9)
+
+        format = "[MMMM] M D, YYYY [at] h:mma"
+        assert self.parser.parse("MMMM 12 10, 2015 at 5:09pm", format) == datetime(
+            2015, 12, 10, 17, 9
+        )
+
+        format = "[It happened on] MMMM Do [in the year] YYYY [a long time ago]"
+        assert self.parser.parse(
+            "It happened on November 25th in the year 1990 a long time ago", format
+        ) == datetime(1990, 11, 25)
+
+        format = "[It happened on] MMMM Do [in the][ year] YYYY [a long time ago]"
+        assert self.parser.parse(
+            "It happened on November 25th in the year 1990 a long time ago", format
+        ) == datetime(1990, 11, 25)
+
+        format = "[I'm][ entirely][ escaped,][ weee!]"
+        assert self.parser.parse("I'm entirely escaped, weee!", format) == datetime(
+            1, 1, 1
+        )
+
+        # Special RegEx characters
+        format = "MMM DD, YYYY |^${}().*+?<>-& h:mm A"
+        assert self.parser.parse(
+            "Dec 31, 2017 |^${}().*+?<>-& 2:00 AM", format
+        ) == datetime(2017, 12, 31, 2, 0)
+
+
+@pytest.mark.usefixtures("dt_parser")
+class TestFuzzInput:
+    # Regression test for issue #860
+    def test_no_match_group(self):
+        fmt_str = str(b"[|\x1f\xb9\x03\x00\x00\x00\x00:-yI:][\x01yI:yI:I")
+        payload = str(b"")
+
+        with pytest.raises(parser.ParserMatchError):
+            self.parser.parse(payload, fmt_str)
+
+    # Regression test for issue #854
+    def test_regex_module_error(self):
+        fmt_str = str(b"struct n[X+,N-M)MMXdMM]<")
+        payload = str(b"")
+
+        with pytest.raises(parser.ParserMatchError):
+            self.parser.parse(payload, fmt_str)
