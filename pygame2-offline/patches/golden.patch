diff --git a/src_py/surfarray.py b/src_py/surfarray.py
index 96c0b8d..8243460 100644
--- a/src_py/surfarray.py
+++ b/src_py/surfarray.py
@@ -94,67 +94,310 @@ __all__ = [
 
 
 def blit_array(surface, array):
-    return None
+    """pygame.surfarray.blit_array(Surface, array): return None
+
+    Blit directly from a array values.
+
+    Directly copy values from an array into a Surface. This is faster than
+    converting the array into a Surface and blitting. The array must be the
+    same dimensions as the Surface and will completely replace all pixel
+    values. Only integer, ascii character and record arrays are accepted.
+
+    This function will temporarily lock the Surface as the new values are
+    copied.
+    """
+    if isinstance(array, numpy_ndarray) and array.dtype in numpy_floats:
+        array = array.round(0).astype(numpy_uint32)
+    return array_to_surface(surface, array)
 
 
 def make_surface(array):
-    return None
+    """pygame.surfarray.make_surface (array): return Surface
+
+    Copy an array to a new surface.
+
+    Create a new Surface that best resembles the data and format on the
+    array. The array can be 2D or 3D with any sized integer values.
+    """
+    if isinstance(array, numpy_ndarray) and array.dtype in numpy_floats:
+        array = array.round(0).astype(numpy_uint32)
+    return pix_make_surface(array)
 
 
 def array2d(surface):
-    return None
+    """pygame.surfarray.array2d(Surface): return array
+
+    copy pixels into a 2d array
+
+    Copy the pixels from a Surface into a 2D array. The bit depth of the
+    surface will control the size of the integer values, and will work
+    for any type of pixel format.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    bpp = surface.get_bytesize()
+    try:
+        dtype = (numpy.uint8, numpy.uint16, numpy.int32, numpy.int32)[bpp - 1]
+    except IndexError:
+        raise ValueError(f"unsupported bit depth {bpp * 8} for 2D array")
+    size = surface.get_size()
+    array = numpy.empty(size, dtype)
+    surface_to_array(array, surface)
+    return array
 
 
 def pixels2d(surface):
-    return None
+    """pygame.surfarray.pixels2d(Surface): return array
+
+    reference pixels into a 2d array
+
+    Create a new 2D array that directly references the pixel values in a
+    Surface. Any changes to the array will affect the pixels in the
+    Surface. This is a fast operation since no data is copied.
+
+    Pixels from a 24-bit Surface cannot be referenced, but all other
+    Surface bit depths can.
+
+    The Surface this references will remain locked for the lifetime of
+    the array (see the Surface.lock - lock the Surface memory for pixel
+    access method).
+    """
+    if surface.get_bitsize() not in _pixel2d_bitdepths:
+        raise ValueError("unsupported bit depth for 2D reference array")
+    try:
+        return numpy_array(surface.get_view("2"), copy=False)
+    except (ValueError, TypeError):
+        raise ValueError(
+            f"bit depth {surface.get_bitsize()} unsupported for 2D reference array"
+        )
 
 
 def array3d(surface):
-    return None
+    """pygame.surfarray.array3d(Surface): return array
+
+    copy pixels into a 3d array
+
+    Copy the pixels from a Surface into a 3D array. The bit depth of the
+    surface will control the size of the integer values, and will work
+    for any type of pixel format.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    width, height = surface.get_size()
+    array = numpy.empty((width, height, 3), numpy.uint8)
+    surface_to_array(array, surface)
+    return array
 
 
 def pixels3d(surface):
-    return None
+    """pygame.surfarray.pixels3d(Surface): return array
+
+    reference pixels into a 3d array
+
+    Create a new 3D array that directly references the pixel values in a
+    Surface. Any changes to the array will affect the pixels in the
+    Surface. This is a fast operation since no data is copied.
+
+    This will only work on Surfaces that have 24-bit or 32-bit
+    formats. Lower pixel formats cannot be referenced.
+
+    The Surface this references will remain locked for the lifetime of
+    the array (see the Surface.lock - lock the Surface memory for pixel
+    access method).
+    """
+    return numpy_array(surface.get_view("3"), copy=False)
 
 
 def array_alpha(surface):
-    return None
+    """pygame.surfarray.array_alpha(Surface): return array
+
+    copy pixel alphas into a 2d array
+
+    Copy the pixel alpha values (degree of transparency) from a Surface
+    into a 2D array. This will work for any type of Surface
+    format. Surfaces without a pixel alpha will return an array with all
+    opaque values.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    size = surface.get_size()
+    array = numpy.empty(size, numpy.uint8)
+    surface_to_array(array, surface, "A")
+    return array
 
 
 def pixels_alpha(surface):
-    return None
+    """pygame.surfarray.pixels_alpha(Surface): return array
+
+    reference pixel alphas into a 2d array
+
+    Create a new 2D array that directly references the alpha values
+    (degree of transparency) in a Surface. Any changes to the array will
+    affect the pixels in the Surface. This is a fast operation since no
+    data is copied.
+
+    This can only work on 32-bit Surfaces with a per-pixel alpha value.
+
+    The Surface this array references will remain locked for the
+    lifetime of the array.
+    """
+    return numpy.array(surface.get_view("A"), copy=False)
 
 
 def pixels_red(surface):
-    return None
+    """pygame.surfarray.pixels_red(Surface): return array
+
+    Reference pixel red into a 2d array.
+
+    Create a new 2D array that directly references the red values
+    in a Surface. Any changes to the array will affect the pixels
+    in the Surface. This is a fast operation since no data is copied.
+
+    This can only work on 24-bit or 32-bit Surfaces.
+
+    The Surface this array references will remain locked for the
+    lifetime of the array.
+    """
+    return numpy.array(surface.get_view("R"), copy=False)
 
 
 def array_red(surface):
-    return None
+    """pygame.surfarray.array_red(Surface): return array
+
+    copy pixel red into a 2d array
+
+    Copy the pixel red values from a Surface into a 2D array. This will work
+    for any type of Surface format.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    size = surface.get_size()
+    array = numpy.empty(size, numpy.uint8)
+    surface_to_array(array, surface, "R")
+    return array
 
 
 def pixels_green(surface):
-    return None
+    """pygame.surfarray.pixels_green(Surface): return array
+
+    Reference pixel green into a 2d array.
+
+    Create a new 2D array that directly references the green values
+    in a Surface. Any changes to the array will affect the pixels
+    in the Surface. This is a fast operation since no data is copied.
+
+    This can only work on 24-bit or 32-bit Surfaces.
+
+    The Surface this array references will remain locked for the
+    lifetime of the array.
+    """
+    return numpy.array(surface.get_view("G"), copy=False)
 
 
 def array_green(surface):
-    return None
+    """pygame.surfarray.array_green(Surface): return array
+
+    copy pixel green into a 2d array
+
+    Copy the pixel green values from a Surface into a 2D array. This will work
+    for any type of Surface format.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    size = surface.get_size()
+    array = numpy.empty(size, numpy.uint8)
+    surface_to_array(array, surface, "G")
+    return array
 
 
 def pixels_blue(surface):
-    return None
+    """pygame.surfarray.pixels_blue(Surface): return array
+
+    Reference pixel blue into a 2d array.
+
+    Create a new 2D array that directly references the blue values
+    in a Surface. Any changes to the array will affect the pixels
+    in the Surface. This is a fast operation since no data is copied.
+
+    This can only work on 24-bit or 32-bit Surfaces.
+
+    The Surface this array references will remain locked for the
+    lifetime of the array.
+    """
+    return numpy.array(surface.get_view("B"), copy=False)
 
 
 def array_blue(surface):
-    return None
+    """pygame.surfarray.array_blue(Surface): return array
+
+    copy pixel blue into a 2d array
+
+    Copy the pixel blue values from a Surface into a 2D array. This will work
+    for any type of Surface format.
+
+    This function will temporarily lock the Surface as pixels are copied
+    (see the Surface.lock - lock the Surface memory for pixel access
+    method).
+    """
+    size = surface.get_size()
+    array = numpy.empty(size, numpy.uint8)
+    surface_to_array(array, surface, "B")
+    return array
 
 
 def array_colorkey(surface):
-    return None
+    """pygame.surfarray.array_colorkey(Surface): return array
+
+    copy the colorkey values into a 2d array
+
+    Create a new array with the colorkey transparency value from each
+    pixel. If the pixel matches the colorkey it will be fully
+    transparent; otherwise it will be fully opaque.
+
+    This will work on any type of Surface format. If the image has no
+    colorkey a solid opaque array will be returned.
+
+    This function will temporarily lock the Surface as pixels are
+    copied.
+    """
+    size = surface.get_size()
+    array = numpy.empty(size, numpy.uint8)
+    surface_to_array(array, surface, "C")
+    return array
 
 
 def map_array(surface, array):
-    return None
+    """pygame.surfarray.map_array(Surface, array3d): return array2d
+
+    map a 3d array into a 2d array
+
+    Convert a 3D array into a 2D array. This will use the given Surface
+    format to control the conversion.
+
+    Note: arrays do not need to be 3D, as long as the minor axis has
+    three elements giving the component colours, any array shape can be
+    used (for example, a single colour can be mapped, or an array of
+    colours). The array shape is limited to eleven dimensions maximum,
+    including the three element minor axis.
+    """
+    if array.ndim == 0:
+        raise ValueError("array must have at least 1 dimension")
+    shape = array.shape
+    if shape[-1] != 3:
+        raise ValueError("array must be a 3d array of 3-value color data")
+    target = numpy_empty(shape[:-1], numpy.int32)
+    pix_map_array(target, array, surface)
+    return target
 
 
 def use_arraytype(arraytype):
diff --git a/src_py/sysfont.py b/src_py/sysfont.py
index d6f1dc9..cc79a2e 100644
--- a/src_py/sysfont.py
+++ b/src_py/sysfont.py
@@ -53,7 +53,43 @@ def _addfont(name, bold, italic, font, fontdict):
 
 
 def initsysfonts_win32():
-    return {}
+    """initialize fonts dictionary on Windows"""
+
+    fontdir = join(os.environ.get("WINDIR", "C:\\Windows"), "Fonts")
+    fonts = {}
+
+    # add fonts entered in the registry
+    microsoft_font_dirs = [
+        "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts",
+        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Fonts",
+    ]
+
+    for domain in [_winreg.HKEY_LOCAL_MACHINE, _winreg.HKEY_CURRENT_USER]:
+        for font_dir in microsoft_font_dirs:
+            try:
+                key = _winreg.OpenKey(domain, font_dir)
+            except FileNotFoundError:
+                continue
+
+            for i in range(_winreg.QueryInfoKey(key)[1]):
+                try:
+                    # name is the font's name e.g. Times New Roman (TrueType)
+                    # font is the font's filename e.g. times.ttf
+                    name, font, _ = _winreg.EnumValue(key, i)
+                except OSError:
+                    break
+
+                if splitext(font)[1].lower() not in OpenType_extensions:
+                    continue
+                if not dirname(font):
+                    font = join(fontdir, font)
+
+                # Some are named A & B, both names should be processed separately
+                # Ex: the main Cambria file is marked as "Cambria & Cambria Math"
+                for name in name.split("&"):
+                    _parse_font_entry_win(name, font, fonts)
+
+    return fonts
 
 
 def _parse_font_entry_win(name, font, fonts):
@@ -147,12 +183,68 @@ def _font_finder_darwin():
 
 
 def initsysfonts_darwin():
-    return {}
+    """Read the fonts on MacOS, and OS X."""
+    #  fc-list is not likely to be there on pre 10.4.x, or MacOS 10.10+
+    fonts = {}
+
+    fclist_locations = [
+        "/usr/X11/bin/fc-list",  # apple x11
+        "/usr/X11R6/bin/fc-list",  # apple x11
+    ]
+    for bin_location in fclist_locations:
+        if exists(bin_location):
+            fonts = initsysfonts_unix(bin_location)
+            break
+
+    if len(fonts) == 0:
+        fonts = _font_finder_darwin()
+
+    return fonts
 
 
 # read the fonts on unix
 def initsysfonts_unix(path="fc-list"):
-    return {}
+    """use the fc-list from fontconfig to get a list of fonts"""
+    fonts = {}
+
+    if sys.platform == "emscripten":
+        return fonts
+
+    try:
+        proc = subprocess.run(
+            [path, ":", "file", "family", "style"],
+            stdout=subprocess.PIPE,  # capture stdout
+            stderr=subprocess.PIPE,  # capture stderr
+            check=True,  # so that errors raise python exception which is handled below
+            timeout=1,  # so that we don't hang the program waiting
+        )
+
+    except FileNotFoundError:
+        warnings.warn(
+            f"'{path}' is missing, system fonts cannot be loaded on your platform"
+        )
+
+    except subprocess.TimeoutExpired:
+        warnings.warn(
+            f"Process running '{path}' timed-out! System fonts cannot be loaded on "
+            "your platform"
+        )
+
+    except subprocess.CalledProcessError as e:
+        warnings.warn(
+            f"'{path}' failed with error code {e.returncode}! System fonts cannot be "
+            f"loaded on your platform. Error log is:\n{e.stderr}"
+        )
+
+    else:
+        for entry in proc.stdout.decode("ascii", "ignore").splitlines():
+            try:
+                _parse_font_entry_unix(entry, fonts)
+            except ValueError:
+                # try the next one.
+                pass
+
+    return fonts
 
 
 def _parse_font_entry_unix(entry, fonts):
@@ -250,23 +342,176 @@ def create_aliases():
 
 
 def initsysfonts():
-    return
+    """
+    Initialise the sysfont module, called once. Locates the installed fonts
+    and creates some aliases for common font categories.
+
+    Has different initialisation functions for different platforms.
+    """
+    global is_init
+    if is_init:
+        # no need to re-init
+        return
+
+    if sys.platform == "win32":
+        fonts = initsysfonts_win32()
+    elif sys.platform == "darwin":
+        fonts = initsysfonts_darwin()
+    else:
+        fonts = initsysfonts_unix()
+
+    Sysfonts.update(fonts)
+    create_aliases()
+    is_init = True
 
 
 def font_constructor(fontpath, size, bold, italic):
-    return None
+    """
+    pygame.font specific declarations
+
+    :param fontpath: path to a font.
+    :param size: size of a font.
+    :param bold: bold style, True or False.
+    :param italic: italic style, True or False.
+
+    :return: A font.Font object.
+    """
+
+    font = Font(fontpath, size)
+    if bold:
+        font.set_bold(True)
+    if italic:
+        font.set_italic(True)
+
+    return font
 
 
 # the exported functions
 
 
 def SysFont(name, size, bold=False, italic=False, constructor=None):
-    return None
+    """pygame.font.SysFont(name, size, bold=False, italic=False, constructor=None) -> Font
+    Create a pygame Font from system font resources.
+
+    This will search the system fonts for the given font
+    name. You can also enable bold or italic styles, and
+    the appropriate system font will be selected if available.
+
+    This will always return a valid Font object, and will
+    fallback on the builtin pygame font if the given font
+    is not found.
+
+    Name can also be an iterable of font names, a string of
+    comma-separated font names, or a bytes of comma-separated
+    font names, in which case the set of names will be searched
+    in order. Pygame uses a small set of common font aliases. If the
+    specific font you ask for is not available, a reasonable
+    alternative may be used.
+
+    If optional constructor is provided, it must be a function with
+    signature constructor(fontpath, size, bold, italic) which returns
+    a Font instance. If None, a pygame.font.Font object is created.
+    """
+    if constructor is None:
+        constructor = font_constructor
+
+    initsysfonts()
+
+    gotbold = gotitalic = False
+    fontname = None
+    if name:
+        if isinstance(name, (str, bytes)):
+            name = name.split(b"," if isinstance(name, bytes) else ",")
+        for single_name in name:
+            if isinstance(single_name, bytes):
+                single_name = single_name.decode()
+
+            single_name = _simplename(single_name)
+            styles = Sysfonts.get(single_name)
+            if not styles:
+                styles = Sysalias.get(single_name)
+            if styles:
+                plainname = styles.get((False, False))
+                fontname = styles.get((bold, italic))
+                if not (fontname or plainname):
+                    # Neither requested style, nor plain font exists, so
+                    # return a font with the name requested, but an
+                    # arbitrary style.
+                    (style, fontname) = list(styles.items())[0]
+                    # Attempt to style it as requested. This can't
+                    # unbold or unitalicize anything, but it can
+                    # fake bold and/or fake italicize.
+                    if bold and style[0]:
+                        gotbold = True
+                    if italic and style[1]:
+                        gotitalic = True
+                elif not fontname:
+                    fontname = plainname
+                elif plainname != fontname:
+                    gotbold = bold
+                    gotitalic = italic
+            if fontname:
+                break
+
+    set_bold = set_italic = False
+    if bold and not gotbold:
+        set_bold = True
+    if italic and not gotitalic:
+        set_italic = True
+
+    return constructor(fontname, size, set_bold, set_italic)
 
 
 def get_fonts():
-    return []
+    """pygame.font.get_fonts() -> list
+    get a list of system font names
+
+    Returns the list of all found system fonts. Note that
+    the names of the fonts will be all lowercase with spaces
+    removed. This is how pygame internally stores the font
+    names for matching.
+    """
+    initsysfonts()
+    return list(Sysfonts)
 
 
 def match_font(name, bold=False, italic=False):
-    return None
+    """pygame.font.match_font(name, bold=0, italic=0) -> name
+    find the filename for the named system font
+
+    This performs the same font search as the SysFont()
+    function, only it returns the path to the TTF file
+    that would be loaded. The font name can also be an
+    iterable of font names or a string/bytes of comma-separated
+    font names to try.
+
+    If no match is found, None is returned.
+    """
+    initsysfonts()
+
+    fontname = None
+    if isinstance(name, (str, bytes)):
+        name = name.split(b"," if isinstance(name, bytes) else ",")
+
+    for single_name in name:
+        if isinstance(single_name, bytes):
+            single_name = single_name.decode()
+
+        single_name = _simplename(single_name)
+        styles = Sysfonts.get(single_name)
+        if not styles:
+            styles = Sysalias.get(single_name)
+        if styles:
+            while not fontname:
+                fontname = styles.get((bold, italic))
+                if italic:
+                    italic = 0
+                elif bold:
+                    bold = 0
+                elif not fontname:
+                    fontname = list(styles.values())[0]
+
+        if fontname:
+            break
+
+    return fontname
