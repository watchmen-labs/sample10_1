...F....FF..F.FFFFFFF.FFF.FFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFEE..EE [ 15%]
EEFFFFFFFFFFF.FFFFFFFF........................FFFFFF..FFFFFFF.........F. [ 30%]
FFFFFFFFFFFFFFFFFF...FFF.F....FFFFF....FFFFFF.FFFFFFFFFFF..F............ [ 45%]
..................................ss.s..........s...............FFEEEEEE [ 60%]
EEE......FFFF.....F................FFFF...FFFFFFFFFFFFFF...F.FEFF....... [ 75%]
...........F.FFFFFFFFFssFFFFFF.FFFFFFFFFFFFF.FFFEE....FFFF....FFFF.FF..F [ 90%]
.FEFFFF..FFFFE.FFFFFFF...EFFFFFFFFFFFFFFFFFFFFFF                         [100%]
==================================== ERRORS ====================================
________________________ ERROR at setup of test_flashes ________________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9ea70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________________ ERROR at setup of test_make_response _____________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735972da0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_________ ERROR at setup of test_make_response_with_response_instance __________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735604370>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
___________________ ERROR at setup of test_jsonify_mimetype ____________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735e37430>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
__________________ ERROR at setup of test_json_dump_dataclass __________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd5810>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________ ERROR at setup of test_jsonify_args_and_kwargs_check _____________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735971390>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________________ ERROR at setup of test_url_generation _____________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c87490>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
________________ ERROR at setup of TestSendfile.test_send_file _________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735305d80>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________ ERROR at setup of TestSendfile.test_static_file ________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355cc0d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
___________ ERROR at setup of TestSendfile.test_send_from_directory ____________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd5a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________ ERROR at setup of TestUrlFor.test_url_for_with_anchor _____________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735617ca0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________ ERROR at setup of TestUrlFor.test_url_for_with_scheme _____________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c716f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______ ERROR at setup of TestUrlFor.test_url_for_with_scheme_not_external ______

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735307b50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______ ERROR at setup of TestUrlFor.test_url_for_with_alternating_schemes ______

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ae530>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______________ ERROR at setup of TestUrlFor.test_url_with_method _______________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355ccd60>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________ ERROR at setup of TestUrlFor.test_url_for_with_self ______________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355843d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________________ ERROR at setup of test_tojson_filter _____________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b41660>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
__________ ERROR at setup of test_escaping_without_template_filename ___________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565ebf0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
________________________ ERROR at setup of test_macros _________________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73562f550>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
___________________ ERROR at setup of test_environ_defaults ____________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7350e2d10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
>       if app_ctx is None or app_ctx.app is not self.app:
E       AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:347: AttributeError
___________ ERROR at setup of test_session_transactions_keep_context ___________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735712200>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________ ERROR at setup of test_client_pop_all_preserved ________________

app = <Flask 'flask_test'>

    @pytest.fixture
    def req_ctx(app):
>       with app.test_request_context() as ctx:

tests/conftest.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7358687f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
=================================== FAILURES ===================================
____________________ test_request_context_means_app_context ____________________

app = <Flask 'flask_test'>

    def test_request_context_means_app_context(app):
>       with app.test_request_context():

tests/test_appctx.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ca30a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_________ test_app_tearing_down_with_handled_exception_by_app_handler __________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354160e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce1d50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
>       if app_ctx is None or app_ctx.app is not self.app:
E       AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:347: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):
        app.config["PROPAGATE_EXCEPTIONS"] = True
        cleanup_stuff = []
    
        @app.teardown_appcontext
        def cleanup(exception):
            cleanup_stuff.append(exception)
    
        @app.route("/")
        def index():
            raise Exception("dummy")
    
        @app.errorhandler(Exception)
        def handler(f):
            return flask.jsonify(str(f))
    
        with app.app_context():
>           client.get("/")

tests/test_appctx.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce1d50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________ test_app_tearing_down_with_unhandled_exception ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9fc0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735def5b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
>       if app_ctx is None or app_ctx.app is not self.app:
E       AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:347: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_app_tearing_down_with_unhandled_exception(app, client):
        app.config["PROPAGATE_EXCEPTIONS"] = True
        cleanup_stuff = []
    
        @app.teardown_appcontext
        def cleanup(exception):
            cleanup_stuff.append(exception)
    
        @app.route("/")
        def index():
            raise ValueError("dummy")
    
        with pytest.raises(ValueError, match="dummy"):
            with app.app_context():
>               client.get("/")

tests/test_appctx.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735def5b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_context_refcounts ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa3b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565f010>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_context_refcounts(app, client):
        called = []
    
        @app.teardown_request
        def teardown_req(error=None):
            called.append("request")
    
        @app.teardown_appcontext
        def teardown_app(error=None):
            called.append("app")
    
        @app.route("/")
        def index():
            with app_ctx:
                with request_ctx:
                    pass
    
            assert flask.request.environ["werkzeug.request"] is not None
            return ""
    
>       res = client.get("/")

tests/test_appctx.py:187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565f010>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_options_work _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572ff40>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735e35120>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_options_work(app, client):
        @app.route("/", methods=["GET", "POST"])
        def index():
            return "Hello World"
    
>       rv = client.open("/", method="OPTIONS")

tests/test_basic.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735e35120>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_options_on_multiple_rules ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735416170>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735da30d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_options_on_multiple_rules(app, client):
        @app.route("/", methods=["GET", "POST"])
        def index():
            return "Hello World"
    
        @app.route("/", methods=["PUT"])
        def index_put():
            return "Aha!"
    
>       rv = client.open("/", method="OPTIONS")

tests/test_basic.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735da30d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_method_route[get] ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f130>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735608340>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
method = 'get'

    @pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
    def test_method_route(app, client, method):
        method_route = getattr(app, method)
        client_method = getattr(client, method)
    
        @method_route("/")
        def hello():
            return "Hello"
    
>       assert client_method("/").data == b"Hello"

tests/test_basic.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735608340>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_method_route[post] ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f370>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce6b30>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
method = 'post'

    @pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
    def test_method_route(app, client, method):
        method_route = getattr(app, method)
        client_method = getattr(client, method)
    
        @method_route("/")
        def hello():
            return "Hello"
    
>       assert client_method("/").data == b"Hello"

tests/test_basic.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce6b30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_method_route[put] ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f1c0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73581b310>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
method = 'put'

    @pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
    def test_method_route(app, client, method):
        method_route = getattr(app, method)
        client_method = getattr(client, method)
    
        @method_route("/")
        def hello():
            return "Hello"
    
>       assert client_method("/").data == b"Hello"

tests/test_basic.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1172: in put
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73581b310>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_method_route[delete] ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab5b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd5f90>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
method = 'delete'

    @pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
    def test_method_route(app, client, method):
        method_route = getattr(app, method)
        client_method = getattr(client, method)
    
        @method_route("/")
        def hello():
            return "Hello"
    
>       assert client_method("/").data == b"Hello"

tests/test_basic.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1177: in delete
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd5f90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_method_route[patch] ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce736e7e4d0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed6b90>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
method = 'patch'

    @pytest.mark.parametrize("method", ["get", "post", "put", "delete", "patch"])
    def test_method_route(app, client, method):
        method_route = getattr(app, method)
        client_method = getattr(client, method)
    
        @method_route("/")
        def hello():
            return "Hello"
    
>       assert client_method("/").data == b"Hello"

tests/test_basic.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1182: in patch
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed6b90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_provide_automatic_options_attr ______________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9fc0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_provide_automatic_options_attr():
        app = flask.Flask(__name__)
    
        def index():
            return "Hello World!"
    
        index.provide_automatic_options = False
        app.route("/")(index)
>       rv = app.test_client().open("/", method="OPTIONS")

tests/test_basic.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dedb70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_provide_automatic_options_kwarg _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab250>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8a950>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_provide_automatic_options_kwarg(app, client):
        def index():
            return flask.request.method
    
        def more():
            return flask.request.method
    
        app.add_url_rule("/", view_func=index, provide_automatic_options=False)
        app.add_url_rule(
            "/more",
            view_func=more,
            methods=["GET", "POST"],
            provide_automatic_options=False,
        )
>       assert client.get("/").data == b"GET"

tests/test_basic.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8a950>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_request_dispatching ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9f30>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735888340>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_request_dispatching(app, client):
        @app.route("/")
        def index():
            return flask.request.method
    
        @app.route("/more", methods=["GET", "POST"])
        def more():
            return flask.request.method
    
>       assert client.get("/").data == b"GET"

tests/test_basic.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735888340>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________________ test_url_mapping _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa4d0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd240>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_url_mapping(app, client):
        random_uuid4 = "7eb41166-9ebf-4d26-b771-ea3f54f8b383"
    
        def index():
            return flask.request.method
    
        def more():
            return flask.request.method
    
        def options():
            return random_uuid4
    
        app.add_url_rule("/", "index", index)
        app.add_url_rule("/more", "more", more, methods=["GET", "POST"])
    
        # Issue 1288: Test that automatic options are not added
        #             when non-uppercase 'options' in methods
        app.add_url_rule("/options", "options", options, methods=["options"])
    
>       assert client.get("/").data == b"GET"

tests/test_basic.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd240>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_werkzeug_routing _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9cf0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7378820e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_werkzeug_routing(app, client):
        from werkzeug.routing import Rule
        from werkzeug.routing import Submount
    
        app.url_map.add(
            Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
        )
    
        def bar():
            return "bar"
    
        def index():
            return "index"
    
        app.view_functions["bar"] = bar
        app.view_functions["index"] = index
    
>       assert client.get("/foo/").data == b"index"

tests/test_basic.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7378820e0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_endpoint_decorator ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa050>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd1db0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_endpoint_decorator(app, client):
        from werkzeug.routing import Rule
        from werkzeug.routing import Submount
    
        app.url_map.add(
            Submount("/foo", [Rule("/bar", endpoint="bar"), Rule("/", endpoint="index")])
        )
    
        @app.endpoint("bar")
        def bar():
            return "bar"
    
        @app.endpoint("index")
        def index():
            return "index"
    
>       assert client.get("/foo/").data == b"index"

tests/test_basic.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd1db0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________________ test_session _________________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '8', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa9e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552ec50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session(app, client):
        @app.route("/set", methods=["POST"])
        def set():
            assert not flask.session.accessed
            assert not flask.session.modified
            flask.session["value"] = flask.request.form["value"]
            assert flask.session.accessed
            assert flask.session.modified
            return "value set"
    
        @app.route("/get")
        def get():
            assert not flask.session.accessed
            assert not flask.session.modified
            v = flask.session.get("value", "None")
            assert flask.session.accessed
            assert not flask.session.modified
            return v
    
>       assert client.post("/set", data={"value": "42"}).data == b"value set"

tests/test_basic.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552ec50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_session_path _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'example.com:8080', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572ff40>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b419c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_path(app, client):
        app.config.update(APPLICATION_ROOT="/foo")
    
        @app.route("/")
        def index():
            flask.session["testing"] = 42
            return "Hello World"
    
>       rv = client.get("/", "http://example.com:8080/foo")

tests/test_basic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b419c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_session_using_application_root ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'example.com:8080', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa170>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b518a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_using_application_root(app, client):
        class PrefixPathMiddleware:
            def __init__(self, app, prefix):
                self.app = app
                self.prefix = prefix
    
            def __call__(self, environ, start_response):
                environ["SCRIPT_NAME"] = self.prefix
                return self.app(environ, start_response)
    
        app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, "/bar")
        app.config.update(APPLICATION_ROOT="/bar")
    
        @app.route("/")
        def index():
            flask.session["testing"] = 42
            return "Hello World"
    
>       rv = client.get("/", "http://example.com:8080/")

tests/test_basic.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
tests/test_basic.py:277: in __call__
    return self.app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b518a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_session_using_session_settings ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'www.example.com:8080', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab490>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcdb40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_using_session_settings(app, client):
        app.config.update(
            SERVER_NAME="www.example.com:8080",
            APPLICATION_ROOT="/test",
            SESSION_COOKIE_DOMAIN=".example.com",
            SESSION_COOKIE_HTTPONLY=False,
            SESSION_COOKIE_SECURE=True,
            SESSION_COOKIE_PARTITIONED=True,
            SESSION_COOKIE_SAMESITE="Lax",
            SESSION_COOKIE_PATH="/",
        )
    
        @app.route("/")
        def index():
            flask.session["testing"] = 42
            return "Hello World"
    
        @app.route("/clear")
        def clear():
            flask.session.pop("testing", None)
            return "Goodbye World"
    
>       rv = client.get("/", "http://www.example.com:8080/test/")

tests/test_basic.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcdb40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_session_using_samesite_attribute _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353a2350>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_using_samesite_attribute(app, client):
        @app.route("/")
        def index():
            flask.session["testing"] = 42
            return "Hello World"
    
        app.config.update(SESSION_COOKIE_SAMESITE="invalid")
    
        with pytest.raises(ValueError):
>           client.get("/")

tests/test_basic.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353a2350>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_missing_session _____________________________

app = <Flask 'flask_test'>

    def test_missing_session(app):
        app.secret_key = None
    
        def expect_exception(f, *args, **kwargs):
            e = pytest.raises(RuntimeError, f, *args, **kwargs)
            assert e.value.args and "session is unavailable" in e.value.args[0]
    
>       with app.test_request_context():

tests/test_basic.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356fe290>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______________________ test_session_secret_key_fallbacks _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f1c0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735653730>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_secret_key_fallbacks(app, client) -> None:
        @app.post("/")
        def set_session() -> str:
            flask.session["a"] = 1
            return ""
    
        @app.get("/")
        def get_session() -> dict[str, t.Any]:
            return dict(flask.session)
    
        # Set session with initial secret key, and two valid expiring keys
        app.secret_key, app.config["SECRET_KEY_FALLBACKS"] = (
            "0 key",
            ["-1 key", "-2 key"],
        )
>       client.post()

tests/test_basic.py:389: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735653730>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_session_expiration ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354abe20>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73536bd60>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_expiration(app, client):
        permanent = True
    
        @app.route("/")
        def index():
            flask.session["test"] = 42
            flask.session.permanent = permanent
            return ""
    
        @app.route("/test")
        def test():
            return str(flask.session.permanent)
    
>       rv = client.get("/")

tests/test_basic.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73536bd60>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_session_stored_last ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa4d0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356bde70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_stored_last(app, client):
        @app.after_request
        def modify_session(response):
            flask.session["foo"] = 42
            return response
    
        @app.route("/")
        def dump_session_contents():
            return repr(flask.session.get("foo"))
    
>       assert client.get("/").data == b"None"

tests/test_basic.py:444: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356bde70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_session_special_types __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f370>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8a440>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_special_types(app, client):
        now = datetime.now(timezone.utc).replace(microsecond=0)
        the_uuid = uuid.uuid4()
    
        @app.route("/")
        def dump_session_contents():
            flask.session["t"] = (1, 2, 3)
            flask.session["b"] = b"\xff"
            flask.session["m"] = Markup("<html>")
            flask.session["u"] = the_uuid
            flask.session["d"] = now
            flask.session["t_tag"] = {" t": "not-a-tuple"}
            flask.session["di_t_tag"] = {" t__": "not-a-tuple"}
            flask.session["di_tag"] = {" di": "not-a-dict"}
            return "", 204
    
        with client:
>           client.get("/")

tests/test_basic.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73572f370>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
_________________________ test_session_cookie_setting __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/bump', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a8430>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd420>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_session_cookie_setting(app):
        is_permanent = True
    
        @app.route("/bump")
        def bump():
            rv = flask.session["foo"] = flask.session.get("foo", 0) + 1
            flask.session.permanent = is_permanent
            return str(rv)
    
        @app.route("/read")
        def read():
            return str(flask.session.get("foo", 0))
    
        def run_test(expect_header):
            with app.test_client() as c:
                assert c.get("/bump").data == b"1"
                assert c.get("/bump").data == b"2"
                assert c.get("/bump").data == b"3"
    
                rv = c.get("/read")
                set_cookie = rv.headers.get("set-cookie")
                assert (set_cookie is not None) == expect_header
                assert rv.data == b"3"
    
        is_permanent = True
        app.config["SESSION_REFRESH_EACH_REQUEST"] = True
>       run_test(expect_header=True)

tests/test_basic.py:505: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_basic.py:494: in run_test
    assert c.get("/bump").data == b"1"
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/bump', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a8430>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
___________________________ test_session_vary_cookie ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/set', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730430>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353804f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_vary_cookie(app, client):
        @app.route("/set")
        def set_session():
            flask.session["test"] = "test"
            return ""
    
        @app.route("/get")
        def get():
            return flask.session.get("test")
    
        @app.route("/getitem")
        def getitem():
            return flask.session["test"]
    
        @app.route("/setdefault")
        def setdefault():
            return flask.session.setdefault("test", "default")
    
        @app.route("/clear")
        def clear():
            flask.session.clear()
            return ""
    
        @app.route("/vary-cookie-header-set")
        def vary_cookie_header_set():
            response = flask.Response()
            response.vary.add("Cookie")
            flask.session["test"] = "test"
            return response
    
        @app.route("/vary-header-set")
        def vary_header_set():
            response = flask.Response()
            response.vary.update(("Accept-Encoding", "Accept-Language"))
            flask.session["test"] = "test"
            return response
    
        @app.route("/no-vary-header")
        def no_vary_header():
            return ""
    
        def expect(path, header_value="Cookie"):
            rv = client.get(path)
    
            if header_value:
                # The 'Vary' key should exist in the headers only once.
                assert len(rv.headers.get_all("Vary")) == 1
                assert rv.headers["Vary"] == header_value
            else:
                assert "Vary" not in rv.headers
    
>       expect("/set")

tests/test_basic.py:571: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_basic.py:562: in expect
    rv = client.get(path)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353804f0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_session_refresh_vary ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/login', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aaef0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce737881ea0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_refresh_vary(app, client):
        @app.get("/login")
        def login():
            flask.session["user_id"] = 1
            flask.session.permanent = True
            return ""
    
        @app.get("/ignored")
        def ignored():
            return ""
    
>       rv = client.get("/login")

tests/test_basic.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce737881ea0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_extended_flashing ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a8430>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7354dd6c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_extended_flashing(app):
        # Be sure app.testing=True below, else tests can fail silently.
        #
        # Specifically, if app.testing is not set to True, the AssertionErrors
        # in the view functions will cause a 500 response to the test client
        # instead of propagating exceptions.
    
        @app.route("/")
        def index():
            flask.flash("Hello World")
            flask.flash("Hello World", "error")
            flask.flash(Markup("<em>Testing</em>"), "warning")
            return ""
    
        @app.route("/test/")
        def test():
            messages = flask.get_flashed_messages()
            assert list(messages) == [
                "Hello World",
                "Hello World",
                Markup("<em>Testing</em>"),
            ]
            return ""
    
        @app.route("/test_with_categories/")
        def test_with_categories():
            messages = flask.get_flashed_messages(with_categories=True)
            assert len(messages) == 3
            assert list(messages) == [
                ("message", "Hello World"),
                ("error", "Hello World"),
                ("warning", Markup("<em>Testing</em>")),
            ]
            return ""
    
        @app.route("/test_filter/")
        def test_filter():
            messages = flask.get_flashed_messages(
                category_filter=["message"], with_categories=True
            )
            assert list(messages) == [("message", "Hello World")]
            return ""
    
        @app.route("/test_filters/")
        def test_filters():
            messages = flask.get_flashed_messages(
                category_filter=["message", "warning"], with_categories=True
            )
            assert list(messages) == [
                ("message", "Hello World"),
                ("warning", Markup("<em>Testing</em>")),
            ]
            return ""
    
        @app.route("/test_filters_without_returning_categories/")
        def test_filters2():
            messages = flask.get_flashed_messages(category_filter=["message", "warning"])
            assert len(messages) == 2
            assert messages[0] == "Hello World"
            assert messages[1] == Markup("<em>Testing</em>")
            return ""
    
        # Create new test client on each test to clean flashed messages.
    
        client = app.test_client()
>       client.get("/")

tests/test_basic.py:672: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7354dd6c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_request_processing ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732440>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355cc820>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_request_processing(app, client):
        evts = []
    
        @app.before_request
        def before_request():
            evts.append("before")
    
        @app.after_request
        def after_request(response):
            response.data += b"|after"
            evts.append("after")
            return response
    
        @app.route("/")
        def index():
            assert "before" in evts
            assert "after" not in evts
            return "request"
    
        assert "after" not in evts
>       rv = client.get("/").data

tests/test_basic.py:708: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355cc820>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_request_preprocessing_early_return ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9cf0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7359032b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_request_preprocessing_early_return(app, client):
        evts = []
    
        @app.before_request
        def before_request1():
            evts.append(1)
    
        @app.before_request
        def before_request2():
            evts.append(2)
            return "hello"
    
        @app.before_request
        def before_request3():
            evts.append(3)
            return "bye"
    
        @app.route("/")
        def index():
            evts.append("index")
            return "damnit"
    
>       rv = client.get("/").data.strip()

tests/test_basic.py:735: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7359032b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_after_request_processing _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab0a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552da50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_after_request_processing(app, client):
        @app.route("/")
        def index():
            @flask.after_this_request
            def foo(response):
                response.headers["X-Foo"] = "a header"
                return response
    
            return "Test"
    
>       resp = client.get("/")

tests/test_basic.py:750: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552da50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_teardown_request_handler _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357317e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735674b80>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_teardown_request_handler(app, client):
        called = []
    
        @app.teardown_request
        def teardown_request(exc):
            called.append(True)
            return "Ignored"
    
        @app.route("/")
        def root():
            return "Response"
    
>       rv = client.get("/")

tests/test_basic.py:767: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735674b80>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_teardown_request_handler_debug_mode ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354abac0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735888310>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_teardown_request_handler_debug_mode(app, client):
        called = []
    
        @app.teardown_request
        def teardown_request(exc):
            called.append(True)
            return "Ignored"
    
        @app.route("/")
        def root():
            return "Response"
    
>       rv = client.get("/")

tests/test_basic.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735888310>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_teardown_request_handler_error ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_teardown_request_handler_error(app, client):
        called = []
        app.testing = False
    
        @app.teardown_request
        def teardown_request1(exc):
            assert type(exc) is ZeroDivisionError
            called.append(True)
            # This raises a new error and blows away sys.exc_info(), so we can
            # test that all teardown_requests get passed the same original
            # exception.
            try:
                raise TypeError()
            except Exception:
                pass
    
        @app.teardown_request
        def teardown_request2(exc):
            assert type(exc) is ZeroDivisionError
            called.append(True)
            # This raises a new error and blows away sys.exc_info(), so we can
            # test that all teardown_requests get passed the same original
            # exception.
            try:
                raise TypeError()
            except Exception:
                pass
    
        @app.route("/")
        def fails():
            raise ZeroDivisionError
    
>       rv = client.get("/")

tests/test_basic.py:823: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735f8e1d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_before_after_request_order ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa050>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b4a560>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_before_after_request_order(app, client):
        called = []
    
        @app.before_request
        def before1():
            called.append(1)
    
        @app.before_request
        def before2():
            called.append(2)
    
        @app.after_request
        def after1(response):
            called.append(4)
            return response
    
        @app.after_request
        def after2(response):
            called.append(3)
            return response
    
        @app.teardown_request
        def finish1(exc):
            called.append(6)
    
        @app.teardown_request
        def finish2(exc):
            called.append(5)
    
        @app.route("/")
        def index():
            return "42"
    
>       rv = client.get("/")

tests/test_basic.py:862: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b4a560>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_error_handling ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab7f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_error_handling(app, client):
        app.testing = False
    
        @app.errorhandler(404)
        def not_found(e):
            return "not found", 404
    
        @app.errorhandler(500)
        def internal_server_error(e):
            return "internal server error", 500
    
        @app.errorhandler(Forbidden)
        def forbidden(e):
            return "forbidden", 403
    
        @app.route("/")
        def index():
            flask.abort(404)
    
        @app.route("/error")
        def error():
            raise ZeroDivisionError
    
        @app.route("/forbidden")
        def error2():
            flask.abort(403)
    
>       rv = client.get("/")

tests/test_basic.py:894: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ca19c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_error_handling_processing ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732e60>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_error_handling_processing(app, client):
        app.testing = False
    
        @app.errorhandler(500)
        def internal_server_error(e):
            return "internal server error", 500
    
        @app.route("/")
        def broken_func():
            raise ZeroDivisionError
    
        @app.after_request
        def after_request(resp):
            resp.mimetype = "text/x-special"
            return resp
    
>       resp = client.get("/")

tests/test_basic.py:921: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357050c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_baseexception_error_handling _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa3b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_baseexception_error_handling(app, client):
        app.testing = False
    
        @app.route("/")
        def broken_func():
            raise KeyboardInterrupt()
    
        with pytest.raises(KeyboardInterrupt):
>           client.get("/")

tests/test_basic.py:934: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b52950>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_before_request_and_routing_errors ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa830>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552e080>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_before_request_and_routing_errors(app, client):
        @app.before_request
        def attach_something():
            flask.g.something = "value"
    
        @app.errorhandler(404)
        def return_something(error):
            return flask.g.something, 404
    
>       rv = client.get("/")

tests/test_basic.py:946: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73552e080>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_user_error_handling ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa680>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd690>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_user_error_handling(app, client):
        class MyException(Exception):
            pass
    
        @app.errorhandler(MyException)
        def handle_my_exception(e):
            assert isinstance(e, MyException)
            return "42"
    
        @app.route("/")
        def index():
            raise MyException()
    
>       assert client.get("/").data == b"42"

tests/test_basic.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735fcd690>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_http_error_subclass_handling _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/1', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab490>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce2a70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_http_error_subclass_handling(app, client):
        class ForbiddenSubclass(Forbidden):
            pass
    
        @app.errorhandler(ForbiddenSubclass)
        def handle_forbidden_subclass(e):
            assert isinstance(e, ForbiddenSubclass)
            return "banana"
    
        @app.errorhandler(403)
        def handle_403(e):
            assert not isinstance(e, ForbiddenSubclass)
            assert isinstance(e, Forbidden)
            return "apple"
    
        @app.route("/1")
        def index1():
            raise ForbiddenSubclass()
    
        @app.route("/2")
        def index2():
            flask.abort(403)
    
        @app.route("/3")
        def index3():
            raise Forbidden()
    
>       assert client.get("/1").data == b"banana"

tests/test_basic.py:994: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce2a70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_errorhandler_precedence _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/E1', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354abac0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73536b130>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_errorhandler_precedence(app, client):
        class E1(Exception):
            pass
    
        class E2(Exception):
            pass
    
        class E3(E1, E2):
            pass
    
        @app.errorhandler(E2)
        def handle_e2(e):
            return "E2"
    
        @app.errorhandler(Exception)
        def handle_exception(e):
            return "Exception"
    
        @app.route("/E1")
        def raise_e1():
            raise E1
    
        @app.route("/E3")
        def raise_e3():
            raise E3
    
>       rv = client.get("/E1")

tests/test_basic.py:1025: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73536b130>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________ test_trap_bad_request_key_error[False-None-True-True] _____________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/key', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9f30>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c858a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
debug = False, trap = None, expect_key = True, expect_abort = True

    @pytest.mark.parametrize(
        ("debug", "trap", "expect_key", "expect_abort"),
        [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
    )
    def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
        app.config["DEBUG"] = debug
        app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
    
        @app.route("/key")
        def fail():
            flask.request.form["missing_key"]
    
        @app.route("/abort")
        def allow_abort():
            flask.abort(400)
    
        if expect_key:
>           rv = client.get("/key")

tests/test_basic.py:1049: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c858a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________ test_trap_bad_request_key_error[True-None-False-True] _____________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/key', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733640>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735581b40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
debug = True, trap = None, expect_key = False, expect_abort = True

    @pytest.mark.parametrize(
        ("debug", "trap", "expect_key", "expect_abort"),
        [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
    )
    def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
        app.config["DEBUG"] = debug
        app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
    
        @app.route("/key")
        def fail():
            flask.request.form["missing_key"]
    
        @app.route("/abort")
        def allow_abort():
            flask.abort(400)
    
        if expect_key:
            rv = client.get("/key")
            assert rv.status_code == 400
            assert b"missing_key" not in rv.data
        else:
            with pytest.raises(KeyError) as exc_info:
>               client.get("/key")

tests/test_basic.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735581b40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________ test_trap_bad_request_key_error[False-True-False-False] ____________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/key', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a9ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d341c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
debug = False, trap = True, expect_key = False, expect_abort = False

    @pytest.mark.parametrize(
        ("debug", "trap", "expect_key", "expect_abort"),
        [(False, None, True, True), (True, None, False, True), (False, True, False, False)],
    )
    def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):
        app.config["DEBUG"] = debug
        app.config["TRAP_BAD_REQUEST_ERRORS"] = trap
    
        @app.route("/key")
        def fail():
            flask.request.form["missing_key"]
    
        @app.route("/abort")
        def allow_abort():
            flask.abort(400)
    
        if expect_key:
            rv = client.get("/key")
            assert rv.status_code == 400
            assert b"missing_key" not in rv.data
        else:
            with pytest.raises(KeyError) as exc_info:
>               client.get("/key")

tests/test_basic.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d341c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_trapping_of_all_http_exceptions _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/fail', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354aa3b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6f790>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_trapping_of_all_http_exceptions(app, client):
        app.config["TRAP_HTTP_EXCEPTIONS"] = True
    
        @app.route("/fail")
        def fail():
            flask.abort(404)
    
        with pytest.raises(NotFound):
>           client.get("/fail")

tests/test_basic.py:1075: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6f790>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_error_handler_after_processor_error ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354ab0a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_error_handler_after_processor_error(app, client):
        app.testing = False
    
        @app.before_request
        def before_request():
            if _trigger == "before":
                raise ZeroDivisionError
    
        @app.after_request
        def after_request(response):
            if _trigger == "after":
                raise ZeroDivisionError
    
            return response
    
        @app.route("/")
        def index():
            return "Foo"
    
        @app.errorhandler(500)
        def internal_server_error(e):
            return "Hello Server Error", 500
    
        for _trigger in "before", "after":
>           rv = client.get("/")

tests/test_basic.py:1102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735652a10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_enctype_debug_helper ___________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '13', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354abe20>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8e470>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_enctype_debug_helper(app, client):
        from flask.debughelpers import DebugFilesKeyError
    
        app.debug = True
    
        @app.route("/fail", methods=["POST"])
        def index():
            return flask.request.files["foo"].filename
    
        with pytest.raises(DebugFilesKeyError) as e:
>           client.post("/fail", data={"foo": "index.txt"})

tests/test_basic.py:1117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8e470>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_response_types ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/text', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730dc0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48760>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_response_types(app, client):
        @app.route("/text")
        def from_text():
            return "Hllo Wrld"
    
        @app.route("/bytes")
        def from_bytes():
            return "Hllo Wrld".encode()
    
        @app.route("/full_tuple")
        def from_full_tuple():
            return (
                "Meh",
                400,
                {"X-Foo": "Testing", "Content-Type": "text/plain; charset=utf-8"},
            )
    
        @app.route("/text_headers")
        def from_text_headers():
            return "Hello", {"X-Foo": "Test", "Content-Type": "text/plain; charset=utf-8"}
    
        @app.route("/text_status")
        def from_text_status():
            return "Hi, status!", 400
    
        @app.route("/response_headers")
        def from_response_headers():
            return (
                flask.Response(
                    "Hello world", 404, {"Content-Type": "text/html", "X-Foo": "Baz"}
                ),
                {"Content-Type": "text/plain", "X-Foo": "Bar", "X-Bar": "Foo"},
            )
    
        @app.route("/response_status")
        def from_response_status():
            return app.response_class("Hello world", 400), 500
    
        @app.route("/wsgi")
        def from_wsgi():
            return NotFound()
    
        @app.route("/dict")
        def from_dict():
            return {"foo": "bar"}, 201
    
        @app.route("/list")
        def from_list():
            return ["foo", "bar"], 201
    
>       assert client.get("/text").data == "Hllo Wrld".encode()

tests/test_basic.py:1172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48760>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_response_type_errors ___________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/none', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732440>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356142b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

    def test_response_type_errors():
        app = flask.Flask(__name__)
        app.testing = True
    
        @app.route("/none")
        def from_none():
            pass
    
        @app.route("/small_tuple")
        def from_small_tuple():
            return ("Hello",)
    
        @app.route("/large_tuple")
        def from_large_tuple():
            return "Hello", 234, {"X-Foo": "Bar"}, "???"
    
        @app.route("/bad_type")
        def from_bad_type():
            return True
    
        @app.route("/bad_wsgi")
        def from_bad_wsgi():
            return lambda: None
    
        c = app.test_client()
    
        with pytest.raises(TypeError) as e:
>           c.get("/none")

tests/test_basic.py:1243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356142b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_build_error_handler ___________________________

app = <Flask 'flask_test'>

    def test_build_error_handler(app):
        # Test base case, a URL which results in a BuildError.
>       with app.test_request_context():

tests/test_basic.py:1353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355cc4f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________________ test_build_error_handler_reraise _______________________

app = <Flask 'flask_test'>

    def test_build_error_handler_reraise(app):
        # Test a custom handler which reraises the BuildError
        def handler_raises_build_error(error, endpoint, values):
            raise error
    
        app.url_build_error_handlers.append(handler_raises_build_error)
    
>       with app.test_request_context():

tests/test_basic.py:1384: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735bff490>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
__________ test_url_for_passes_special_values_to_build_error_handler ___________

app = <Flask 'flask_test'>

    def test_url_for_passes_special_values_to_build_error_handler(app):
        @app.url_build_error_handlers.append
        def handler(error, endpoint, values):
            assert values == {
                "_external": False,
                "_anchor": None,
                "_method": None,
                "_scheme": None,
            }
            return "handled"
    
>       with app.test_request_context():

tests/test_basic.py:1399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b52740>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______________________________ test_static_files _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/static/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357301f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735394490>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_static_files(app, client):
>       rv = client.get("/static/index.html")

tests/test_basic.py:1404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735394490>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_static_url_path _____________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730ee0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735901c00>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

    def test_static_url_path():
        app = flask.Flask(__name__, static_url_path="/foo")
        app.testing = True
>       rv = app.test_client().get("/foo/index.html")

tests/test_basic.py:1415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735901c00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_static_url_path_with_ending_slash ____________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732f80>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735658d00>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

    def test_static_url_path_with_ending_slash():
        app = flask.Flask(__name__, static_url_path="/foo/")
        app.testing = True
>       rv = app.test_client().get("/foo/index.html")

tests/test_basic.py:1426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735658d00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_static_url_empty_path __________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/static/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732b90>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'test_basic'>

    def test_static_url_empty_path(app):
        app = flask.Flask(__name__, static_folder="", static_url_path="")
>       rv = app.test_client().open("/static/index.html", method="GET")

tests/test_basic.py:1436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b59960>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_static_url_empty_path_default ______________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/static/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357323b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'test_basic'>

    def test_static_url_empty_path_default(app):
        app = flask.Flask(__name__, static_folder="")
>       rv = app.test_client().open("/static/index.html", method="GET")

tests/test_basic.py:1443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735586710>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_static_folder_with_pathlib_path _____________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/static/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357328c0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'test_basic'>

    def test_static_folder_with_pathlib_path(app):
        from pathlib import Path
    
        app = flask.Flask(__name__, static_folder=Path("static"))
>       rv = app.test_client().open("/static/index.html", method="GET")

tests/test_basic.py:1452: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d5c30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_static_folder_with_ending_slash _____________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/catch/all', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732c20>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_static_folder_with_ending_slash():
        app = flask.Flask(__name__, static_folder="static/")
    
        @app.route("/<path:path>")
        def catch_all(path):
            return path
    
>       rv = app.test_client().get("/catch/all")

tests/test_basic.py:1464: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed10c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_static_route_with_host_matching _____________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'example.com', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/static/index.html', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357339a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_static_route_with_host_matching():
        app = flask.Flask(__name__, host_matching=True, static_host="example.com")
        c = app.test_client()
>       rv = c.get("http://example.com/static/index.html")

tests/test_basic.py:1471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356726b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________ test_server_name_matching[False-False-default-default-default] ________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732dd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

subdomain_matching = False, host_matching = False, expect_base = 'default'
expect_abc = 'default', expect_xyz = 'default'

    @pytest.mark.parametrize(
        ("subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"),
        [
            (False, False, "default", "default", "default"),
            (True, False, "default", "abc", "<invalid>"),
            (False, True, "default", "abc", "default"),
        ],
    )
    def test_server_name_matching(
        subdomain_matching: bool,
        host_matching: bool,
        expect_base: str,
        expect_abc: str,
        expect_xyz: str,
    ) -> None:
        app = flask.Flask(
            __name__,
            subdomain_matching=subdomain_matching,
            host_matching=host_matching,
            static_host="example.test" if host_matching else None,
        )
        app.config["SERVER_NAME"] = "example.test"
    
        @app.route("/", defaults={"name": "default"}, host="<name>")
        @app.route("/", subdomain="<name>", host="<name>.example.test")
        def index(name: str) -> str:
            return name
    
        client = app.test_client()
    
>       r = client.get(base_url="http://example.test")

tests/test_basic.py:1524: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce0070>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________ test_server_name_matching[True-False-default-abc-<invalid>] __________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735731090>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

subdomain_matching = True, host_matching = False, expect_base = 'default'
expect_abc = 'abc', expect_xyz = '<invalid>'

    @pytest.mark.parametrize(
        ("subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"),
        [
            (False, False, "default", "default", "default"),
            (True, False, "default", "abc", "<invalid>"),
            (False, True, "default", "abc", "default"),
        ],
    )
    def test_server_name_matching(
        subdomain_matching: bool,
        host_matching: bool,
        expect_base: str,
        expect_abc: str,
        expect_xyz: str,
    ) -> None:
        app = flask.Flask(
            __name__,
            subdomain_matching=subdomain_matching,
            host_matching=host_matching,
            static_host="example.test" if host_matching else None,
        )
        app.config["SERVER_NAME"] = "example.test"
    
        @app.route("/", defaults={"name": "default"}, host="<name>")
        @app.route("/", subdomain="<name>", host="<name>.example.test")
        def index(name: str) -> str:
            return name
    
        client = app.test_client()
    
>       r = client.get(base_url="http://example.test")

tests/test_basic.py:1524: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b44a30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________ test_server_name_matching[False-True-default-abc-default] ___________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357303a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

subdomain_matching = False, host_matching = True, expect_base = 'default'
expect_abc = 'abc', expect_xyz = 'default'

    @pytest.mark.parametrize(
        ("subdomain_matching", "host_matching", "expect_base", "expect_abc", "expect_xyz"),
        [
            (False, False, "default", "default", "default"),
            (True, False, "default", "abc", "<invalid>"),
            (False, True, "default", "abc", "default"),
        ],
    )
    def test_server_name_matching(
        subdomain_matching: bool,
        host_matching: bool,
        expect_base: str,
        expect_abc: str,
        expect_xyz: str,
    ) -> None:
        app = flask.Flask(
            __name__,
            subdomain_matching=subdomain_matching,
            host_matching=host_matching,
            static_host="example.test" if host_matching else None,
        )
        app.config["SERVER_NAME"] = "example.test"
    
        @app.route("/", defaults={"name": "default"}, host="<name>")
        @app.route("/", subdomain="<name>", host="<name>.example.test")
        def index(name: str) -> str:
            return name
    
        client = app.test_client()
    
>       r = client.get(base_url="http://example.test")

tests/test_basic.py:1524: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355f3a90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_server_name_subdomain __________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'dev.local:5000', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357328c0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_server_name_subdomain():
        app = flask.Flask(__name__, subdomain_matching=True)
        client = app.test_client()
    
        @app.route("/")
        def index():
            return "default"
    
        @app.route("/", subdomain="foo")
        def subdomain():
            return "subdomain"
    
        app.config["SERVER_NAME"] = "dev.local:5000"
>       rv = client.get("/")

tests/test_basic.py:1549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8bd00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_exception_propagation[TESTING] ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730ca0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735610df0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
key = 'TESTING'

    @pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
    def test_exception_propagation(app, client, key):
        app.testing = False
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        if key is not None:
            app.config[key] = True
    
            with pytest.raises(ZeroDivisionError):
>               client.get("/")

tests/test_basic.py:1593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735610df0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_exception_propagation[PROPAGATE_EXCEPTIONS] _______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730310>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd0370>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
key = 'PROPAGATE_EXCEPTIONS'

    @pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
    def test_exception_propagation(app, client, key):
        app.testing = False
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        if key is not None:
            app.config[key] = True
    
            with pytest.raises(ZeroDivisionError):
>               client.get("/")

tests/test_basic.py:1593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd0370>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_exception_propagation[DEBUG] _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732200>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9fdf0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
key = 'DEBUG'

    @pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
    def test_exception_propagation(app, client, key):
        app.testing = False
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        if key is not None:
            app.config[key] = True
    
            with pytest.raises(ZeroDivisionError):
>               client.get("/")

tests/test_basic.py:1593: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9fdf0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_exception_propagation[None] _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733b50>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
key = None

    @pytest.mark.parametrize("key", ["TESTING", "PROPAGATE_EXCEPTIONS", "DEBUG", None])
    def test_exception_propagation(app, client, key):
        app.testing = False
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        if key is not None:
            app.config[key] = True
    
            with pytest.raises(ZeroDivisionError):
                client.get("/")
        else:
>           assert client.get("/").status_code == 500

tests/test_basic.py:1595: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565d900>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_url_processors ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/de/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357301f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356fd1b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_url_processors(app, client):
        @app.url_defaults
        def add_language_code(endpoint, values):
            if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(
                endpoint, "lang_code"
            ):
                values.setdefault("lang_code", flask.g.lang_code)
    
        @app.url_value_preprocessor
        def pull_lang_code(endpoint, values):
            flask.g.lang_code = values.pop("lang_code", None)
    
        @app.route("/<lang_code>/")
        def index():
            return flask.url_for("about")
    
        @app.route("/<lang_code>/about")
        def about():
            return flask.url_for("something_else")
    
        @app.route("/foo")
        def something_else():
            return flask.url_for("about", lang_code="en")
    
>       assert client.get("/de/").data == b"/de/about"

tests/test_basic.py:1640: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356fd1b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_inject_blueprint_url_defaults ______________________

app = <Flask 'flask_test'>

    def test_inject_blueprint_url_defaults(app):
        bp = flask.Blueprint("foo", __name__, template_folder="template")
    
        @bp.url_defaults
        def bp_defaults(endpoint, values):
            values["page"] = "login"
    
        @bp.route("/<page>")
        def view(page):
            pass
    
        app.register_blueprint(bp)
    
        values = dict()
        app.inject_url_defaults("foo.view", values)
        expected = dict(page="login")
        assert values == expected
    
>       with app.test_request_context("/somepage"):

tests/test_basic.py:1663: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b41ff0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________________________ test_nonascii_pathinfo ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/\x95\x95\x91\x95\x95\x95\x95\x87\x95\x95\x95\x95\x95', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7354a95a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735e370d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_nonascii_pathinfo(app, client):
        @app.route("/")
        def index():
            return "Hello World!"
    
>       rv = client.get("/")

tests/test_basic.py:1674: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735e370d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_no_setup_after_first_request _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730af0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6ff10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_no_setup_after_first_request(app, client):
        app.debug = True
    
        @app.route("/")
        def index():
            return "Awesome"
    
>       assert client.get("/").data == b"Awesome"

tests/test_basic.py:1685: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6ff10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_routing_redirect_debugging ________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '14', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357329e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd0910>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7ce735dd26b0>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_routing_redirect_debugging(monkeypatch, app, client):
        app.config["DEBUG"] = True
    
        @app.route("/user/", methods=["GET", "POST"])
        def user():
            return flask.request.form["status"]
    
        # default redirect code preserves form data
>       rv = client.post("/user", data={"status": "success"}, follow_redirects=True)

tests/test_basic.py:1701: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd0910>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_route_decorator_custom_endpoint _____________________

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_route_decorator_custom_endpoint(app, client):
        app.debug = True
    
        @app.route("/foo/")
        def foo():
            return flask.request.endpoint
    
        @app.route("/bar/", endpoint="bar")
        def for_bar():
            return flask.request.endpoint
    
        @app.route("/bar/123", endpoint="123")
        def for_bar_foo():
            return flask.request.endpoint
    
>       with app.test_request_context():

tests/test_basic.py:1728: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c718a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_________________________ test_subdomain_basic_support _________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'localhost.localdomain', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733f40>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_subdomain_basic_support():
        app = flask.Flask(__name__, subdomain_matching=True)
        app.config["SERVER_NAME"] = "localhost.localdomain"
        client = app.test_client()
    
        @app.route("/")
        def normal_index():
            return "normal index"
    
        @app.route("/", subdomain="test")
        def test_index():
            return "test index"
    
>       rv = client.get("/", "http://localhost.localdomain/")

tests/test_basic.py:1767: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735634d00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_subdomain_matching ____________________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'mitsuhiko.localhost.localdomain', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733b50>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_subdomain_matching():
        app = flask.Flask(__name__, subdomain_matching=True)
        client = app.test_client()
        app.config["SERVER_NAME"] = "localhost.localdomain"
    
        @app.route("/", subdomain="<user>")
        def index(user):
            return f"index for {user}"
    
>       rv = client.get("/", "http://mitsuhiko.localhost.localdomain/")

tests/test_basic.py:1783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357aea40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_subdomain_matching_with_ports ______________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': 'mitsuhiko.localhost.localdomain:3000', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735731bd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_subdomain_matching_with_ports():
        app = flask.Flask(__name__, subdomain_matching=True)
        app.config["SERVER_NAME"] = "localhost.localdomain:3000"
        client = app.test_client()
    
        @app.route("/", subdomain="<user>")
        def index(user):
            return f"index for {user}"
    
>       rv = client.get("/", "http://mitsuhiko.localhost.localdomain:3000/")

tests/test_basic.py:1796: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73567b220>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________ test_subdomain_matching_other_name[False] ___________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': '127.0.0.1:3000', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732830>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

matching = False

    @pytest.mark.parametrize("matching", (False, True))
    def test_subdomain_matching_other_name(matching):
        app = flask.Flask(__name__, subdomain_matching=matching)
        app.config["SERVER_NAME"] = "localhost.localdomain:3000"
        client = app.test_client()
    
        @app.route("/")
        def index():
            return "", 204
    
        # suppress Werkzeug 0.15 warning about name mismatch
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore", "Current server name", UserWarning, "flask.app"
            )
            # ip address can't match name
>           rv = client.get("/", "http://127.0.0.1:3000/")

tests/test_basic.py:1816: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356756c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_subdomain_matching_other_name[True] ___________________

self = <Flask 'test_basic'>
environ = {'HTTP_HOST': '127.0.0.1:3000', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732b00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

matching = True

    @pytest.mark.parametrize("matching", (False, True))
    def test_subdomain_matching_other_name(matching):
        app = flask.Flask(__name__, subdomain_matching=matching)
        app.config["SERVER_NAME"] = "localhost.localdomain:3000"
        client = app.test_client()
    
        @app.route("/")
        def index():
            return "", 204
    
        # suppress Werkzeug 0.15 warning about name mismatch
        with warnings.catch_warnings():
            warnings.filterwarnings(
                "ignore", "Current server name", UserWarning, "flask.app"
            )
            # ip address can't match name
>           rv = client.get("/", "http://127.0.0.1:3000/")

tests/test_basic.py:1816: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73578f430>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_multi_route_rules ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732200>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b46080>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_multi_route_rules(app, client):
        @app.route("/")
        @app.route("/<test>/")
        def index(test="a"):
            return test
    
>       rv = client.open("/")

tests/test_basic.py:1830: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b46080>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_multi_route_class_views _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735731360>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561ca60>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_multi_route_class_views(app, client):
        class View:
            def __init__(self, app):
                app.add_url_rule("/", "index", self.index)
                app.add_url_rule("/<test>/", "index", self.index)
    
            def index(self, test="a"):
                return test
    
        _ = View(app)
>       rv = client.open("/")

tests/test_basic.py:1846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561ca60>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_max_cookie_size _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733910>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8ec80>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
recwarn = WarningsRecorder(record=True)

    def test_max_cookie_size(app, client, recwarn):
        app.config["MAX_COOKIE_SIZE"] = 100
    
        # outside app context, default to Werkzeug static value,
        # which is also the default config
        response = flask.Response()
        default = flask.Flask.default_config["MAX_COOKIE_SIZE"]
        assert response.max_cookie_size == default
    
        # inside app context, use app config
        with app.app_context():
            assert flask.Response().max_cookie_size == 100
    
        @app.route("/")
        def index():
            r = flask.Response("", status=204)
            r.set_cookie("foo", "bar" * 100)
            return r
    
>       client.get("/")

tests/test_basic.py:1920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8ec80>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_blueprint_specific_error_handling ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/frontend-no', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732170>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b628c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_specific_error_handling(app, client):
        frontend = flask.Blueprint("frontend", __name__)
        backend = flask.Blueprint("backend", __name__)
        sideend = flask.Blueprint("sideend", __name__)
    
        @frontend.errorhandler(403)
        def frontend_forbidden(e):
            return "frontend says no", 403
    
        @frontend.route("/frontend-no")
        def frontend_no():
            flask.abort(403)
    
        @backend.errorhandler(403)
        def backend_forbidden(e):
            return "backend says no", 403
    
        @backend.route("/backend-no")
        def backend_no():
            flask.abort(403)
    
        @sideend.route("/what-is-a-sideend")
        def sideend_no():
            flask.abort(403)
    
        app.register_blueprint(frontend)
        app.register_blueprint(backend)
        app.register_blueprint(sideend)
    
        @app.errorhandler(403)
        def app_forbidden(e):
            return "application itself says no", 403
    
>       assert client.get("/frontend-no").data == b"frontend says no"

tests/test_blueprints.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b628c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________ test_blueprint_specific_user_error_handling __________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/decorator', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733910>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356ceaa0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_specific_user_error_handling(app, client):
        class MyDecoratorException(Exception):
            pass
    
        class MyFunctionException(Exception):
            pass
    
        blue = flask.Blueprint("blue", __name__)
    
        @blue.errorhandler(MyDecoratorException)
        def my_decorator_exception_handler(e):
            assert isinstance(e, MyDecoratorException)
            return "boom"
    
        def my_function_exception_handler(e):
            assert isinstance(e, MyFunctionException)
            return "bam"
    
        blue.register_error_handler(MyFunctionException, my_function_exception_handler)
    
        @blue.route("/decorator")
        def blue_deco_test():
            raise MyDecoratorException()
    
        @blue.route("/function")
        def blue_func_test():
            raise MyFunctionException()
    
        app.register_blueprint(blue)
    
>       assert client.get("/decorator").data == b"boom"

tests/test_blueprints.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356ceaa0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_blueprint_app_error_handling _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/forbidden', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce200>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73567a440>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_app_error_handling(app, client):
        errors = flask.Blueprint("errors", __name__)
    
        @errors.app_errorhandler(403)
        def forbidden_handler(e):
            return "you shall not pass", 403
    
        @app.route("/forbidden")
        def app_forbidden():
            flask.abort(403)
    
        forbidden_bp = flask.Blueprint("forbidden_bp", __name__)
    
        @forbidden_bp.route("/nope")
        def bp_forbidden():
            flask.abort(403)
    
        app.register_blueprint(errors)
        app.register_blueprint(forbidden_bp)
    
>       assert client.get("/forbidden").data == b"you shall not pass"

tests/test_blueprints.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73567a440>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_blueprint_prefix_slash[-/-/] _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cef80>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561f5b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '', rule = '/', url = '/'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561f5b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_blueprint_prefix_slash[/--/] _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735731090>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580d8d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/', rule = '', url = '/'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580d8d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_blueprint_prefix_slash[/-/-/] ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732830>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b63850>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/', rule = '/', url = '/'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b63850>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_blueprint_prefix_slash[/foo--/foo] ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732170>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735677df0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo', rule = '', url = '/foo'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735677df0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________ test_blueprint_prefix_slash[/foo/--/foo/] ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cdc60>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d68f40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo/', rule = '', url = '/foo/'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d68f40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_blueprint_prefix_slash[-/bar-/bar] ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357309d0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356516c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '', rule = '/bar', url = '/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356516c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_blueprint_prefix_slash[/foo/-/bar-/foo/bar] _______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357305e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73557ca30>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo/', rule = '/bar', url = '/foo/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73557ca30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_blueprint_prefix_slash[/foo/-bar-/foo/bar] ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce050>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cfac0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo/', rule = 'bar', url = '/foo/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cfac0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_blueprint_prefix_slash[/foo-/bar-/foo/bar] ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735730e50>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735608940>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo', rule = '/bar', url = '/foo/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735608940>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________ test_blueprint_prefix_slash[/foo/-//bar-/foo/bar] _______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357339a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565d360>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo/', rule = '//bar', url = '/foo/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565d360>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________ test_blueprint_prefix_slash[/foo//-/bar-/foo/bar] _______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo/bar', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd5a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355f0c10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
prefix = '/foo//', rule = '/bar', url = '/foo/bar'

    @pytest.mark.parametrize(
        ("prefix", "rule", "url"),
        (
            ("", "/", "/"),
            ("/", "", "/"),
            ("/", "/", "/"),
            ("/foo", "", "/foo"),
            ("/foo/", "", "/foo/"),
            ("", "/bar", "/bar"),
            ("/foo/", "/bar", "/foo/bar"),
            ("/foo/", "bar", "/foo/bar"),
            ("/foo", "/bar", "/foo/bar"),
            ("/foo/", "//bar", "/foo/bar"),
            ("/foo//", "/bar", "/foo/bar"),
        ),
    )
    def test_blueprint_prefix_slash(app, client, prefix, rule, url):
        bp = flask.Blueprint("test", __name__, url_prefix=prefix)
    
        @bp.route(rule)
        def index():
            return "", 204
    
        app.register_blueprint(bp)
>       assert client.get(url).status_code == 204

tests/test_blueprints.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355f0c10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_blueprint_url_defaults __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/1/foo', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735732320>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c72f80>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_url_defaults(app, client):
        bp = flask.Blueprint("test", __name__)
    
        @bp.route("/foo", defaults={"baz": 42})
        def foo(bar, baz):
            return f"{bar}/{baz:d}"
    
        @bp.route("/bar")
        def bar(bar):
            return str(bar)
    
        app.register_blueprint(bp, url_prefix="/1", url_defaults={"bar": 23})
        app.register_blueprint(bp, name="test2", url_prefix="/2", url_defaults={"bar": 19})
    
>       assert client.get("/1/foo").data == b"23/42"

tests/test_blueprints.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c72f80>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_blueprint_url_processors _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/de/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cdbd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cc2e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_url_processors(app, client):
        bp = flask.Blueprint("frontend", __name__, url_prefix="/<lang_code>")
    
        @bp.url_defaults
        def add_language_code(endpoint, values):
            values.setdefault("lang_code", flask.g.lang_code)
    
        @bp.url_value_preprocessor
        def pull_lang_code(endpoint, values):
            flask.g.lang_code = values.pop("lang_code")
    
        @bp.route("/")
        def index():
            return flask.url_for(".about")
    
        @bp.route("/about")
        def about():
            return flask.url_for(".index")
    
        app.register_blueprint(bp)
    
>       assert client.get("/de/").data == b"/de/about"

tests/test_blueprints.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cc2e0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_templates_and_static ___________________________

self = <Flask 'blueprintapp'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf520>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355ce9e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_apps = None

    def test_templates_and_static(test_apps):
        from blueprintapp import app
    
        client = app.test_client()
    
>       rv = client.get("/")

tests/test_blueprints.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355ce9e0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_default_static_max_age __________________________

app = <Flask 'flask_test'>

    def test_default_static_max_age(app):
        class MyBlueprint(flask.Blueprint):
            def get_send_file_max_age(self, filename):
                return 100
    
        blueprint = MyBlueprint("blueprint", __name__, static_folder="static")
        app.register_blueprint(blueprint)
    
        # try/finally, in case other tests use this app for Blueprint tests.
        max_age_default = app.config["SEND_FILE_MAX_AGE_DEFAULT"]
        try:
>           with app.test_request_context():

tests/test_blueprints.py:234: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735605450>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
__________________________ test_dotted_names_from_app __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357309d0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73581b1f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_dotted_names_from_app(app, client):
        test = flask.Blueprint("test", __name__)
    
        @app.route("/")
        def app_index():
            return flask.url_for("test.index")
    
        @test.route("/test/")
        def index():
            return flask.url_for("app_index")
    
        app.register_blueprint(test)
    
>       rv = client.get("/")

tests/test_blueprints.py:277: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73581b1f0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_empty_url_defaults ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf880>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73586a0e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_empty_url_defaults(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.route("/", defaults={"page": 1})
        @bp.route("/page/<int:page>")
        def something(page):
            return str(page)
    
        app.register_blueprint(bp)
    
>       assert client.get("/").data == b"1"

tests/test_blueprints.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73586a0e0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_route_decorator_custom_endpoint _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc310>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b61660>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_route_decorator_custom_endpoint(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.route("/foo")
        def foo():
            return flask.request.endpoint
    
        @bp.route("/bar", endpoint="bar")
        def foo_bar():
            return flask.request.endpoint
    
        @bp.route("/bar/123", endpoint="123")
        def foo_bar_foo():
            return flask.request.endpoint
    
        @bp.route("/bar/foo")
        def bar_foo():
            return flask.request.endpoint
    
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.request.endpoint
    
>       assert client.get("/").data == b"index"

tests/test_blueprints.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b61660>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_endpoint_decorator ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/foo', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735733b50>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735583040>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_endpoint_decorator(app, client):
        from werkzeug.routing import Rule
    
        app.url_map.add(Rule("/foo", endpoint="bar"))
    
        bp = flask.Blueprint("bp", __name__)
    
        @bp.endpoint("bar")
        def foobar():
            return flask.request.endpoint
    
        app.register_blueprint(bp, url_prefix="/bp_prefix")
    
>       assert client.get("/foo").data == b"bar"

tests/test_blueprints.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735583040>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_template_filter_with_template ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cfac0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735606b30>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_filter_with_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_filter()
        def super_reverse(s):
            return s[::-1]
    
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_blueprints.py:427: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735606b30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________ test_template_filter_after_route_with_template ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc5e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ca3df0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_filter_after_route_with_template(app, client):
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_filter()
        def super_reverse(s):
            return s[::-1]
    
        app.register_blueprint(bp, url_prefix="/py")
>       rv = client.get("/")

tests/test_blueprints.py:443: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ca3df0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_add_template_filter_with_template ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cfbe0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357bf9a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_filter_with_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        def super_reverse(s):
            return s[::-1]
    
        bp.add_app_template_filter(super_reverse)
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_blueprints.py:460: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357bf9a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________ test_template_filter_with_name_and_template __________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd6c0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580ec50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_filter_with_name_and_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_filter("super_reverse")
        def my_reverse(s):
            return s[::-1]
    
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_blueprints.py:477: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580ec50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_add_template_filter_with_name_and_template ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cdea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735635390>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_filter_with_name_and_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        def my_reverse(s):
            return s[::-1]
    
        bp.add_app_template_filter(my_reverse, "super_reverse")
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_blueprints.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735635390>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_template_test_with_template _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf400>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73562d240>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_test_with_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_test()
        def boolean(value):
            return isinstance(value, bool)
    
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_blueprints.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73562d240>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________ test_template_test_after_route_with_template _________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735731bd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735607010>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_test_after_route_with_template(app, client):
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_test()
        def boolean(value):
            return isinstance(value, bool)
    
        app.register_blueprint(bp, url_prefix="/py")
>       rv = client.get("/")

tests/test_blueprints.py:579: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735607010>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_add_template_test_with_template _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd480>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73583ab30>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_test_with_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        def boolean(value):
            return isinstance(value, bool)
    
        bp.add_app_template_test(boolean)
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_blueprints.py:596: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73583ab30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________ test_template_test_with_name_and_template ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ccd30>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd3670>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_test_with_name_and_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.app_template_test("boolean")
        def is_boolean(value):
            return isinstance(value, bool)
    
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_blueprints.py:613: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735dd3670>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________ test_add_template_test_with_name_and_template _________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc8b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735970550>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_test_with_name_and_template(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        def is_boolean(value):
            return isinstance(value, bool)
    
        bp.add_app_template_test(is_boolean, "boolean")
        app.register_blueprint(bp, url_prefix="/py")
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_blueprints.py:630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735970550>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_context_processing ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cee60>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b47a90>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_context_processing(app, client):
        answer_bp = flask.Blueprint("answer_bp", __name__)
    
        def template_string():
            return flask.render_template_string(
                "{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}"
                "{% if answer %}{{ answer }} is the answer.{% endif %}"
            )
    
        # App global context processor
        @answer_bp.app_context_processor
        def not_answer_context_processor():
            return {"notanswer": 43}
    
        # Blueprint local context processor
        @answer_bp.context_processor
        def answer_context_processor():
            return {"answer": 42}
    
        # Setup endpoints for testing
        @answer_bp.route("/bp")
        def bp_page():
            return template_string()
    
        @app.route("/")
        def app_page():
            return template_string()
    
        # Register the blueprint
        app.register_blueprint(answer_bp)
    
>       app_page_bytes = client.get("/").data

tests/test_blueprints.py:665: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b47a90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_request_processing ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/bp', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce290>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5a200>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_request_processing(app, client):
        bp = flask.Blueprint("bp", __name__)
        evts = []
    
        @bp.before_request
        def before_bp():
            evts.append("before")
    
        @bp.after_request
        def after_bp(response):
            response.data += b"|after"
            evts.append("after")
            return response
    
        @bp.teardown_request
        def teardown_bp(exc):
            evts.append("teardown")
    
        # Setup routes for testing
        @bp.route("/bp")
        def bp_endpoint():
            return "request"
    
        app.register_blueprint(bp)
    
        assert evts == []
>       rv = client.get("/bp")

tests/test_blueprints.py:722: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5a200>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_app_request_processing __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd750>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6fbb0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_app_request_processing(app, client):
        bp = flask.Blueprint("bp", __name__)
        evts = []
    
        @bp.before_app_request
        def before_app():
            evts.append("before")
    
        @bp.after_app_request
        def after_app(response):
            response.data += b"|after"
            evts.append("after")
            return response
    
        @bp.teardown_app_request
        def teardown_app(exc):
            evts.append("teardown")
    
        app.register_blueprint(bp)
    
        # Setup routes for testing
        @app.route("/")
        def bp_endpoint():
            return "request"
    
        # before first request
        assert evts == []
    
        # first request
>       resp = client.get("/").data

tests/test_blueprints.py:756: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6fbb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_app_url_processors ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/de/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf5b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735498f40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_app_url_processors(app, client):
        bp = flask.Blueprint("bp", __name__)
    
        # Register app-wide url defaults and preprocessor on blueprint
        @bp.app_url_defaults
        def add_language_code(endpoint, values):
            values.setdefault("lang_code", flask.g.lang_code)
    
        @bp.app_url_value_preprocessor
        def pull_lang_code(endpoint, values):
            flask.g.lang_code = values.pop("lang_code")
    
        # Register route rules at the app level
        @app.route("/<lang_code>/")
        def index():
            return flask.url_for("about")
    
        @app.route("/<lang_code>/about")
        def about():
            return flask.url_for("index")
    
        app.register_blueprint(bp)
    
>       assert client.get("/de/").data == b"/de/about"

tests/test_blueprints.py:789: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735498f40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_nested_blueprint _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce440>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d1420>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_nested_blueprint(app, client):
        parent = flask.Blueprint("parent", __name__)
        child = flask.Blueprint("child", __name__)
        grandchild = flask.Blueprint("grandchild", __name__)
    
        @parent.errorhandler(403)
        def forbidden(e):
            return "Parent no", 403
    
        @parent.route("/")
        def parent_index():
            return "Parent yes"
    
        @parent.route("/no")
        def parent_no():
            flask.abort(403)
    
        @child.route("/")
        def child_index():
            return "Child yes"
    
        @child.route("/no")
        def child_no():
            flask.abort(403)
    
        @grandchild.errorhandler(403)
        def grandchild_forbidden(e):
            return "Grandchild no", 403
    
        @grandchild.route("/")
        def grandchild_index():
            return "Grandchild yes"
    
        @grandchild.route("/no")
        def grandchild_no():
            flask.abort(403)
    
        child.register_blueprint(grandchild, url_prefix="/grandchild")
        parent.register_blueprint(child, url_prefix="/child")
        app.register_blueprint(parent, url_prefix="/parent")
    
>       assert client.get("/parent/").data == b"Parent yes"

tests/test_blueprints.py:834: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d1420>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_nested_callback_order __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/a', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cfbe0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735678df0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_nested_callback_order(app, client):
        parent = flask.Blueprint("parent", __name__)
        child = flask.Blueprint("child", __name__)
    
        @app.before_request
        def app_before1():
            flask.g.setdefault("seen", []).append("app_1")
    
        @app.teardown_request
        def app_teardown1(e=None):
            assert flask.g.seen.pop() == "app_1"
    
        @app.before_request
        def app_before2():
            flask.g.setdefault("seen", []).append("app_2")
    
        @app.teardown_request
        def app_teardown2(e=None):
            assert flask.g.seen.pop() == "app_2"
    
        @app.context_processor
        def app_ctx():
            return dict(key="app")
    
        @parent.before_request
        def parent_before1():
            flask.g.setdefault("seen", []).append("parent_1")
    
        @parent.teardown_request
        def parent_teardown1(e=None):
            assert flask.g.seen.pop() == "parent_1"
    
        @parent.before_request
        def parent_before2():
            flask.g.setdefault("seen", []).append("parent_2")
    
        @parent.teardown_request
        def parent_teardown2(e=None):
            assert flask.g.seen.pop() == "parent_2"
    
        @parent.context_processor
        def parent_ctx():
            return dict(key="parent")
    
        @child.before_request
        def child_before1():
            flask.g.setdefault("seen", []).append("child_1")
    
        @child.teardown_request
        def child_teardown1(e=None):
            assert flask.g.seen.pop() == "child_1"
    
        @child.before_request
        def child_before2():
            flask.g.setdefault("seen", []).append("child_2")
    
        @child.teardown_request
        def child_teardown2(e=None):
            assert flask.g.seen.pop() == "child_2"
    
        @child.context_processor
        def child_ctx():
            return dict(key="child")
    
        @child.route("/a")
        def a():
            return ", ".join(flask.g.seen)
    
        @child.route("/b")
        def b():
            return flask.render_template_string("{{ key }}")
    
        parent.register_blueprint(child)
        app.register_blueprint(parent)
        assert (
>           client.get("/a").data == b"app_1, app_2, parent_1, parent_2, child_1, child_2"
        )

tests/test_blueprints.py:917: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735678df0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________ test_nesting_url_prefixes[/parent-/child-None-None] ______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent/child/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cce50>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353d1f60>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

parent_init = '/parent', child_init = '/child', parent_registration = None
child_registration = None, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "parent_init, child_init, parent_registration, child_registration",
        [
            ("/parent", "/child", None, None),
            ("/parent", None, None, "/child"),
            (None, None, "/parent", "/child"),
            ("/other", "/something", "/parent", "/child"),
        ],
    )
    def test_nesting_url_prefixes(
        parent_init,
        child_init,
        parent_registration,
        child_registration,
        app,
        client,
    ) -> None:
        parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
        child = flask.Blueprint("child", __name__, url_prefix=child_init)
    
        @child.route("/")
        def index():
            return "index"
    
        parent.register_blueprint(child, url_prefix=child_registration)
        app.register_blueprint(parent, url_prefix=parent_registration)
    
>       response = client.get("/parent/child/")

tests/test_blueprints.py:949: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7353d1f60>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________ test_nesting_url_prefixes[/parent-None-None-/child] ______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent/child/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd000>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd57b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

parent_init = '/parent', child_init = None, parent_registration = None
child_registration = '/child', app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "parent_init, child_init, parent_registration, child_registration",
        [
            ("/parent", "/child", None, None),
            ("/parent", None, None, "/child"),
            (None, None, "/parent", "/child"),
            ("/other", "/something", "/parent", "/child"),
        ],
    )
    def test_nesting_url_prefixes(
        parent_init,
        child_init,
        parent_registration,
        child_registration,
        app,
        client,
    ) -> None:
        parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
        child = flask.Blueprint("child", __name__, url_prefix=child_init)
    
        @child.route("/")
        def index():
            return "index"
    
        parent.register_blueprint(child, url_prefix=child_registration)
        app.register_blueprint(parent, url_prefix=parent_registration)
    
>       response = client.get("/parent/child/")

tests/test_blueprints.py:949: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735cd57b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________ test_nesting_url_prefixes[None-None-/parent-/child] ______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent/child/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd900>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73549a440>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

parent_init = None, child_init = None, parent_registration = '/parent'
child_registration = '/child', app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "parent_init, child_init, parent_registration, child_registration",
        [
            ("/parent", "/child", None, None),
            ("/parent", None, None, "/child"),
            (None, None, "/parent", "/child"),
            ("/other", "/something", "/parent", "/child"),
        ],
    )
    def test_nesting_url_prefixes(
        parent_init,
        child_init,
        parent_registration,
        child_registration,
        app,
        client,
    ) -> None:
        parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
        child = flask.Blueprint("child", __name__, url_prefix=child_init)
    
        @child.route("/")
        def index():
            return "index"
    
        parent.register_blueprint(child, url_prefix=child_registration)
        app.register_blueprint(parent, url_prefix=parent_registration)
    
>       response = client.get("/parent/child/")

tests/test_blueprints.py:949: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73549a440>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________ test_nesting_url_prefixes[/other-/something-/parent-/child] __________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent/child/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cee60>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d2aa0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

parent_init = '/other', child_init = '/something'
parent_registration = '/parent', child_registration = '/child'
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "parent_init, child_init, parent_registration, child_registration",
        [
            ("/parent", "/child", None, None),
            ("/parent", None, None, "/child"),
            (None, None, "/parent", "/child"),
            ("/other", "/something", "/parent", "/child"),
        ],
    )
    def test_nesting_url_prefixes(
        parent_init,
        child_init,
        parent_registration,
        child_registration,
        app,
        client,
    ) -> None:
        parent = flask.Blueprint("parent", __name__, url_prefix=parent_init)
        child = flask.Blueprint("child", __name__, url_prefix=child_init)
    
        @child.route("/")
        def index():
            return "index"
    
        parent.register_blueprint(child, url_prefix=child_registration)
        app.register_blueprint(parent, url_prefix=parent_registration)
    
>       response = client.get("/parent/child/")

tests/test_blueprints.py:949: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d2aa0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_nesting_subdomains ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'api.example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/child/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cfeb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735637400>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_nesting_subdomains(app, client) -> None:
        app.subdomain_matching = True
        app.config["SERVER_NAME"] = "example.test"
        client.allow_subdomain_redirects = True
    
        parent = flask.Blueprint("parent", __name__)
        child = flask.Blueprint("child", __name__)
    
        @child.route("/child/")
        def index():
            return "child"
    
        parent.register_blueprint(child)
        app.register_blueprint(parent, subdomain="api")
    
>       response = client.get("/child/", base_url="http://api.example.test")

tests/test_blueprints.py:968: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735637400>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_child_and_parent_subdomain ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'api.parent.example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc160>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735bdb010>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_child_and_parent_subdomain(app, client) -> None:
        app.subdomain_matching = True
        app.config["SERVER_NAME"] = "example.test"
        client.allow_subdomain_redirects = True
    
        parent = flask.Blueprint("parent", __name__)
        child = flask.Blueprint("child", __name__, subdomain="api")
    
        @child.route("/")
        def index():
            return "child"
    
        parent.register_blueprint(child)
        app.register_blueprint(parent, subdomain="parent")
    
>       response = client.get("/", base_url="http://api.parent.example.test")

tests/test_blueprints.py:987: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735bdb010>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_blueprint_renaming ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/a/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc8b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae3c70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_blueprint_renaming(app, client) -> None:
        bp = flask.Blueprint("bp", __name__)
        bp2 = flask.Blueprint("bp2", __name__)
    
        @bp.get("/")
        def index():
            return flask.request.endpoint
    
        @bp.get("/error")
        def error():
            flask.abort(403)
    
        @bp.errorhandler(403)
        def forbidden(_: Exception):
            return "Error", 403
    
        @bp2.get("/")
        def index2():
            return flask.request.endpoint
    
        bp.register_blueprint(bp2, url_prefix="/a", name="sub")
        app.register_blueprint(bp, url_prefix="/a")
        app.register_blueprint(bp, url_prefix="/b", name="alt")
    
>       assert client.get("/a/").data == b"bp.index"

tests/test_blueprints.py:1041: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae3c70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_custom_converters ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/1,2,3', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cecb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357c0fa0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_custom_converters(app, client):
        class ListConverter(BaseConverter):
            def to_python(self, value):
                return value.split(",")
    
            def to_url(self, value):
                base_to_url = super().to_url
                return ",".join(base_to_url(x) for x in value)
    
        app.url_map.converters["list"] = ListConverter
    
        @app.route("/<list:args>")
        def index(args):
            return "|".join(args)
    
>       assert client.get("/1,2,3").data == b"1|2|3"

tests/test_converters.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357c0fa0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_context_available ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/admin', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3640>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565abf0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_context_available(app, client):
        class ContextConverter(BaseConverter):
            def to_python(self, value):
                assert request is not None
                assert session is not None
                return value
    
        app.url_map.converters["ctx"] = ContextConverter
    
        @app.get("/<ctx:name>")
        def index(name):
            return name
    
>       assert client.get("/admin").data == b"admin"

tests/test_converters.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565abf0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________ TestStreaming.test_streaming_with_context ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': 'name=World', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce320>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c72650>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

self = <test_helpers.TestStreaming object at 0x7ce73539a380>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_streaming_with_context(self, app, client):
        @app.route("/")
        def index():
            def generate():
                yield "Hello "
                yield flask.request.args["name"]
                yield "!"
    
            return flask.Response(flask.stream_with_context(generate()))
    
>       rv = client.get("/?name=World")

tests/test_helpers.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c72650>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________ TestStreaming.test_streaming_with_context_as_decorator ____________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': 'name=World', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cea70>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed6200>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

self = <test_helpers.TestStreaming object at 0x7ce735399840>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_streaming_with_context_as_decorator(self, app, client):
        @app.route("/")
        def index():
            @flask.stream_with_context
            def generate(hello):
                yield hello
                yield flask.request.args["name"]
                yield "!"
    
            return flask.Response(generate("Hello "))
    
>       rv = client.get("/?name=World")

tests/test_helpers.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed6200>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________ TestStreaming.test_streaming_with_context_and_custom_close __________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': 'name=World', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf7f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae0c10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

self = <test_helpers.TestStreaming object at 0x7ce73539bd60>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_streaming_with_context_and_custom_close(self, app, client):
        called = []
    
        class Wrapper:
            def __init__(self, gen):
                self._gen = gen
    
            def __iter__(self):
                return self
    
            def close(self):
                called.append(42)
    
            def __next__(self):
                return next(self._gen)
    
            next = __next__
    
        @app.route("/")
        def index():
            def generate():
                yield "Hello "
                yield flask.request.args["name"]
                yield "!"
    
            return flask.Response(flask.stream_with_context(Wrapper(generate())))
    
>       rv = client.get("/?name=World")

tests/test_helpers.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae0c10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ TestStreaming.test_stream_keeps_session ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735415f30>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357bb9d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

self = <test_helpers.TestStreaming object at 0x7ce73539a890>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_stream_keeps_session(self, app, client):
        @app.route("/")
        def index():
            flask.session["test"] = "flask"
    
            @flask.stream_with_context
            def gen():
                yield flask.session["test"]
    
            return flask.Response(gen())
    
>       rv = client.get("/")

tests/test_helpers.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357bb9d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ TestHelpers.test_make_response ________________________

self = <test_helpers.TestHelpers object at 0x7ce73539aa70>

    def test_make_response(self):
        app = flask.Flask(__name__)
>       with app.test_request_context():

tests/test_helpers.py:327: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6ff40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________________ test_bad_request_debug_message[True] _____________________

self = <Flask 'flask_test'>
environ = {'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/json', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ccee0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568e050>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
debug = True

    @pytest.mark.parametrize("debug", (True, False))
    def test_bad_request_debug_message(app, client, debug):
        app.config["DEBUG"] = debug
        app.config["TRAP_BAD_REQUEST_ERRORS"] = False
    
        @app.route("/json", methods=["POST"])
        def post_json():
            flask.request.get_json()
            return None
    
>       rv = client.post("/json", data=None, content_type="application/json")

tests/test_json.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568e050>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_bad_request_debug_message[False] _____________________

self = <Flask 'flask_test'>
environ = {'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/json', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cdc60>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735585e10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
debug = False

    @pytest.mark.parametrize("debug", (True, False))
    def test_bad_request_debug_message(app, client, debug):
        app.config["DEBUG"] = debug
        app.config["TRAP_BAD_REQUEST_ERRORS"] = False
    
        @app.route("/json", methods=["POST"])
        def post_json():
            flask.request.get_json()
            return None
    
>       rv = client.post("/json", data=None, content_type="application/json")

tests/test_json.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735585e10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_json_bad_requests ____________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '9', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3a30>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48bb0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_bad_requests(app, client):
        @app.route("/json", methods=["POST"])
        def return_json():
            return flask.jsonify(foo=str(flask.request.get_json()))
    
>       rv = client.post("/json", data="malformed", content_type="application/json")

tests/test_json.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48bb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_json_custom_mimetypes __________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '5', 'CONTENT_TYPE': 'application/x+json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735415fc0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73588b7c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_custom_mimetypes(app, client):
        @app.route("/json", methods=["POST"])
        def return_json():
            return flask.request.get_json()
    
>       rv = client.post("/json", data='"foo"', content_type="application/x+json")

tests/test_json.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73588b7c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_jsonify_basic_types[0] __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cd5a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561f880>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 0, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561f880>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_jsonify_basic_types[-1] _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ccee0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9f640>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = -1, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9f640>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_jsonify_basic_types[1] __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3250>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73537add0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 1, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73537add0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_jsonify_basic_types[23] _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cc8b0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5b550>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 23, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5b550>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_jsonify_basic_types[3.14] ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357ce050>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73560b790>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 3.14, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73560b790>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_jsonify_basic_types[s] __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2ef0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9e710>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 's', app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9e710>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_jsonify_basic_types[longer string] ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad39a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d6bc70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = 'longer string', app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735d6bc70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_jsonify_basic_types[True] ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cdab0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d1c90>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = True, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355d1c90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_jsonify_basic_types[False] ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3520>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73572b670>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = False, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73572b670>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_jsonify_basic_types[None] ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/jsonify_basic_types', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3880>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735613760>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_value = None, app = <Flask 'flask_test'>
client = <FlaskClient <Flask 'flask_test'>>

    @pytest.mark.parametrize(
        "test_value", [0, -1, 1, 23, 3.14, "s", "longer string", True, False, None]
    )
    def test_jsonify_basic_types(test_value, app, client):
        url = "/jsonify_basic_types"
        app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))
>       rv = client.get(url)

tests/test_json.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735613760>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_jsonify_dicts ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/kw', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3130>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735379cc0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_jsonify_dicts(app, client):
        d = {
            "a": 0,
            "b": 23,
            "c": 3.14,
            "d": "t",
            "e": "Hi",
            "f": True,
            "g": False,
            "h": ["test list", 10, False],
            "i": {"test": "dict"},
        }
    
        @app.route("/kw")
        def return_kwargs():
            return flask.jsonify(**d)
    
        @app.route("/dict")
        def return_dict():
            return flask.jsonify(d)
    
        for url in "/kw", "/dict":
>           rv = client.get(url)

tests/test_json.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735379cc0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_jsonify_arrays ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/args_unpack', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce7357cf7f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735672f50>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_jsonify_arrays(app, client):
        """Test jsonify of lists and args unpacking."""
        a_list = [
            0,
            42,
            3.14,
            "t",
            "hello",
            True,
            False,
            ["test list", 2, False],
            {"test": "dict"},
        ]
    
        @app.route("/args_unpack")
        def return_args_unpack():
            return flask.jsonify(*a_list)
    
        @app.route("/array")
        def return_array():
            return flask.jsonify(a_list)
    
        for url in "/args_unpack", "/array":
>           rv = client.get(url)

tests/test_json.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735672f50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_jsonify_datetime[value0] _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad0940>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73549bd00>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
value = datetime.datetime(1973, 3, 11, 6, 30, 45)

    @pytest.mark.parametrize(
        "value", [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)]
    )
    def test_jsonify_datetime(app, client, value):
        @app.route("/")
        def index():
            return flask.jsonify(value=value)
    
>       r = client.get()

tests/test_json.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73549bd00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_jsonify_datetime[value1] _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2290>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73588bb20>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
value = datetime.date(1975, 1, 5)

    @pytest.mark.parametrize(
        "value", [datetime.datetime(1973, 3, 11, 6, 30, 45), datetime.date(1975, 1, 5)]
    )
    def test_jsonify_datetime(app, client, value):
        @app.route("/")
        def index():
            return flask.jsonify(value=value)
    
>       r = client.get()

tests/test_json.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73588bb20>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_jsonify_uuid_types ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/uuid_test', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad30a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735903700>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_jsonify_uuid_types(app, client):
        """Test jsonify with uuid.UUID types"""
    
        test_uuid = uuid.UUID(bytes=b"\xde\xad\xbe\xef" * 4)
        url = "/uuid_test"
        app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))
    
>       rv = client.get(url)

tests/test_json.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735903700>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________________ test_json_attr ________________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '16', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2950>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735afa830>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_attr(app, client):
        @app.route("/add", methods=["POST"])
        def add():
            json = flask.request.get_json()
            return str(json["a"] + json["b"])
    
>       rv = client.post(
            "/add",
            data=flask.json.dumps({"a": 1, "b": 2}),
            content_type="application/json",
        )

tests/test_json.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735afa830>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_json_customization ____________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '19', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad1ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce0310>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_customization(app, client):
        class X:  # noqa: B903, for Python2 compatibility
            def __init__(self, val):
                self.val = val
    
        def default(o):
            if isinstance(o, X):
                return f"<{o.val}>"
    
            return DefaultJSONProvider.default(o)
    
        class CustomProvider(DefaultJSONProvider):
            def object_hook(self, obj):
                if len(obj) == 1 and "_foo" in obj:
                    return X(obj["_foo"])
    
                return obj
    
            def loads(self, s, **kwargs):
                kwargs.setdefault("object_hook", self.object_hook)
                return super().loads(s, **kwargs)
    
        app.json = CustomProvider(app)
        app.json.default = default
    
        @app.route("/", methods=["POST"])
        def index():
            return flask.json.dumps(flask.request.get_json()["x"])
    
>       rv = client.post(
            "/",
            data=flask.json.dumps({"x": {"_foo": 42}}),
            content_type="application/json",
        )

tests/test_json.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce0310>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_json_key_sorting _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3640>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ad090>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_key_sorting(app, client):
        app.debug = True
        assert app.json.sort_keys
        d = dict.fromkeys(range(20), "foo")
    
        @app.route("/")
        def index():
            return flask.jsonify(values=d)
    
>       rv = client.get("/")

tests/test_json.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ad090>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_wsgi_errors_stream ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2290>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735609450>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_wsgi_errors_stream(app, client):
        @app.route("/")
        def index():
            app.logger.error("test")
            return ""
    
        stream = StringIO()
>       client.get("/", errors_stream=stream)

tests/test_logging.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735609450>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_log_view_exception ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad0550>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_log_view_exception(app, client):
        @app.route("/")
        def index():
            raise Exception("test")
    
        app.testing = False
        stream = StringIO()
>       rv = client.get("/", errors_stream=stream)

tests/test_logging.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356fcf10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________________ test_aborting _________________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad15a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735868c70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_aborting(app):
        class Foo(Exception):
            whatever = 42
    
        @app.errorhandler(Foo)
        def handle_foo(e):
            return str(e.whatever)
    
        @app.route("/")
        def index():
            raise flask.abort(flask.redirect(flask.url_for("test")))
    
        @app.route("/test")
        def test():
            raise Foo()
    
        with app.test_client() as c:
>           rv = c.get("/")

tests/test_regression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad15a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
_____________________________ test_teardown_on_pop _____________________________

app = <Flask 'flask_test'>

    def test_teardown_on_pop(app):
        buffer = []
    
        @app.teardown_request
        def end_of_request(exception):
            buffer.append(exception)
    
        ctx = app.test_request_context()
>       ctx.push()

tests/test_reqctx.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73557c460>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________________ test_teardown_with_previous_exception _____________________

app = <Flask 'flask_test'>

    def test_teardown_with_previous_exception(app):
        buffer = []
    
        @app.teardown_request
        def end_of_request(exception):
            buffer.append(exception)
    
        try:
            raise Exception("dummy")
        except Exception:
            pass
    
>       with app.test_request_context():

tests/test_reqctx.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c86410>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________________ test_teardown_with_handled_exception _____________________

app = <Flask 'flask_test'>

    def test_teardown_with_handled_exception(app):
        buffer = []
    
        @app.teardown_request
        def end_of_request(exception):
            buffer.append(exception)
    
>       with app.test_request_context():

tests/test_reqctx.py:54: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9dde0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________________ test_proper_test_request_context _______________________

app = <Flask 'flask_test'>

    def test_proper_test_request_context(app):
        app.config.update(SERVER_NAME="localhost.localdomain:5000")
    
        @app.route("/")
        def index():
            return None
    
        @app.route("/", subdomain="foo")
        def sub():
            return None
    
>       with app.test_request_context("/"):

tests/test_reqctx.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ca11e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_____________________________ test_context_binding _____________________________

app = <Flask 'flask_test'>

    def test_context_binding(app):
        @app.route("/")
        def index():
            return f"Hello {flask.request.args['name']}!"
    
        @app.route("/meh")
        def meh():
            return flask.request.url
    
>       with app.test_request_context("/?name=World"):

tests/test_reqctx.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c89630>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
______________________________ test_context_test _______________________________

app = <Flask 'flask_test'>

    def test_context_test(app):
        assert not flask.request
        assert not flask.has_request_context()
        ctx = app.test_request_context()
>       ctx.push()

tests/test_reqctx.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357de590>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_________________________ test_manual_context_binding __________________________

app = <Flask 'flask_test'>

    def test_manual_context_binding(app):
        @app.route("/")
        def index():
            return f"Hello {flask.request.args['name']}!"
    
        ctx = app.test_request_context("/?name=World")
>       ctx.push()

tests/test_reqctx.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c87ee0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________________ test_session_error_pops_context ________________________

self = <CustomFlask 'test_reqctx'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad30a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_session_error_pops_context():
        class SessionError(Exception):
            pass
    
        class FailingSessionInterface(SessionInterface):
            def open_session(self, app, request):
                raise SessionError()
    
        class CustomFlask(flask.Flask):
            session_interface = FailingSessionInterface()
    
        app = CustomFlask(__name__)
    
        @app.route("/")
        def index():
            # shouldn't get here
            AssertionError()
    
>       response = app.test_client().get("/")

tests/test_reqctx.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735bfd8a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_session_dynamic_cookie_name _______________________

self = <CustomFlask 'test_reqctx'>
environ = {'CONTENT_LENGTH': '8', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2320>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_session_dynamic_cookie_name():
        # This session interface will use a cookie with a different name if the
        # requested url ends with the string "dynamic_cookie"
        class PathAwareSessionInterface(SecureCookieSessionInterface):
            def get_cookie_name(self, app):
                if flask.request.url.endswith("dynamic_cookie"):
                    return "dynamic_cookie_name"
                else:
                    return super().get_cookie_name(app)
    
        class CustomFlask(flask.Flask):
            session_interface = PathAwareSessionInterface()
    
        app = CustomFlask(__name__)
        app.secret_key = "secret_key"
    
        @app.route("/set", methods=["POST"])
        def set():
            flask.session["value"] = flask.request.form["value"]
            return "value set"
    
        @app.route("/get")
        def get():
            v = flask.session.get("value", "None")
            return v
    
        @app.route("/set_dynamic_cookie", methods=["POST"])
        def set_dynamic_cookie():
            flask.session["value"] = flask.request.form["value"]
            return "value set"
    
        @app.route("/get_dynamic_cookie")
        def get_dynamic_cookie():
            v = flask.session.get("value", "None")
            return v
    
        test_client = app.test_client()
    
        # first set the cookie in both /set urls but each with a different value
>       assert test_client.post("/set", data={"value": "42"}).data == b"value set"

tests/test_reqctx.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735586ce0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_bad_environ_raises_bad_request ______________________

    def test_bad_environ_raises_bad_request():
        app = flask.Flask(__name__)
    
        from flask.testing import EnvironBuilder
    
        builder = EnvironBuilder(app)
        environ = builder.get_environ()
    
        # use a non-printable character in the Host - this is key to this test
        environ["HTTP_HOST"] = "\x8a"
    
>       with app.request_context(environ):

tests/test_reqctx.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355c6080>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
____________________ test_environ_for_valid_idna_completes _____________________

    def test_environ_for_valid_idna_completes():
        app = flask.Flask(__name__)
    
        @app.route("/")
        def index():
            return "Hello World!"
    
        from flask.testing import EnvironBuilder
    
        builder = EnvironBuilder(app)
        environ = builder.get_environ()
    
        # these characters are all IDNA-compatible
        environ["HTTP_HOST"] = ".com"
    
>       with app.request_context(environ):

tests/test_reqctx.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565a710>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
________________________ test_normal_environ_completes _________________________

self = <Flask 'test_reqctx'>
environ = {'HTTP_HOST': 'xn--on-0ia.com', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3eb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_normal_environ_completes():
        app = flask.Flask(__name__)
    
        @app.route("/")
        def index():
            return "Hello World!"
    
>       response = app.test_client().get("/", headers={"host": "xn--on-0ia.com"})

tests/test_reqctx.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed7e50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_max_content_length ____________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '157', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad1750>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568fbe0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_max_content_length(app: Flask, client: FlaskClient) -> None:
        app.config["MAX_CONTENT_LENGTH"] = 50
    
        @app.post("/")
        def index():
            request.form["myfile"]
            AssertionError()
    
        @app.errorhandler(413)
        def catcher(error):
            return "42"
    
>       rv = client.post("/", data={"myfile": "foo" * 50})

tests/test_request.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568fbe0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_trusted_hosts_config ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'example.test', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2cb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356ccca0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_trusted_hosts_config(app: Flask) -> None:
        app.config["TRUSTED_HOSTS"] = ["example.test", ".other.test"]
    
        @app.get("/")
        def index() -> str:
            return ""
    
        client = app.test_client()
>       r = client.get(base_url="http://example.test")

tests/test_request.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356ccca0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_open_session_with_endpoint ________________________

self = <Flask 'test_session_interface'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2320>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_open_session_with_endpoint():
        """If request.endpoint (or other URL matching behavior) is needed
        while loading the session, RequestContext.match_request() can be
        called manually.
        """
    
        class MySessionInterface(SessionInterface):
            def save_session(self, app, session, response):
                pass
    
            def open_session(self, app, request):
                request_ctx.match_request()
                assert request.endpoint is not None
    
        app = flask.Flask(__name__)
        app.session_interface = MySessionInterface()
    
        @app.get("/")
        def index():
            return "Hello, World!"
    
>       response = app.test_client().get("/")

tests/test_session_interface.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735583880>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_template_rendered ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad13f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73558fbb0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_rendered(app, client):
        @app.route("/")
        def index():
            return flask.render_template("simple_template.html", whiskey=42)
    
        recorded = []
    
        def record(sender, template, context):
            recorded.append((template, context))
    
        flask.template_rendered.connect(record, app)
        try:
>           client.get("/")

tests/test_signals.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73558fbb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_before_render_template __________________________

self = <Flask 'test_signals'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594c280>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_before_render_template():
        app = flask.Flask(__name__)
    
        @app.route("/")
        def index():
            return flask.render_template("simple_template.html", whiskey=42)
    
        recorded = []
    
        def record(sender, template, context):
            context["whiskey"] = 43
            recorded.append((template, context))
    
        flask.before_render_template.connect(record, app)
        try:
>           rv = app.test_client().get("/")

tests/test_signals.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735728eb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_request_signals _____________________________

self = <Flask 'test_signals'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad25f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_request_signals():
        app = flask.Flask(__name__)
        calls = []
    
        def before_request_signal(sender):
            calls.append("before-signal")
    
        def after_request_signal(sender, response):
            assert response.data == b"stuff"
            calls.append("after-signal")
    
        @app.before_request
        def before_request_handler():
            calls.append("before-handler")
    
        @app.after_request
        def after_request_handler(response):
            calls.append("after-handler")
            response.data = "stuff"
            return response
    
        @app.route("/")
        def index():
            calls.append("handler")
            return "ignored anyway"
    
        flask.request_started.connect(before_request_signal, app)
        flask.request_finished.connect(after_request_signal, app)
    
        try:
>           rv = app.test_client().get("/")

tests/test_signals.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b88550>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_request_exception_signal _________________________

self = <Flask 'test_signals'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad15a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_request_exception_signal():
        app = flask.Flask(__name__)
        recorded = []
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        def record(sender, exception):
            recorded.append(exception)
    
        flask.got_request_exception.connect(record, app)
        try:
>           assert app.test_client().get("/").status_code == 500

tests/test_signals.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b44c40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_appcontext_signals ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e560>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561e3b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_appcontext_signals(app, client):
        recorded = []
    
        def record_push(sender, **kwargs):
            recorded.append("push")
    
        def record_pop(sender, **kwargs):
            recorded.append("pop")
    
        @app.route("/")
        def index():
            return "Hello"
    
        flask.appcontext_pushed.connect(record_push, app)
        flask.appcontext_popped.connect(record_pop, app)
        try:
>           rv = client.get("/")

tests/test_signals.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561e3b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_flash_signal _______________________________

app = <Flask 'flask_test'>

    def test_flash_signal(app):
        @app.route("/")
        def index():
            flask.flash("This is a flash message", category="notice")
            return flask.redirect("/other")
    
        recorded = []
    
        def record(sender, message, category):
            recorded.append((message, category))
    
        flask.message_flashed.connect(record, app)
        try:
            client = app.test_client()
>           with client.session_transaction():

tests/test_signals.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FlaskClient <Flask 'flask_test'>>, args = (), kwargs = {}
app = <Flask 'flask_test'>
ctx = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735971000>

    @contextmanager
    def session_transaction(
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Iterator[SessionMixin]:
        """When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.
    
        ::
    
            with client.session_transaction() as session:
                session['value'] = 42
    
        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """
        if self._cookies is None:
            raise TypeError(
                "Cookies are disabled. Create a client with 'use_cookies=True'."
            )
    
        app = self.application
        ctx = app.test_request_context(*args, **kwargs)
>       self._add_cookies_to_wsgi(ctx.request.environ)
E       AttributeError: 'RequestContext' object has no attribute 'request'

src/flask/testing.py:162: AttributeError
_____________________ test_appcontext_tearing_down_signal ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594c1f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_appcontext_tearing_down_signal(app, client):
        app.testing = False
        recorded = []
    
        def record_teardown(sender, exc):
            recorded.append(exc)
    
        @app.route("/")
        def index():
            raise ZeroDivisionError
    
        flask.appcontext_tearing_down.connect(record_teardown, app)
        try:
>           rv = client.get("/")

tests/test_signals.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356079a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_suppressed_exception_logging _______________________

self = <SuppressedFlask 'test_subclassing'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3250>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:838: in handle_exception
    handler = self._find_error_handler(server_error, request.blueprints)
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_suppressed_exception_logging():
        class SuppressedFlask(flask.Flask):
            def log_exception(self, exc_info):
                pass
    
        out = StringIO()
        app = SuppressedFlask(__name__)
    
        @app.route("/")
        def index():
            raise Exception("test")
    
>       rv = app.test_client().get("/", errors_stream=out)

tests/test_subclassing.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735650670>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_context_processing ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2b00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cf070>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_context_processing(app, client):
        @app.context_processor
        def context_processor():
            return {"injected_value": 42}
    
        @app.route("/")
        def index():
            return flask.render_template("context_template.html", value=23)
    
>       rv = client.get("/")

tests/test_templating.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356cf070>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_original_win _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d5a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6c9d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_original_win(app, client):
        @app.route("/")
        def index():
            return flask.render_template_string("{{ config }}", config=42)
    
>       rv = client.get("/")

tests/test_templating.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b6c9d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_simple_stream ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594de10>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735900c10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_simple_stream(app, client):
        @app.route("/")
        def index():
            return flask.stream_template_string("{{ config }}", config=42)
    
>       rv = client.get("/")

tests/test_templating.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735900c10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_standard_context _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': 'foo=42', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2a70>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356bc4c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_standard_context(app, client):
        @app.route("/")
        def index():
            flask.g.foo = 23
            flask.session["test"] = "aha"
            return flask.render_template_string(
                """
                {{ request.args.foo }}
                {{ g.foo }}
                {{ config.DEBUG }}
                {{ session.test }}
            """
            )
    
>       rv = client.get("/?foo=42")

tests/test_templating.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7356bc4c0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________________ test_escaping _________________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad1ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735651480>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_escaping(app, client):
        text = "<p>Hello World!"
    
        @app.route("/")
        def index():
            return flask.render_template(
                "escaping_template.html", text=text, html=Markup(text)
            )
    
>       lines = client.get("/").data.splitlines()

tests/test_templating.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735651480>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________________ test_no_escaping _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d480>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5afb0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_no_escaping(app, client):
        text = "<p>Hello World!"
    
        @app.route("/")
        def index():
            return flask.render_template(
                "non_escaping_template.txt", text=text, html=Markup(text)
            )
    
>       lines = client.get("/").data.splitlines()

tests/test_templating.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b5afb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________ test_template_filter_with_template ______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d240>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73578ed10>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_filter_with_template(app, client):
        @app.template_filter()
        def super_reverse(s):
            return s[::-1]
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_templating.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73578ed10>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________ test_add_template_filter_with_template ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2cb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735653850>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_filter_with_template(app, client):
        def super_reverse(s):
            return s[::-1]
    
        app.add_template_filter(super_reverse)
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_templating.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735653850>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________ test_template_filter_with_name_and_template __________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2b00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48fa0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_filter_with_name_and_template(app, client):
        @app.template_filter("super_reverse")
        def my_reverse(s):
            return s[::-1]
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_templating.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b48fa0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________ test_add_template_filter_with_name_and_template ________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594f0a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae0940>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_filter_with_name_and_template(app, client):
        def my_reverse(s):
            return s[::-1]
    
        app.add_template_filter(my_reverse, "super_reverse")
    
        @app.route("/")
        def index():
            return flask.render_template("template_filter.html", value="abcd")
    
>       rv = client.get("/")

tests/test_templating.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ae0940>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_template_test_with_template _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594ec20>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735707d00>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_test_with_template(app, client):
        @app.template_test()
        def boolean(value):
            return isinstance(value, bool)
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_templating.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735707d00>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________ test_add_template_test_with_template _____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad3910>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ac6a0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_test_with_template(app, client):
        def boolean(value):
            return isinstance(value, bool)
    
        app.add_template_test(boolean)
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_templating.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ac6a0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________ test_template_test_with_name_and_template ___________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d900>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568c490>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_template_test_with_name_and_template(app, client):
        @app.template_test("boolean")
        def is_boolean(value):
            return isinstance(value, bool)
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_templating.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568c490>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________ test_add_template_test_with_name_and_template _________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d7e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565e650>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_add_template_test_with_name_and_template(app, client):
        def is_boolean(value):
            return isinstance(value, bool)
    
        app.add_template_test(is_boolean, "boolean")
    
        @app.route("/")
        def index():
            return flask.render_template("template_test.html", value=False)
    
>       rv = client.get("/")

tests/test_templating.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73565e650>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_custom_template_loader __________________________

self = <MyFlask 'test_templating'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e170>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'flask_test'>>

    def test_custom_template_loader(client):
        class MyFlask(flask.Flask):
            def create_global_jinja_loader(self):
                from jinja2 import DictLoader
    
                return DictLoader({"index.html": "Hello Custom World!"})
    
        app = MyFlask(__name__)
    
        @app.route("/")
        def index():
            return flask.render_template("index.html")
    
        c = app.test_client()
>       rv = c.get("/")

tests/test_templating.py:338: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561da50>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_iterable_loader _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2560>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8f280>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_iterable_loader(app, client):
        @app.context_processor
        def context_processor():
            return {"whiskey": "Jameson"}
    
        @app.route("/")
        def index():
            return flask.render_template(
                [
                    "no_template.xml",  # should skip this one
                    "simple_template.html",  # should render this
                    "context_template.html",
                ],
                value=23,
            )
    
>       rv = client.get("/")

tests/test_templating.py:358: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c8f280>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_template_loader_debugging ________________________

self = <Flask 'blueprintapp'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/missing', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594f7f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735729750>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

test_apps = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7ce73572a350>

    def test_template_loader_debugging(test_apps, monkeypatch):
        from blueprintapp import app
    
        called = []
    
        class _TestHandler(logging.Handler):
            def handle(self, record):
                called.append(True)
                text = str(record.msg)
                assert "1: trying loader of application 'blueprintapp'" in text
                assert (
                    "2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)"
                ) in text
                assert (
                    "trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)"
                ) in text
                assert "Error: the template could not be found" in text
                assert (
                    "looked up from an endpoint that belongs to the blueprint 'frontend'"
                ) in text
                assert "See https://flask.palletsprojects.com/blueprints/#templates" in text
    
        with app.test_client() as c:
            monkeypatch.setitem(app.config, "EXPLAIN_TEMPLATE_LOADING", True)
            monkeypatch.setattr(
                logging.getLogger("blueprintapp"), "handlers", [_TestHandler()]
            )
    
            with pytest.raises(TemplateNotFound) as excinfo:
>               c.get("/missing")

tests/test_templating.py:436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'blueprintapp'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/missing', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594f7f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
______________________ test_environ_defaults_from_config _______________________

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_environ_defaults_from_config(app, client):
        app.config["SERVER_NAME"] = "example.com:1234"
        app.config["APPLICATION_ROOT"] = "/foo"
    
        @app.route("/")
        def index():
            return flask.request.url
    
        ctx = app.test_request_context()
>       assert ctx.request.url == "http://example.com:1234/foo/"
E       AttributeError: 'RequestContext' object has no attribute 'request'

tests/test_testing.py:24: AttributeError
__________________________ test_environ_base_default ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594cee0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735617a60>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_environ_base_default(app, client):
        @app.route("/")
        def index():
            flask.g.remote_addr = flask.request.remote_addr
            flask.g.user_agent = flask.request.user_agent.string
            return ""
    
        with client:
>           client.get("/")

tests/test_testing.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594cee0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
__________________________ test_environ_base_modified __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Foo', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad1ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355e41c0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_environ_base_modified(app, client):
        @app.route("/")
        def index():
            flask.g.remote_addr = flask.request.remote_addr
            flask.g.user_agent = flask.request.user_agent.string
            return ""
    
        client.environ_base["REMOTE_ADDR"] = "192.168.0.22"
        client.environ_base["HTTP_USER_AGENT"] = "Foo"
    
        with client:
>           client.get("/")

tests/test_testing.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Foo', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad1ea0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
___________________________ test_client_open_environ ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/index', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594caf0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580e3b0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
request = <FixtureRequest for <Function test_client_open_environ>>

    def test_client_open_environ(app, client, request):
        @app.route("/index")
        def index():
            return flask.request.remote_addr
    
        builder = EnvironBuilder(app, path="/index", method="GET")
        request.addfinalizer(builder.close)
    
>       rv = client.open(builder)

tests/test_testing.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580e3b0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________________ test_specify_url_scheme ____________________________

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_specify_url_scheme(app, client):
        @app.route("/")
        def index():
            return flask.request.url
    
        ctx = app.test_request_context(url_scheme="https")
>       assert ctx.request.url == "https://localhost/"
E       AttributeError: 'RequestContext' object has no attribute 'request'

tests/test_testing.py:96: AttributeError
________________________ test_blueprint_with_subdomain _________________________

    def test_blueprint_with_subdomain():
        app = flask.Flask(__name__, subdomain_matching=True)
        app.config["SERVER_NAME"] = "example.com:1234"
        app.config["APPLICATION_ROOT"] = "/foo"
        client = app.test_client()
    
        bp = flask.Blueprint("company", __name__, subdomain="xxx")
    
        @bp.route("/")
        def index():
            return flask.request.url
    
        app.register_blueprint(bp)
    
        ctx = app.test_request_context("/", subdomain="xxx")
>       assert ctx.request.url == "http://xxx.example.com:1234/foo/"
E       AttributeError: 'RequestContext' object has no attribute 'request'

tests/test_testing.py:132: AttributeError
__________________________ test_redirect_keep_session __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/getsession', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594fd00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735672410>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
>       if app_ctx is None or app_ctx.app is not self.app:
E       AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:347: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
app_ctx = <flask.ctx.AppContext object at 0x7ce735671840>

    def test_redirect_keep_session(app, client, app_ctx):
        @app.route("/", methods=["GET", "POST"])
        def index():
            if flask.request.method == "POST":
                return flask.redirect("/getsession")
            flask.session["data"] = "foo"
            return "index"
    
        @app.route("/getsession")
        def get_session():
            return flask.session.get("data", "<missing>")
    
        with client:
>           rv = client.get("/getsession")

tests/test_testing.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/getsession', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594fd00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
                environ["werkzeug.debug.preserve_context"](_cv_app.get())
>               environ["werkzeug.debug.preserve_context"](_cv_request.get())
E               LookupError: <ContextVar name='flask.request_ctx' at 0x7ce736e761b0>

src/flask/app.py:1503: LookupError
__________________________ test_session_transactions ___________________________

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_session_transactions(app, client):
        @app.route("/")
        def index():
            return str(flask.session["foo"])
    
        with client:
>           with client.session_transaction() as sess:

tests/test_testing.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FlaskClient <Flask 'flask_test'>>, args = (), kwargs = {}
app = <Flask 'flask_test'>
ctx = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357b8100>

    @contextmanager
    def session_transaction(
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Iterator[SessionMixin]:
        """When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.
    
        ::
    
            with client.session_transaction() as session:
                session['value'] = 42
    
        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """
        if self._cookies is None:
            raise TypeError(
                "Cookies are disabled. Create a client with 'use_cookies=True'."
            )
    
        app = self.application
        ctx = app.test_request_context(*args, **kwargs)
>       self._add_cookies_to_wsgi(ctx.request.environ)
E       AttributeError: 'RequestContext' object has no attribute 'request'

src/flask/testing.py:162: AttributeError
__________________ test_session_transactions_no_null_sessions __________________

    def test_session_transactions_no_null_sessions():
        app = flask.Flask(__name__)
    
        with app.test_client() as c:
            with pytest.raises(RuntimeError) as e:
>               with c.session_transaction():

tests/test_testing.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.10/contextlib.py:135: in __enter__
    return next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <FlaskClient <Flask 'test_testing'>>, args = (), kwargs = {}
app = <Flask 'test_testing'>
ctx = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73549acb0>

    @contextmanager
    def session_transaction(
        self, *args: t.Any, **kwargs: t.Any
    ) -> t.Iterator[SessionMixin]:
        """When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.
    
        ::
    
            with client.session_transaction() as session:
                session['value'] = 42
    
        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """
        if self._cookies is None:
            raise TypeError(
                "Cookies are disabled. Create a client with 'use_cookies=True'."
            )
    
        app = self.application
        ctx = app.test_request_context(*args, **kwargs)
>       self._add_cookies_to_wsgi(ctx.request.environ)
E       AttributeError: 'RequestContext' object has no attribute 'request'

src/flask/testing.py:162: AttributeError
_______________________ test_test_client_context_binding _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d630>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_test_client_context_binding(app, client):
        app.testing = False
    
        @app.route("/")
        def index():
            flask.g.value = 42
            return "Hello World!"
    
        @app.route("/other")
        def other():
            raise ZeroDivisionError
    
        with client:
>           resp = client.get("/")

tests/test_testing.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d630>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
______________________________ test_reuse_client _______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2b00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735c9e470>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

client = <FlaskClient <Flask 'flask_test'>>

    def test_reuse_client(client):
        c = client
    
        with c:
>           assert client.get("/").status_code == 404

tests/test_testing.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce735ad2b00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
____________________________ test_full_url_request _____________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '6', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'domain.com', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e7a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73537a770>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_full_url_request(app, client):
        @app.route("/action", methods=["POST"])
        def action():
            return "x"
    
        with client:
>           rv = client.post("http://domain.com/action?vodka=42", data={"gin": 43})

tests/test_testing.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '6', 'CONTENT_TYPE': 'application/x-www-form-urlencoded', 'HTTP_HOST': 'domain.com', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e7a0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
________________________ test_json_request_and_response ________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '49', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594edd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735141de0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_json_request_and_response(app, client):
        @app.route("/echo", methods=["POST"])
        def echo():
            return jsonify(flask.request.get_json())
    
        with client:
            json_data = {"drink": {"gin": 1, "tonic": True}, "price": 10}
>           rv = client.post("/echo", json=json_data)

tests/test_testing.py:270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '49', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594edd0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
                response = self.handle_exception(e)
            except:  # noqa: B001
                error = sys.exc_info()[1]
                raise
            return response(environ, start_response)
        finally:
            if "werkzeug.debug.preserve_context" in environ:
>               environ["werkzeug.debug.preserve_context"](_cv_app.get())
E               LookupError: <ContextVar name='flask.app_ctx' at 0x7ce736e76200>

src/flask/app.py:1502: LookupError
_______________________ test_client_json_no_app_context ________________________

self = <Flask 'flask_test'>
environ = {'CONTENT_LENGTH': '17', 'CONTENT_TYPE': 'application/json', 'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d090>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355f1fc0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_client_json_no_app_context(app, client):
        @app.route("/hello", methods=["POST"])
        def hello():
            return f"Hello, {flask.request.json['name']}!"
    
        class Namespace:
            count = 0
    
            def add(self, app):
                self.count += 1
    
        ns = Namespace()
    
        with appcontext_popped.connected_to(ns.add, app):
>           rv = client.post("/hello", json={"name": "Flask"})

tests/test_testing.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1167: in post
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355f1fc0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________________ test_subdomain ________________________________

    def test_subdomain():
        app = flask.Flask(__name__, subdomain_matching=True)
        app.config["SERVER_NAME"] = "example.com"
        client = app.test_client()
    
        @app.route("/", subdomain="<company_id>")
        def view(company_id):
            return company_id
    
>       with app.test_request_context():

tests/test_testing.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735604370>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_______________________________ test_nosubdomain _______________________________

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_nosubdomain(app, client):
        app.config["SERVER_NAME"] = "example.com"
    
        @app.route("/<company_id>")
        def view(company_id):
            return company_id
    
>       with app.test_request_context():

tests/test_testing.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/ctx.py:409: in __enter__
    self.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735b89240>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError
_________________________ test_error_handler_no_match __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/custom', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e9e0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_error_handler_no_match(app, client):
        class CustomException(Exception):
            pass
    
        @app.errorhandler(CustomException)
        def custom_exception_handler(e):
            assert isinstance(e, CustomException)
            return "custom"
    
        with pytest.raises(TypeError) as exc_info:
            app.register_error_handler(CustomException(), None)
    
        assert "CustomException() is an instance, not a class." in str(exc_info.value)
    
        with pytest.raises(ValueError) as exc_info:
            app.register_error_handler(list, None)
    
        assert "'list' is not a subclass of Exception." in str(exc_info.value)
    
        @app.errorhandler(500)
        def handle_500(e):
            assert isinstance(e, InternalServerError)
    
            if e.original_exception is not None:
                return f"wrapped {type(e.original_exception).__name__}"
    
            return "direct"
    
        with pytest.raises(ValueError) as exc_info:
            app.register_error_handler(999, None)
    
        assert "Use a subclass of HTTPException" in str(exc_info.value)
    
        @app.route("/custom")
        def custom_test():
            raise CustomException()
    
        @app.route("/keyerror")
        def key_error():
            raise KeyError()
    
        @app.route("/abort")
        def do_abort():
            flask.abort(500)
    
        app.testing = False
>       assert client.get("/custom").data == b"custom"

tests/test_user_error_handler.py:56: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce3730>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_error_handler_subclass __________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/parent', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594c280>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73558eb90>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_error_handler_subclass(app):
        class ParentException(Exception):
            pass
    
        class ChildExceptionUnregistered(ParentException):
            pass
    
        class ChildExceptionRegistered(ParentException):
            pass
    
        @app.errorhandler(ParentException)
        def parent_exception_handler(e):
            assert isinstance(e, ParentException)
            return "parent"
    
        @app.errorhandler(ChildExceptionRegistered)
        def child_exception_handler(e):
            assert isinstance(e, ChildExceptionRegistered)
            return "child-registered"
    
        @app.route("/parent")
        def parent_test():
            raise ParentException()
    
        @app.route("/child-unregistered")
        def unregistered_test():
            raise ChildExceptionUnregistered()
    
        @app.route("/child-registered")
        def registered_test():
            raise ChildExceptionRegistered()
    
        c = app.test_client()
    
>       assert c.get("/parent").data == b"parent"

tests/test_user_error_handler.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73558eb90>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________ test_error_handler_http_subclass _______________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/forbidden', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e320>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357c2380>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_error_handler_http_subclass(app):
        class ForbiddenSubclassRegistered(Forbidden):
            pass
    
        class ForbiddenSubclassUnregistered(Forbidden):
            pass
    
        @app.errorhandler(403)
        def code_exception_handler(e):
            assert isinstance(e, Forbidden)
            return "forbidden"
    
        @app.errorhandler(ForbiddenSubclassRegistered)
        def subclass_exception_handler(e):
            assert isinstance(e, ForbiddenSubclassRegistered)
            return "forbidden-registered"
    
        @app.route("/forbidden")
        def forbidden_test():
            raise Forbidden()
    
        @app.route("/forbidden-registered")
        def registered_test():
            raise ForbiddenSubclassRegistered()
    
        @app.route("/forbidden-unregistered")
        def unregistered_test():
            raise ForbiddenSubclassUnregistered()
    
        c = app.test_client()
    
>       assert c.get("/forbidden").data == b"forbidden"

tests/test_user_error_handler.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357c2380>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_error_handler_blueprint _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/error', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594de10>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed51e0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_error_handler_blueprint(app):
        bp = flask.Blueprint("bp", __name__)
    
        @bp.errorhandler(500)
        def bp_exception_handler(e):
            return "bp-error"
    
        @bp.route("/error")
        def bp_test():
            raise InternalServerError()
    
        @app.errorhandler(500)
        def app_exception_handler(e):
            return "app-error"
    
        @app.route("/error")
        def app_test():
            raise InternalServerError()
    
        app.register_blueprint(bp, url_prefix="/bp")
    
        c = app.test_client()
    
>       assert c.get("/error").data == b"app-error"

tests/test_user_error_handler.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ed51e0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_default_error_handler __________________________

self = <Flask 'test_user_error_handler'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/bp/undefined', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594feb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_default_error_handler():
        bp = flask.Blueprint("bp", __name__)
    
        @bp.errorhandler(HTTPException)
        def bp_exception_handler(e):
            assert isinstance(e, HTTPException)
            assert isinstance(e, NotFound)
            return "bp-default"
    
        @bp.errorhandler(Forbidden)
        def bp_forbidden_handler(e):
            assert isinstance(e, Forbidden)
            return "bp-forbidden"
    
        @bp.route("/undefined")
        def bp_registered_test():
            raise NotFound()
    
        @bp.route("/forbidden")
        def bp_forbidden_test():
            raise Forbidden()
    
        app = flask.Flask(__name__)
    
        @app.errorhandler(HTTPException)
        def catchall_exception_handler(e):
            assert isinstance(e, HTTPException)
            assert isinstance(e, NotFound)
            return "default"
    
        @app.errorhandler(Forbidden)
        def catchall_forbidden_handler(e):
            assert isinstance(e, Forbidden)
            return "forbidden"
    
        @app.route("/forbidden")
        def forbidden():
            raise Forbidden()
    
        @app.route("/slash/")
        def slash():
            return "slash"
    
        app.register_blueprint(bp, url_prefix="/bp")
    
        c = app.test_client()
>       assert c.get("/bp/undefined").data == b"bp-default"

tests/test_user_error_handler.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7357ae5f0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______ TestGenericHandlers.test_handle_class_or_code[InternalServerError] ______

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/custom', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e290>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

self = <test_user_error_handler.TestGenericHandlers object at 0x7ce735d6afe0>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
to_handle = <class 'werkzeug.exceptions.InternalServerError'>

    @pytest.mark.parametrize("to_handle", (InternalServerError, 500))
    def test_handle_class_or_code(self, app, client, to_handle):
        """``InternalServerError`` and ``500`` are aliases, they should
        have the same behavior. Both should only receive
        ``InternalServerError``, which might wrap another error.
        """
    
        @app.errorhandler(to_handle)
        def handle_500(e):
            assert isinstance(e, InternalServerError)
            return self.report_error(e)
    
>       assert client.get("/custom").data == b"wrapped Custom"

tests/test_user_error_handler.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7355c7a60>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________ TestGenericHandlers.test_handle_class_or_code[500] ______________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/custom', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594eb00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

self = <test_user_error_handler.TestGenericHandlers object at 0x7ce735d6a470>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>
to_handle = 500

    @pytest.mark.parametrize("to_handle", (InternalServerError, 500))
    def test_handle_class_or_code(self, app, client, to_handle):
        """``InternalServerError`` and ``500`` are aliases, they should
        have the same behavior. Both should only receive
        ``InternalServerError``, which might wrap another error.
        """
    
        @app.errorhandler(to_handle)
        def handle_500(e):
            assert isinstance(e, InternalServerError)
            return self.report_error(e)
    
>       assert client.get("/custom").data == b"wrapped Custom"

tests/test_user_error_handler.py:264: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7358315d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________ TestGenericHandlers.test_handle_generic_http _________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/error', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594eef0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

self = <test_user_error_handler.TestGenericHandlers object at 0x7ce735d6ae60>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_handle_generic_http(self, app, client):
        """``HTTPException`` should only receive ``HTTPException``
        subclasses. It will receive ``404`` routing exceptions.
        """
    
        @app.errorhandler(HTTPException)
        def handle_http(e):
            assert isinstance(e, HTTPException)
            return str(e.code)
    
>       assert client.get("/error").data == b"500"

tests/test_user_error_handler.py:279: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73580fa30>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ TestGenericHandlers.test_handle_generic ____________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/custom', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594dab0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

self = <test_user_error_handler.TestGenericHandlers object at 0x7ce735d69cf0>
app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_handle_generic(self, app, client):
        """Generic ``Exception`` will handle all exceptions directly,
        including ``HTTPExceptions``.
        """
    
        @app.errorhandler(Exception)
        def handle_exception(e):
            return self.report_error(e)
    
>       assert client.get("/custom").data == b"direct Custom"

tests/test_user_error_handler.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73561e110>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_______________________________ test_basic_view ________________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594c1f0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568f7f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_basic_view(app):
        class Index(flask.views.View):
            methods = ["GET", "POST"]
    
            def dispatch_request(self):
                return flask.request.method
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
>       common_test(app)

tests/test_views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_views.py:10: in common_test
    assert c.get("/").data == b"GET"
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73568f7f0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_method_based_view ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d870>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73509f670>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_method_based_view(app):
        class Index(flask.views.MethodView):
            def get(self):
                return "GET"
    
            def post(self):
                return "POST"
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
    
>       common_test(app)

tests/test_views.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_views.py:10: in common_test
    assert c.get("/").data == b"GET"
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73509f670>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_view_patching ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594f640>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73586bc40>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_view_patching(app):
        class Index(flask.views.MethodView):
            def get(self):
                raise ZeroDivisionError
    
            def post(self):
                raise ZeroDivisionError
    
        class Other(Index):
            def get(self):
                return "GET"
    
            def post(self):
                return "POST"
    
        view = Index.as_view("index")
        view.view_class = Other
        app.add_url_rule("/", view_func=view)
>       common_test(app)

tests/test_views.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_views.py:10: in common_test
    assert c.get("/").data == b"GET"
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73586bc40>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_view_inheritance _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d240>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735304f70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_view_inheritance(app, client):
        class Index(flask.views.MethodView):
            def get(self):
                return "GET"
    
            def post(self):
                return "POST"
    
        class BetterIndex(Index):
            def delete(self):
                return "DELETE"
    
        app.add_url_rule("/", view_func=BetterIndex.as_view("index"))
    
>       meths = parse_set_header(client.open("/", method="OPTIONS").headers["Allow"])

tests/test_views.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735304f70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_____________________________ test_view_decorators _____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594fc70>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735706470>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_view_decorators(app, client):
        def add_x_parachute(f):
            def new_function(*args, **kwargs):
                resp = flask.make_response(f(*args, **kwargs))
                resp.headers["X-Parachute"] = "awesome"
                return resp
    
            return new_function
    
        class Index(flask.views.View):
            decorators = [add_x_parachute]
    
            def dispatch_request(self):
                return "Awesome"
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
>       rv = client.get("/")

tests/test_views.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735706470>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
___________________ test_view_provide_automatic_options_attr ___________________

self = <Flask 'test_views'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594dab0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:835: in handle_exception
    self.log_exception(exc_info)
src/flask/app.py:857: in log_exception
    f"Exception on {request.path} [{request.method}]", exc_info=exc_info
/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:318: in __get__
    obj = instance._get_current_object()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _get_current_object() -> T:
        try:
            obj = local.get()
        except LookupError:
>           raise RuntimeError(unbound_message) from None
E           RuntimeError: Working outside of request context.
E           
E           This typically means that you attempted to use functionality that needed
E           an active HTTP request. Consult the documentation on testing for
E           information about how to avoid this problem.

/opt/venv/lib/python3.10/site-packages/werkzeug/local.py:519: RuntimeError

During handling of the above exception, another exception occurred:

    def test_view_provide_automatic_options_attr():
        app = flask.Flask(__name__)
    
        class Index1(flask.views.View):
            provide_automatic_options = False
    
            def dispatch_request(self):
                return "Hello World!"
    
        app.add_url_rule("/", view_func=Index1.as_view("index"))
        c = app.test_client()
>       rv = c.open("/", method="OPTIONS")

tests/test_views.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73562eda0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_implicit_head ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594f400>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735728e80>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_implicit_head(app, client):
        class Index(flask.views.MethodView):
            def get(self):
                return flask.Response("Blub", headers={"X-Method": flask.request.method})
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
>       rv = client.get("/")

tests/test_views.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735728e80>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
______________________________ test_explicit_head ______________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594feb0>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735afb4f0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_explicit_head(app, client):
        class Index(flask.views.MethodView):
            def get(self):
                return "GET"
    
            def head(self):
                return flask.Response("", headers={"X-Method": "HEAD"})
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
>       rv = client.get("/")

tests/test_views.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735afb4f0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
____________________________ test_endpoint_override ____________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594d750>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7359736d0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>

    def test_endpoint_override(app):
        app.debug = True
    
        class Index(flask.views.View):
            methods = ["GET", "POST"]
    
            def dispatch_request(self):
                return flask.request.method
    
        app.add_url_rule("/", view_func=Index.as_view("index"))
    
        with pytest.raises(AssertionError):
            app.add_url_rule("/", view_func=Index.as_view("index"))
    
        # But these tests should still pass. We just log a warning.
>       common_test(app)

tests/test_views.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_views.py:10: in common_test
    assert c.get("/").data == b"GET"
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce7359736d0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
_________________________ test_methods_var_inheritance _________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594fd90>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce2800>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_methods_var_inheritance(app, client):
        class BaseView(flask.views.MethodView):
            methods = ["GET", "PROPFIND"]
    
        class ChildView(BaseView):
            def get(self):
                return "GET"
    
            def propfind(self):
                return "PROPFIND"
    
        app.add_url_rule("/", view_func=ChildView.as_view("index"))
    
>       assert client.get("/").data == b"GET"

tests/test_views.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735ce2800>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
__________________________ test_multiple_inheritance ___________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594e830>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73508efb0>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_multiple_inheritance(app, client):
        class GetView(flask.views.MethodView):
            def get(self):
                return "GET"
    
        class DeleteView(flask.views.MethodView):
            def delete(self):
                return "DELETE"
    
        class GetDeleteView(GetView, DeleteView):
            pass
    
        app.add_url_rule("/", view_func=GetDeleteView.as_view("index"))
    
>       assert client.get("/").data == b"GET"

tests/test_views.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce73508efb0>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________ test_remove_method_from_parent ________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594eb00>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735613f70>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_remove_method_from_parent(app, client):
        class GetView(flask.views.MethodView):
            def get(self):
                return "GET"
    
        class OtherView(flask.views.MethodView):
            def post(self):
                return "POST"
    
        class View(GetView, OtherView):
            methods = ["GET"]
    
        app.add_url_rule("/", view_func=View.as_view("index"))
    
>       assert client.get("/").data == b"GET"

tests/test_views.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735613f70>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
________________________________ test_init_once ________________________________

self = <Flask 'flask_test'>
environ = {'HTTP_HOST': 'localhost', 'HTTP_USER_AGENT': 'Werkzeug/3.1.3', 'PATH_INFO': '/', 'QUERY_STRING': '', ...}
start_response = <function run_wsgi_app.<locals>.start_response at 0x7ce73594fc70>

    def wsgi_app(
        self, environ: WSGIEnvironment, start_response: StartResponse
    ) -> cabc.Iterable[bytes]:
        """The actual WSGI application. This is not implemented in
        :meth:`__call__` so that middlewares can be applied without
        losing a reference to the app object. Instead of doing this::
    
            app = MyMiddleware(app)
    
        It's a better idea to do this instead::
    
            app.wsgi_app = MyMiddleware(app.wsgi_app)
    
        Then you still have the original application object around and
        can continue to call methods on it.
    
        .. versionchanged:: 0.7
            Teardown events for the request and app contexts are called
            even if an unhandled error occurs. Other events may not be
            called depending on when an error occurs during dispatch.
            See :ref:`callbacks-and-errors`.
    
        :param environ: A WSGI environment.
        :param start_response: A callable accepting a status code,
            a list of headers, and an optional exception context to
            start the response.
        """
        ctx = self.request_context(environ)
        error: BaseException | None = None
        try:
            try:
                ctx.push()
                response = self.full_dispatch_request()
            except Exception as e:
                error = e
>               response = self.handle_exception(e)

src/flask/app.py:1495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/flask/app.py:1491: in wsgi_app
    ctx.push()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735306c20>

    def push(self) -> None:
        # Before we push the request context we have to ensure that there
        # is an application context.
        app_ctx = _cv_app.get(None)
    
        if app_ctx is None or app_ctx.app is not self.app:
>           app_ctx = self.app.app_context()
E           AttributeError: 'RequestContext' object has no attribute 'app'

src/flask/ctx.py:348: AttributeError

During handling of the above exception, another exception occurred:

app = <Flask 'flask_test'>, client = <FlaskClient <Flask 'flask_test'>>

    def test_init_once(app, client):
        n = 0
    
        class CountInit(flask.views.View):
            init_every_request = False
    
            def __init__(self):
                nonlocal n
                n += 1
    
            def dispatch_request(self):
                return str(n)
    
        app.add_url_rule("/", view_func=CountInit.as_view("index"))
>       assert client.get("/").data == b"1"

tests/test_views.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1162: in get
    return self.open(*args, **kw)
src/flask/testing.py:235: in open
    response = super().open(
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1116: in open
    response_parts = self.run_wsgi_app(request.environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:988: in run_wsgi_app
    rv = run_wsgi_app(self.application, environ, buffered=buffered)
/opt/venv/lib/python3.10/site-packages/werkzeug/test.py:1264: in run_wsgi_app
    app_rv = app(environ, start_response)
src/flask/app.py:1517: in __call__
    return self.wsgi_app(environ, start_response)
src/flask/app.py:1508: in wsgi_app
    ctx.pop(error)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'RequestContext' object has no attribute 'request'") raised in repr()] RequestContext object at 0x7ce735306c20>
exc = AttributeError("'RequestContext' object has no attribute 'app'")

    def pop(self, exc: BaseException | None = _sentinel) -> None:  # type: ignore
        """Pops the request context and unbinds it by doing that.  This will
        also trigger the execution of functions registered by the
        :meth:`~flask.Flask.teardown_request` decorator.
    
        .. versionchanged:: 0.9
           Added the `exc` argument.
        """
>       clear_request = len(self._cv_tokens) == 1
E       AttributeError: 'RequestContext' object has no attribute '_cv_tokens'

src/flask/ctx.py:379: AttributeError
=========================== short test summary info ============================
FAILED tests/test_appctx.py::test_request_context_means_app_context - Attribu...
FAILED tests/test_appctx.py::test_app_tearing_down_with_handled_exception_by_app_handler
FAILED tests/test_appctx.py::test_app_tearing_down_with_unhandled_exception
FAILED tests/test_appctx.py::test_context_refcounts - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_options_work - AttributeError: 'RequestConte...
FAILED tests/test_basic.py::test_options_on_multiple_rules - AttributeError: ...
FAILED tests/test_basic.py::test_method_route[get] - AttributeError: 'Request...
FAILED tests/test_basic.py::test_method_route[post] - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_method_route[put] - AttributeError: 'Request...
FAILED tests/test_basic.py::test_method_route[delete] - AttributeError: 'Requ...
FAILED tests/test_basic.py::test_method_route[patch] - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_provide_automatic_options_attr - AttributeEr...
FAILED tests/test_basic.py::test_provide_automatic_options_kwarg - AttributeE...
FAILED tests/test_basic.py::test_request_dispatching - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_url_mapping - AttributeError: 'RequestContex...
FAILED tests/test_basic.py::test_werkzeug_routing - AttributeError: 'RequestC...
FAILED tests/test_basic.py::test_endpoint_decorator - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_session - AttributeError: 'RequestContext' o...
FAILED tests/test_basic.py::test_session_path - AttributeError: 'RequestConte...
FAILED tests/test_basic.py::test_session_using_application_root - AttributeEr...
FAILED tests/test_basic.py::test_session_using_session_settings - AttributeEr...
FAILED tests/test_basic.py::test_session_using_samesite_attribute - Attribute...
FAILED tests/test_basic.py::test_missing_session - AttributeError: 'RequestCo...
FAILED tests/test_basic.py::test_session_secret_key_fallbacks - AttributeErro...
FAILED tests/test_basic.py::test_session_expiration - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_session_stored_last - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_session_special_types - LookupError: <Contex...
FAILED tests/test_basic.py::test_session_cookie_setting - LookupError: <Conte...
FAILED tests/test_basic.py::test_session_vary_cookie - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_session_refresh_vary - AttributeError: 'Requ...
FAILED tests/test_basic.py::test_extended_flashing - AttributeError: 'Request...
FAILED tests/test_basic.py::test_request_processing - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_request_preprocessing_early_return - Attribu...
FAILED tests/test_basic.py::test_after_request_processing - AttributeError: '...
FAILED tests/test_basic.py::test_teardown_request_handler - AttributeError: '...
FAILED tests/test_basic.py::test_teardown_request_handler_debug_mode - Attrib...
FAILED tests/test_basic.py::test_teardown_request_handler_error - AttributeEr...
FAILED tests/test_basic.py::test_before_after_request_order - AttributeError:...
FAILED tests/test_basic.py::test_error_handling - AttributeError: 'RequestCon...
FAILED tests/test_basic.py::test_error_handling_processing - AttributeError: ...
FAILED tests/test_basic.py::test_baseexception_error_handling - AttributeErro...
FAILED tests/test_basic.py::test_before_request_and_routing_errors - Attribut...
FAILED tests/test_basic.py::test_user_error_handling - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_http_error_subclass_handling - AttributeErro...
FAILED tests/test_basic.py::test_errorhandler_precedence - AttributeError: 'R...
FAILED tests/test_basic.py::test_trap_bad_request_key_error[False-None-True-True]
FAILED tests/test_basic.py::test_trap_bad_request_key_error[True-None-False-True]
FAILED tests/test_basic.py::test_trap_bad_request_key_error[False-True-False-False]
FAILED tests/test_basic.py::test_trapping_of_all_http_exceptions - AttributeE...
FAILED tests/test_basic.py::test_error_handler_after_processor_error - Attrib...
FAILED tests/test_basic.py::test_enctype_debug_helper - AttributeError: 'Requ...
FAILED tests/test_basic.py::test_response_types - AttributeError: 'RequestCon...
FAILED tests/test_basic.py::test_response_type_errors - AttributeError: 'Requ...
FAILED tests/test_basic.py::test_build_error_handler - AttributeError: 'Reque...
FAILED tests/test_basic.py::test_build_error_handler_reraise - AttributeError...
FAILED tests/test_basic.py::test_url_for_passes_special_values_to_build_error_handler
FAILED tests/test_basic.py::test_static_files - AttributeError: 'RequestConte...
FAILED tests/test_basic.py::test_static_url_path - AttributeError: 'RequestCo...
FAILED tests/test_basic.py::test_static_url_path_with_ending_slash - Attribut...
FAILED tests/test_basic.py::test_static_url_empty_path - AttributeError: 'Req...
FAILED tests/test_basic.py::test_static_url_empty_path_default - AttributeErr...
FAILED tests/test_basic.py::test_static_folder_with_pathlib_path - AttributeE...
FAILED tests/test_basic.py::test_static_folder_with_ending_slash - AttributeE...
FAILED tests/test_basic.py::test_static_route_with_host_matching - AttributeE...
FAILED tests/test_basic.py::test_server_name_matching[False-False-default-default-default]
FAILED tests/test_basic.py::test_server_name_matching[True-False-default-abc-<invalid>]
FAILED tests/test_basic.py::test_server_name_matching[False-True-default-abc-default]
FAILED tests/test_basic.py::test_server_name_subdomain - AttributeError: 'Req...
FAILED tests/test_basic.py::test_exception_propagation[TESTING] - AttributeEr...
FAILED tests/test_basic.py::test_exception_propagation[PROPAGATE_EXCEPTIONS]
FAILED tests/test_basic.py::test_exception_propagation[DEBUG] - AttributeErro...
FAILED tests/test_basic.py::test_exception_propagation[None] - AttributeError...
FAILED tests/test_basic.py::test_url_processors - AttributeError: 'RequestCon...
FAILED tests/test_basic.py::test_inject_blueprint_url_defaults - AttributeErr...
FAILED tests/test_basic.py::test_nonascii_pathinfo - AttributeError: 'Request...
FAILED tests/test_basic.py::test_no_setup_after_first_request - AttributeErro...
FAILED tests/test_basic.py::test_routing_redirect_debugging - AttributeError:...
FAILED tests/test_basic.py::test_route_decorator_custom_endpoint - AttributeE...
FAILED tests/test_basic.py::test_subdomain_basic_support - AttributeError: 'R...
FAILED tests/test_basic.py::test_subdomain_matching - AttributeError: 'Reques...
FAILED tests/test_basic.py::test_subdomain_matching_with_ports - AttributeErr...
FAILED tests/test_basic.py::test_subdomain_matching_other_name[False] - Attri...
FAILED tests/test_basic.py::test_subdomain_matching_other_name[True] - Attrib...
FAILED tests/test_basic.py::test_multi_route_rules - AttributeError: 'Request...
FAILED tests/test_basic.py::test_multi_route_class_views - AttributeError: 'R...
FAILED tests/test_basic.py::test_max_cookie_size - AttributeError: 'RequestCo...
FAILED tests/test_blueprints.py::test_blueprint_specific_error_handling - Att...
FAILED tests/test_blueprints.py::test_blueprint_specific_user_error_handling
FAILED tests/test_blueprints.py::test_blueprint_app_error_handling - Attribut...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[-/-/] - Attribut...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/--/] - Attribut...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/-/-/] - Attribu...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo--/foo] - At...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/--/foo/] - ...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[-/bar-/bar] - At...
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-/bar-/foo/bar]
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-bar-/foo/bar]
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo-/bar-/foo/bar]
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo/-//bar-/foo/bar]
FAILED tests/test_blueprints.py::test_blueprint_prefix_slash[/foo//-/bar-/foo/bar]
FAILED tests/test_blueprints.py::test_blueprint_url_defaults - AttributeError...
FAILED tests/test_blueprints.py::test_blueprint_url_processors - AttributeErr...
FAILED tests/test_blueprints.py::test_templates_and_static - AttributeError: ...
FAILED tests/test_blueprints.py::test_default_static_max_age - AttributeError...
FAILED tests/test_blueprints.py::test_dotted_names_from_app - AttributeError:...
FAILED tests/test_blueprints.py::test_empty_url_defaults - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_route_decorator_custom_endpoint - Attri...
FAILED tests/test_blueprints.py::test_endpoint_decorator - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_template_filter_with_template - Attribu...
FAILED tests/test_blueprints.py::test_template_filter_after_route_with_template
FAILED tests/test_blueprints.py::test_add_template_filter_with_template - Att...
FAILED tests/test_blueprints.py::test_template_filter_with_name_and_template
FAILED tests/test_blueprints.py::test_add_template_filter_with_name_and_template
FAILED tests/test_blueprints.py::test_template_test_with_template - Attribute...
FAILED tests/test_blueprints.py::test_template_test_after_route_with_template
FAILED tests/test_blueprints.py::test_add_template_test_with_template - Attri...
FAILED tests/test_blueprints.py::test_template_test_with_name_and_template - ...
FAILED tests/test_blueprints.py::test_add_template_test_with_name_and_template
FAILED tests/test_blueprints.py::test_context_processing - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_request_processing - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_app_request_processing - AttributeError...
FAILED tests/test_blueprints.py::test_app_url_processors - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_nested_blueprint - AttributeError: 'Req...
FAILED tests/test_blueprints.py::test_nested_callback_order - AttributeError:...
FAILED tests/test_blueprints.py::test_nesting_url_prefixes[/parent-/child-None-None]
FAILED tests/test_blueprints.py::test_nesting_url_prefixes[/parent-None-None-/child]
FAILED tests/test_blueprints.py::test_nesting_url_prefixes[None-None-/parent-/child]
FAILED tests/test_blueprints.py::test_nesting_url_prefixes[/other-/something-/parent-/child]
FAILED tests/test_blueprints.py::test_nesting_subdomains - AttributeError: 'R...
FAILED tests/test_blueprints.py::test_child_and_parent_subdomain - AttributeE...
FAILED tests/test_blueprints.py::test_blueprint_renaming - AttributeError: 'R...
FAILED tests/test_converters.py::test_custom_converters - AttributeError: 'Re...
FAILED tests/test_converters.py::test_context_available - AttributeError: 'Re...
FAILED tests/test_helpers.py::TestStreaming::test_streaming_with_context - At...
FAILED tests/test_helpers.py::TestStreaming::test_streaming_with_context_as_decorator
FAILED tests/test_helpers.py::TestStreaming::test_streaming_with_context_and_custom_close
FAILED tests/test_helpers.py::TestStreaming::test_stream_keeps_session - Attr...
FAILED tests/test_helpers.py::TestHelpers::test_make_response - AttributeErro...
FAILED tests/test_json.py::test_bad_request_debug_message[True] - AttributeEr...
FAILED tests/test_json.py::test_bad_request_debug_message[False] - AttributeE...
FAILED tests/test_json.py::test_json_bad_requests - AttributeError: 'RequestC...
FAILED tests/test_json.py::test_json_custom_mimetypes - AttributeError: 'Requ...
FAILED tests/test_json.py::test_jsonify_basic_types[0] - AttributeError: 'Req...
FAILED tests/test_json.py::test_jsonify_basic_types[-1] - AttributeError: 'Re...
FAILED tests/test_json.py::test_jsonify_basic_types[1] - AttributeError: 'Req...
FAILED tests/test_json.py::test_jsonify_basic_types[23] - AttributeError: 'Re...
FAILED tests/test_json.py::test_jsonify_basic_types[3.14] - AttributeError: '...
FAILED tests/test_json.py::test_jsonify_basic_types[s] - AttributeError: 'Req...
FAILED tests/test_json.py::test_jsonify_basic_types[longer string] - Attribut...
FAILED tests/test_json.py::test_jsonify_basic_types[True] - AttributeError: '...
FAILED tests/test_json.py::test_jsonify_basic_types[False] - AttributeError: ...
FAILED tests/test_json.py::test_jsonify_basic_types[None] - AttributeError: '...
FAILED tests/test_json.py::test_jsonify_dicts - AttributeError: 'RequestConte...
FAILED tests/test_json.py::test_jsonify_arrays - AttributeError: 'RequestCont...
FAILED tests/test_json.py::test_jsonify_datetime[value0] - AttributeError: 'R...
FAILED tests/test_json.py::test_jsonify_datetime[value1] - AttributeError: 'R...
FAILED tests/test_json.py::test_jsonify_uuid_types - AttributeError: 'Request...
FAILED tests/test_json.py::test_json_attr - AttributeError: 'RequestContext' ...
FAILED tests/test_json.py::test_json_customization - AttributeError: 'Request...
FAILED tests/test_json.py::test_json_key_sorting - AttributeError: 'RequestCo...
FAILED tests/test_logging.py::test_wsgi_errors_stream - AttributeError: 'Requ...
FAILED tests/test_logging.py::test_log_view_exception - AttributeError: 'Requ...
FAILED tests/test_regression.py::test_aborting - LookupError: <ContextVar nam...
FAILED tests/test_reqctx.py::test_teardown_on_pop - AttributeError: 'RequestC...
FAILED tests/test_reqctx.py::test_teardown_with_previous_exception - Attribut...
FAILED tests/test_reqctx.py::test_teardown_with_handled_exception - Attribute...
FAILED tests/test_reqctx.py::test_proper_test_request_context - AttributeErro...
FAILED tests/test_reqctx.py::test_context_binding - AttributeError: 'RequestC...
FAILED tests/test_reqctx.py::test_context_test - AttributeError: 'RequestCont...
FAILED tests/test_reqctx.py::test_manual_context_binding - AttributeError: 'R...
FAILED tests/test_reqctx.py::test_session_error_pops_context - AttributeError...
FAILED tests/test_reqctx.py::test_session_dynamic_cookie_name - AttributeErro...
FAILED tests/test_reqctx.py::test_bad_environ_raises_bad_request - AttributeE...
FAILED tests/test_reqctx.py::test_environ_for_valid_idna_completes - Attribut...
FAILED tests/test_reqctx.py::test_normal_environ_completes - AttributeError: ...
FAILED tests/test_request.py::test_max_content_length - AttributeError: 'Requ...
FAILED tests/test_request.py::test_trusted_hosts_config - AttributeError: 'Re...
FAILED tests/test_session_interface.py::test_open_session_with_endpoint - Att...
FAILED tests/test_signals.py::test_template_rendered - AttributeError: 'Reque...
FAILED tests/test_signals.py::test_before_render_template - AttributeError: '...
FAILED tests/test_signals.py::test_request_signals - AttributeError: 'Request...
FAILED tests/test_signals.py::test_request_exception_signal - AttributeError:...
FAILED tests/test_signals.py::test_appcontext_signals - AttributeError: 'Requ...
FAILED tests/test_signals.py::test_flash_signal - AttributeError: 'RequestCon...
FAILED tests/test_signals.py::test_appcontext_tearing_down_signal - Attribute...
FAILED tests/test_subclassing.py::test_suppressed_exception_logging - Attribu...
FAILED tests/test_templating.py::test_context_processing - AttributeError: 'R...
FAILED tests/test_templating.py::test_original_win - AttributeError: 'Request...
FAILED tests/test_templating.py::test_simple_stream - AttributeError: 'Reques...
FAILED tests/test_templating.py::test_standard_context - AttributeError: 'Req...
FAILED tests/test_templating.py::test_escaping - AttributeError: 'RequestCont...
FAILED tests/test_templating.py::test_no_escaping - AttributeError: 'RequestC...
FAILED tests/test_templating.py::test_template_filter_with_template - Attribu...
FAILED tests/test_templating.py::test_add_template_filter_with_template - Att...
FAILED tests/test_templating.py::test_template_filter_with_name_and_template
FAILED tests/test_templating.py::test_add_template_filter_with_name_and_template
FAILED tests/test_templating.py::test_template_test_with_template - Attribute...
FAILED tests/test_templating.py::test_add_template_test_with_template - Attri...
FAILED tests/test_templating.py::test_template_test_with_name_and_template - ...
FAILED tests/test_templating.py::test_add_template_test_with_name_and_template
FAILED tests/test_templating.py::test_custom_template_loader - AttributeError...
FAILED tests/test_templating.py::test_iterable_loader - AttributeError: 'Requ...
FAILED tests/test_templating.py::test_template_loader_debugging - LookupError...
FAILED tests/test_testing.py::test_environ_defaults_from_config - AttributeEr...
FAILED tests/test_testing.py::test_environ_base_default - LookupError: <Conte...
FAILED tests/test_testing.py::test_environ_base_modified - LookupError: <Cont...
FAILED tests/test_testing.py::test_client_open_environ - AttributeError: 'Req...
FAILED tests/test_testing.py::test_specify_url_scheme - AttributeError: 'Requ...
FAILED tests/test_testing.py::test_blueprint_with_subdomain - AttributeError:...
FAILED tests/test_testing.py::test_redirect_keep_session - LookupError: <Cont...
FAILED tests/test_testing.py::test_session_transactions - AttributeError: 'Re...
FAILED tests/test_testing.py::test_session_transactions_no_null_sessions - At...
FAILED tests/test_testing.py::test_test_client_context_binding - LookupError:...
FAILED tests/test_testing.py::test_reuse_client - LookupError: <ContextVar na...
FAILED tests/test_testing.py::test_full_url_request - LookupError: <ContextVa...
FAILED tests/test_testing.py::test_json_request_and_response - LookupError: <...
FAILED tests/test_testing.py::test_client_json_no_app_context - AttributeErro...
FAILED tests/test_testing.py::test_subdomain - AttributeError: 'RequestContex...
FAILED tests/test_testing.py::test_nosubdomain - AttributeError: 'RequestCont...
FAILED tests/test_user_error_handler.py::test_error_handler_no_match - Attrib...
FAILED tests/test_user_error_handler.py::test_error_handler_subclass - Attrib...
FAILED tests/test_user_error_handler.py::test_error_handler_http_subclass - A...
FAILED tests/test_user_error_handler.py::test_error_handler_blueprint - Attri...
FAILED tests/test_user_error_handler.py::test_default_error_handler - Attribu...
FAILED tests/test_user_error_handler.py::TestGenericHandlers::test_handle_class_or_code[InternalServerError]
FAILED tests/test_user_error_handler.py::TestGenericHandlers::test_handle_class_or_code[500]
FAILED tests/test_user_error_handler.py::TestGenericHandlers::test_handle_generic_http
FAILED tests/test_user_error_handler.py::TestGenericHandlers::test_handle_generic
FAILED tests/test_views.py::test_basic_view - AttributeError: 'RequestContext...
FAILED tests/test_views.py::test_method_based_view - AttributeError: 'Request...
FAILED tests/test_views.py::test_view_patching - AttributeError: 'RequestCont...
FAILED tests/test_views.py::test_view_inheritance - AttributeError: 'RequestC...
FAILED tests/test_views.py::test_view_decorators - AttributeError: 'RequestCo...
FAILED tests/test_views.py::test_view_provide_automatic_options_attr - Attrib...
FAILED tests/test_views.py::test_implicit_head - AttributeError: 'RequestCont...
FAILED tests/test_views.py::test_explicit_head - AttributeError: 'RequestCont...
FAILED tests/test_views.py::test_endpoint_override - AttributeError: 'Request...
FAILED tests/test_views.py::test_methods_var_inheritance - AttributeError: 'R...
FAILED tests/test_views.py::test_multiple_inheritance - AttributeError: 'Requ...
FAILED tests/test_views.py::test_remove_method_from_parent - AttributeError: ...
FAILED tests/test_views.py::test_init_once - AttributeError: 'RequestContext'...
ERROR tests/test_basic.py::test_flashes - AttributeError: 'RequestContext' ob...
ERROR tests/test_basic.py::test_make_response - AttributeError: 'RequestConte...
ERROR tests/test_basic.py::test_make_response_with_response_instance - Attrib...
ERROR tests/test_basic.py::test_jsonify_mimetype - AttributeError: 'RequestCo...
ERROR tests/test_basic.py::test_json_dump_dataclass - AttributeError: 'Reques...
ERROR tests/test_basic.py::test_jsonify_args_and_kwargs_check - AttributeErro...
ERROR tests/test_basic.py::test_url_generation - AttributeError: 'RequestCont...
ERROR tests/test_helpers.py::TestSendfile::test_send_file - AttributeError: '...
ERROR tests/test_helpers.py::TestSendfile::test_static_file - AttributeError:...
ERROR tests/test_helpers.py::TestSendfile::test_send_from_directory - Attribu...
ERROR tests/test_helpers.py::TestUrlFor::test_url_for_with_anchor - Attribute...
ERROR tests/test_helpers.py::TestUrlFor::test_url_for_with_scheme - Attribute...
ERROR tests/test_helpers.py::TestUrlFor::test_url_for_with_scheme_not_external
ERROR tests/test_helpers.py::TestUrlFor::test_url_for_with_alternating_schemes
ERROR tests/test_helpers.py::TestUrlFor::test_url_with_method - AttributeErro...
ERROR tests/test_helpers.py::TestUrlFor::test_url_for_with_self - AttributeEr...
ERROR tests/test_json.py::test_tojson_filter - AttributeError: 'RequestContex...
ERROR tests/test_templating.py::test_escaping_without_template_filename - Att...
ERROR tests/test_templating.py::test_macros - AttributeError: 'RequestContext...
ERROR tests/test_testing.py::test_environ_defaults - AttributeError: 'Request...
ERROR tests/test_testing.py::test_session_transactions_keep_context - Attribu...
ERROR tests/test_testing.py::test_client_pop_all_preserved - AttributeError: ...
241 failed, 211 passed, 7 skipped, 22 errors in 14.91s
