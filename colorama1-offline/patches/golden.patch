diff --git a/colorama/ansitowin32.py b/colorama/ansitowin32.py
index 281c16d..6d87c9b 100644
--- a/colorama/ansitowin32.py
+++ b/colorama/ansitowin32.py
@@ -1,7 +1,7 @@
 # Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
+import os
 import re
 import sys
-import os
 
 from .ansi import AnsiFore, AnsiBack, AnsiStyle, Style, BEL
 from .winterm import enable_vt_processing, WinTerm, WinColor, WinStyle
@@ -13,12 +13,13 @@ if windll is not None:
     winterm = WinTerm()
 
 
-class StreamWrapper:
-    '''
+class StreamWrapper(object):
+    """
     Wraps a stream (such as stdout), acting as a transparent proxy for all
-    attribute access apart from method 'write()', which is delegated to our
+    attribute access apart from method ``write()``, which is delegated to our
     Converter instance.
-    '''
+    """
+
     def __init__(self, wrapped, converter):
         # double-underscore everything to prevent clashes with names of
         # attributes on the wrapped stream object.
@@ -44,10 +45,32 @@ class StreamWrapper:
         return self.__dict__
 
     def write(self, text):
-        pass
+        """
+        Proxy writes through the owning :class:`AnsiToWin32` instance so that
+        ANSI sequences can be stripped / converted as needed.
+        """
+        self.__convertor.write(text)
 
     def isatty(self):
-        return True
+        """
+        Return True if the underlying stream is considered a TTY.
+
+        Includes a special-case for the PyCharm-hosted console, which reports
+        ``isatty() == False`` even though it behaves like an interactive
+        terminal.
+        """
+        stream = self.__wrapped
+
+        if "PYCHARM_HOSTED" in os.environ:
+            if stream is not None and (stream is sys.__stdout__ or stream is sys.__stderr__):
+                return True
+
+        try:
+            stream_isatty = stream.isatty
+        except AttributeError:
+            return False
+        else:
+            return stream_isatty()
 
     @property
     def closed(self):
@@ -60,14 +83,17 @@ class StreamWrapper:
             return True
 
 
-class AnsiToWin32:
-    '''
-    Implements a 'write()' method which, on Windows, will strip ANSI character
-    sequences from the text, and if outputting to a tty, will convert them into
-    win32 function calls.
-    '''
-    ANSI_CSI_RE = re.compile('BROKEN[')
-    ANSI_OSC_RE = re.compile('BROKEN[')
+class AnsiToWin32(object):
+    """
+    Implements a :meth:`write` method which, on Windows, will strip ANSI
+    character sequences from the text, and if outputting to a tty, will convert
+    them into win32 function calls.
+    """
+
+    # Control Sequence Introducer (e.g. ESC [ 31m)
+    ANSI_CSI_RE = re.compile("\001?\033\\[((?:\\d|;)*)([a-zA-Z])\002?")
+    # Operating System Command (e.g. ESC ] 0;title BEL)
+    ANSI_OSC_RE = re.compile("\001?\033\\]([^\a]*)(\a)\002?")
 
     def __init__(self, wrapped, convert=None, strip=None, autoreset=False):
         # The wrapped stream (normally sys.stdout or sys.stderr)
@@ -79,27 +105,43 @@ class AnsiToWin32:
         # create the proxy wrapping our output stream
         self.stream = StreamWrapper(wrapped, self)
 
-        on_windows = os.name == 'nt'
+        on_windows = os.name == "nt"
+
         # We test if the WinAPI works, because even if we are on Windows
         # we may be using a terminal that doesn't support the WinAPI
         # (e.g. Cygwin Terminal). In this case it's up to the terminal
         # to support the ANSI codes.
         conversion_supported = on_windows and winapi_test()
+
+        # Try to determine whether the system already supports ANSI VT
+        # sequences natively. On modern Windows consoles this is done by
+        # enabling VT-processing mode; on non-Windows we assume native ANSI.
+        fd = None
         try:
             fd = wrapped.fileno()
         except Exception:
-            fd = -1
-        system_has_native_ansi = not on_windows or enable_vt_processing(fd)
-        have_tty = not self.stream.closed and self.stream.isatty()
+            # Not all streams provide fileno() (e.g. some mocks, StringIO).
+            fd = None
+
+        if fd is not None:
+            # enable_vt_processing() internally handles OSError / TypeError
+            # (e.g. when fd is a Mock in tests) and returns a boolean.
+            system_has_native_ansi = (not on_windows) or enable_vt_processing(fd)
+        else:
+            system_has_native_ansi = not on_windows
+
+        have_tty = (not self.stream.closed) and self.stream.isatty()
         need_conversion = conversion_supported and not system_has_native_ansi
 
         # should we strip ANSI sequences from our output?
         if strip is None:
+            # If we need conversion, or we're not on a tty, we strip.
             strip = need_conversion or not have_tty
         self.strip = strip
 
-        # should we should convert ANSI sequences into win32 calls?
+        # should we convert ANSI sequences into win32 calls?
         if convert is None:
+            # Only convert if we both *need* it and are writing to a tty.
             convert = need_conversion and have_tty
         self.convert = convert
 
@@ -110,19 +152,19 @@ class AnsiToWin32:
         self.on_stderr = self.wrapped is sys.stderr
 
     def should_wrap(self):
-        '''
-        True if this class is actually needed. If false, then the output
+        """
+        True if this class is actually needed. If False, then the output
         stream will not be affected, nor will win32 calls be issued, so
         wrapping stdout is not actually required. This will generally be
         False on non-Windows platforms, unless optional functionality like
         autoreset has been requested using kwargs to init()
-        '''
+        """
         return self.convert or self.strip or self.autoreset
 
     def get_win32_calls(self):
         if self.convert and winterm:
             return {
-                AnsiStyle.RESET_ALL: (winterm.reset_all, ),
+                AnsiStyle.RESET_ALL: (winterm.reset_all,),
                 AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),
                 AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),
                 AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),
@@ -134,7 +176,7 @@ class AnsiToWin32:
                 AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),
                 AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),
                 AnsiFore.WHITE: (winterm.fore, WinColor.GREY),
-                AnsiFore.RESET: (winterm.fore, ),
+                AnsiFore.RESET: (winterm.fore,),
                 AnsiFore.LIGHTBLACK_EX: (winterm.fore, WinColor.BLACK, True),
                 AnsiFore.LIGHTRED_EX: (winterm.fore, WinColor.RED, True),
                 AnsiFore.LIGHTGREEN_EX: (winterm.fore, WinColor.GREEN, True),
@@ -151,7 +193,7 @@ class AnsiToWin32:
                 AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),
                 AnsiBack.CYAN: (winterm.back, WinColor.CYAN),
                 AnsiBack.WHITE: (winterm.back, WinColor.GREY),
-                AnsiBack.RESET: (winterm.back, ),
+                AnsiBack.RESET: (winterm.back,),
                 AnsiBack.LIGHTBLACK_EX: (winterm.back, WinColor.BLACK, True),
                 AnsiBack.LIGHTRED_EX: (winterm.back, WinColor.RED, True),
                 AnsiBack.LIGHTGREEN_EX: (winterm.back, WinColor.GREEN, True),
@@ -172,20 +214,18 @@ class AnsiToWin32:
         if self.autoreset:
             self.reset_all()
 
-
     def reset_all(self):
         if self.convert:
-            self.call_win32('m', (0,))
+            self.call_win32("m", (0,))
         elif not self.strip and not self.stream.closed:
             self.wrapped.write(Style.RESET_ALL)
 
-
     def write_and_convert(self, text):
-        '''
+        """
         Write the given text to our wrapped stream, stripping any ANSI
         sequences from the text, and optionally converting them into win32
         calls.
-        '''
+        """
         cursor = 0
         text = self.convert_osc(text)
         for match in self.ANSI_CSI_RE.finditer(text):
@@ -195,39 +235,45 @@ class AnsiToWin32:
             cursor = end
         self.write_plain_text(text, cursor, len(text))
 
-
     def write_plain_text(self, text, start, end):
         if start < end:
             self.wrapped.write(text[start:end])
             self.wrapped.flush()
 
-
     def convert_ansi(self, paramstring, command):
         if self.convert:
             params = self.extract_params(command, paramstring)
             self.call_win32(command, params)
 
-
     def extract_params(self, command, paramstring):
-        if command in 'Hf':
-            params = tuple(int(p) if len(p) != 0 else 1 for p in paramstring.split(';'))
+        if command in "Hf":
+            params = tuple(
+                int(p) if len(p) != 0 else 1 for p in paramstring.split(";")
+            )
             while len(params) < 2:
                 # defaults:
                 params = params + (1,)
         else:
-            params = tuple(int(p) for p in paramstring.split(';') if len(p) != 0)
+            params = tuple(
+                int(p) for p in paramstring.split(";") if len(p) != 0
+            )
             if len(params) == 0:
                 # defaults:
-                if command in 'JKm':
+                if command in "JKm":
                     params = (0,)
-                elif command in 'ABCD':
+                elif command in "ABCD":
                     params = (1,)
-
         return params
 
-
     def call_win32(self, command, params):
-        if command == 'm':
+        """
+        Dispatch parsed ANSI commands to the appropriate Win32 calls.
+
+        Note: this uses the `win32_calls` lookup even if the module-level
+        `winterm` is None, which is required for the tests that monkeypatch
+        `win32_calls` directly.
+        """
+        if command == "m":
             for param in params:
                 if param in self.win32_calls:
                     func_args = self.win32_calls[param]
@@ -235,34 +281,36 @@ class AnsiToWin32:
                     args = func_args[1:]
                     kwargs = dict(on_stderr=self.on_stderr)
                     func(*args, **kwargs)
-        elif command in 'J':
+        elif command in "J" and winterm:
             winterm.erase_screen(params[0], on_stderr=self.on_stderr)
-        elif command in 'K':
+        elif command in "K" and winterm:
             winterm.erase_line(params[0], on_stderr=self.on_stderr)
-        elif command in 'Hf':     # cursor position - absolute
+        elif command in "Hf" and winterm:  # cursor position - absolute
             winterm.set_cursor_position(params, on_stderr=self.on_stderr)
-        elif command in 'ABCD':   # cursor position - relative
+        elif command in "ABCD" and winterm:  # cursor position - relative
             n = params[0]
             # A - up, B - down, C - forward, D - back
-            x, y = {'A': (0, -n), 'B': (0, n), 'C': (n, 0), 'D': (-n, 0)}[command]
+            x, y = {"A": (0, -n), "B": (0, n), "C": (n, 0), "D": (-n, 0)}[command]
             winterm.cursor_adjust(x, y, on_stderr=self.on_stderr)
 
-
     def convert_osc(self, text):
+        """
+        Strip Operating System Command (OSC) sequences (such as title changes)
+        from *text*, optionally updating the console window title on Windows.
+        """
         for match in self.ANSI_OSC_RE.finditer(text):
             start, end = match.span()
             text = text[:start] + text[end:]
             paramstring, command = match.groups()
-            if command == BEL:
+            if command == BEL and winterm:
                 if paramstring.count(";") == 1:
                     params = paramstring.split(";")
                     # 0 - change title and icon (we will only change title)
                     # 1 - change icon (we don't support this)
                     # 2 - change title
-                    if params[0] in '02':
+                    if params[0] in "02":
                         winterm.set_title(params[1])
         return text
 
-
     def flush(self):
         self.wrapped.flush()
